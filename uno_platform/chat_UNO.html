<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNO Construction Intelligence Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .chat-container {
            height: 100vh;
            display: flex;
        }
        .chat-panel {
            width: 50%;
            border-right: 1px solid #e5e7eb;
        }
        .chart-panel {
            width: 50%;
            background-color: #f9fafb;
        }
        .chat-history {
            height: calc(100vh - 140px);
            overflow-y: auto;
            padding: 1rem;
        }
        .tile-hover:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        .animate-pulse {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }
    </style>
</head>
<body>
    <div id="loading" class="h-screen flex items-center justify-center hidden">
        <div class="animate-pulse text-center">
            <svg class="w-12 h-12 text-gray-400 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
            </svg>
            <p class="text-gray-500">Analyzing your construction data...</p>
        </div>
    </div>

    <!-- Loading Section -->
    <div id="loading-section" class="h-screen flex items-center justify-center bg-gray-50">
        <div class="max-w-md w-full bg-white p-8 rounded-lg shadow-lg">
            <div class="text-center">
                <div class="animate-spin w-12 h-12 border-4 border-blue-500 border-t-transparent rounded-full mx-auto mb-4"></div>
                <h2 class="text-2xl font-bold text-gray-900 mb-2">Construction Intelligence Assistant</h2>

                <p class="text-gray-600">Loading UNO project data...</p>
            </div>
        </div>
    </div>

    <div id="chat-app" class="chat-container hidden">
        <!-- Left Panel - Chat Interface -->
        <div class="chat-panel">
            <div class="h-full flex flex-col">
                <!-- Header -->
                <div class="border-b border-gray-200 p-4">
                    <div class="flex items-center justify-between">
                        <h2 class="text-lg font-semibold text-gray-900 flex items-center gap-2">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"/>
                            </svg>
                            Construction Intelligence Assistant
                        </h2>
                        <div class="flex items-center gap-3">
                            <a href="https://alicia-li-auckland.github.io/toys/uno_platform/" class="inline-flex items-center px-3 py-2 text-sm font-medium text-blue-600 bg-blue-50 border border-blue-200 rounded-lg hover:bg-blue-100 hover:text-blue-700 transition-colors duration-200">
                                <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
                                </svg>
                                Back to Platform
                            </a>
                            <button onclick="reloadData()" class="text-sm text-blue-600 hover:text-blue-800">
                                Upload New Data
                            </button>
                        </div>
                    </div>
                    <div class="mt-2">
                        <p class="text-sm text-gray-600" id="data-stats">No data loaded</p>
                    </div>
                </div>

                <!-- Chat Messages -->
                <div class="chat-history space-y-4" id="chat-history">
                    <!-- Messages will be populated by JavaScript -->
                </div>

                <!-- Chat Input -->
                <div class="border-t border-gray-200 p-4">
                    <div class="flex space-x-2">
                        <input 
                            type="text" 
                            id="chat-input" 
                            placeholder="Ask a question about your construction data..."
                            class="flex-1 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                            onkeypress="handleKeyPress(event)"
                        >
                        <button 
                            onclick="sendMessage()" 
                            class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                            id="send-button"
                        >
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Panel - Charts -->
        <div class="chart-panel" id="chart-panel">
            <div class="h-full flex items-center justify-center hidden" id="default-chart-view">
                <div class="text-center">
                    <svg class="w-16 h-16 text-gray-400 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
                    </svg>
                    <h3 class="text-lg font-semibold text-gray-900 mb-2">Click an Insight to See Details</h3>
                    <p class="text-gray-600">Select any clickable insight from the chat to view detailed charts and analysis.</p>
                </div>
            </div>

            <!-- Executive Dashboard (copied from dashboard-simple_UNO.html) -->
            <div id="executive-dashboard" class="h-full overflow-y-auto p-6">
                <h2 class="text-xl font-bold text-gray-900 mb-6">Executive Summary</h2>
                
                <!-- Row 1: Key Metrics Cards -->
                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6 mb-6">
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                        <div class="flex items-center justify-between">
                            <div>
                                <p class="text-sm font-medium text-gray-600">Project Completion</p>
                                <p class="text-3xl font-bold text-blue-600" id="completion-rate">0%</p>
                                <p class="text-xs text-gray-500" id="completion-tasks">0 of 0 tasks</p>
                            </div>
                            <div class="w-10 h-10 bg-blue-100 rounded-full flex items-center justify-center">
                                <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                </svg>
                            </div>
                        </div>
                    </div>

                    <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                        <div class="flex items-center justify-between">
                            <div>
                                <p class="text-sm font-medium text-gray-600">Completion Rate</p>
                                <p class="text-3xl font-bold text-green-600" id="work-velocity">0</p>
                                <p class="text-xs text-gray-500">tasks/day average</p>
                            </div>
                            <div class="w-10 h-10 bg-green-100 rounded-full flex items-center justify-center">
                                <svg class="w-6 h-6 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path>
                                </svg>
                            </div>
                        </div>
                    </div>

                    <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                        <div class="flex items-center justify-between">
                            <div>
                                <p class="text-sm font-medium text-gray-600">Active Trades</p>
                                <p class="text-3xl font-bold text-purple-600" id="active-trades">0</p>
                                <p class="text-xs text-gray-500">currently working</p>
                            </div>
                            <div class="w-10 h-10 bg-purple-100 rounded-full flex items-center justify-center">
                                <svg class="w-6 h-6 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                                </svg>
                            </div>
                        </div>
                    </div>

                    <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                        <div class="flex items-center justify-between">
                            <div>
                                <p class="text-sm font-medium text-gray-600">Active Locations</p>
                                <p class="text-3xl font-bold text-orange-600" id="active-locations">0</p>
                                <p class="text-xs text-gray-500">with ongoing work</p>
                            </div>
                            <div class="w-10 h-10 bg-orange-100 rounded-full flex items-center justify-center">
                                <svg class="w-6 h-6 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"></path>
                                </svg>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Key Insights & Actions -->
                <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200 mb-6">
                    <h3 class="text-lg font-semibold text-gray-900 mb-4 flex items-center gap-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                        </svg>
                        Key Insights & Actions
                    </h3>
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-4" id="insights-container">
                        <!-- Insights will be populated by JavaScript -->
                    </div>
                </div>

                <!-- Project Milestone Timeline -->
                <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                    <h3 class="text-lg font-semibold text-gray-900 mb-6 flex items-center gap-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                        </svg>
                        Project Milestone Timeline
                    </h3>
                    
                    <!-- Timeline visualization -->
                    <div class="relative">
                        <!-- Timeline line -->
                        <div class="absolute left-6 top-0 bottom-0 w-0.5 bg-gray-300"></div>
                        
                        <div class="max-h-none overflow-visible" id="timeline-container">
                            <!-- Timeline items will be populated by JavaScript -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Chart containers (hidden by default) -->
            <div id="trade-progress-chart" class="h-full overflow-y-auto hidden"></div>
            <div id="level-comparison-chart" class="h-full overflow-y-auto hidden"></div>
            <div id="velocity-trend-chart" class="h-full overflow-y-auto hidden"></div>
            <div id="velocity-comparison-chart" class="h-full overflow-y-auto hidden"></div>
            <div id="stalled-trades-chart" class="h-full overflow-y-auto hidden"></div>
            <div id="stacked-trades-chart" class="h-full overflow-y-auto hidden"></div>
            <div id="burst-start-chart" class="h-full overflow-y-auto hidden"></div>
            <div id="swiss-cheese-chart" class="h-full overflow-y-auto hidden"></div>
            <div id="trade-blockage-chart" class="h-full overflow-y-auto hidden"></div>
            <div id="premature-start-chart" class="h-full overflow-y-auto hidden"></div>
        </div>
    </div>

    <script>
        // Data will be loaded from uploaded CSV only

        // Helper function to check if a task is in progress (handles both formats)
        function isInProgress(state) {
            return state === 'in progress' || state === 'in-progress';
        }

        let dashboardData = null;
        let chatHistory = [];
        let selectedInsight = null;
        let activeChart = null;
        let currentData = [];
        
        // Removed API configuration - using local chatbot logic

        // Centralized trade ordering function (copied exactly from dashboard-simple_UNO.html)
        function getOrderedTrades(availableTrades) {
            const tradeOrder = [
                'Concrete Formwork',
                'Concrete Rebar',
                'Backfill',
                'Electrical Yard Equipment Conduit',
                'Structural Piles',
                'Concrete Pour',
                'Structural Steel',
                'Generator Placement',
                'DWTR Installation',
                'MWT Installation',
                'Mechanical Yard - Equipment Placement',
                'Electrical Yard 96 Equipment Placement',
                'Conveyance',
                'Booster Pump System Installation',
                'Roofing Metal Deck',
                'Roofing Insulation',
                'Roofing Membrane',
                'Roofing Flashing'
            ];
            
            // Function to normalize trade names for comparison
            function normalizeTradeForComparison(trade) {
                return trade.toLowerCase()
                    .replace(/[-\s]+/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();
            }
            
            // Get trades in preferred order first
            const orderedTrades = tradeOrder.filter(orderTrade => {
                return availableTrades.some(availableTrade => {
                    const normalizedOrder = normalizeTradeForComparison(orderTrade);
                    const normalizedAvailable = normalizeTradeForComparison(availableTrade);
                    return normalizedOrder === normalizedAvailable || 
                           normalizedAvailable.includes(normalizedOrder) ||
                           normalizedOrder.includes(normalizedAvailable);
                });
            }).map(orderTrade => {
                return availableTrades.find(availableTrade => {
                    const normalizedOrder = normalizeTradeForComparison(orderTrade);
                    const normalizedAvailable = normalizeTradeForComparison(availableTrade);
                    return normalizedOrder === normalizedAvailable || 
                           normalizedAvailable.includes(normalizedOrder) ||
                           normalizedOrder.includes(normalizedAvailable);
                });
            });
            
            // Add any trades not in the sequence at the end
            const otherTrades = availableTrades.filter(trade => !orderedTrades.includes(trade)).sort();
            return [...orderedTrades, ...otherTrades];
        }

        // Automatically load UNO data
        async function autoLoadUNOData() {
            try {
                showLoadingScreen();
                console.log('ðŸ”¥ LOADING UNO_construction_data_fixed.csv - ENSURING CLEAN DATA');
                const response = await fetch('UNO_construction_data_fixed.csv');
                
                if (!response.ok) {
                    throw new Error(`Failed to load data: ${response.status}`);
                }
                
                const csvContent = await response.text();
                console.log('ðŸ“Š Raw CSV loaded, length:', csvContent.length);
                const data = parseCSV(csvContent);
                console.log('ðŸ“‹ Parsed CSV data:', data.length, 'total records');
                
                // Validate we have the right UNO data
                const uniqueTrades = [...new Set(data.map(row => row.trade))].sort();
                console.log('ðŸ”§ Unique trades found:', uniqueTrades);
                console.log('ðŸ“Š Trade counts:', uniqueTrades.map(trade => 
                    `${trade}: ${data.filter(row => row.trade === trade).length}`
                ));
                
                // Check for any WhartonSmith contamination
                const suspiciousWhartonTrades = ['Wall Drywall', 'Wall Prime Paint', 'In Wall Insulation', 'Overhead Plumbing'];
                const contamination = suspiciousWhartonTrades.filter(trade => uniqueTrades.includes(trade));
                if (contamination.length > 0) {
                    console.error('âŒ CONTAMINATION DETECTED:', contamination);
                    throw new Error(`WhartonSmith data contamination detected: ${contamination.join(', ')}`);
                }
                
                // Validate required columns
                const requiredFields = ['location', 'trade', 'state', 'capture_date'];
                const headers = Object.keys(data[0] || {});
                const missingFields = requiredFields.filter(field => !headers.includes(field));

                if (missingFields.length > 0) {
                    throw new Error(`Missing required columns: ${missingFields.join(', ')}`);
                }

                currentData = data;
                await loadAndAnalyzeData();
                
            } catch (error) {
                console.error('Error loading UNO data:', error);
                showLoadingError(error.message);
            }
        }

        function showLoadingScreen() {
            document.getElementById('loading-section').classList.remove('hidden');
            document.getElementById('chat-app').classList.add('hidden');
        }

        function showLoadingError(message) {
            const loadingSection = document.getElementById('loading-section');
            loadingSection.innerHTML = `
                <div class="max-w-md w-full bg-white p-8 rounded-lg shadow-lg">
                    <div class="text-center">
                        <svg class="w-12 h-12 text-red-500 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16c-.77.833.192 2.5 1.732 2.5z"/>
                        </svg>
                        <h2 class="text-2xl font-bold text-gray-900 mb-2">Error Loading Data</h2>
                        <p class="text-gray-600">${message}</p>
                        <button onclick="autoLoadUNOData()" class="mt-4 bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">
                            Retry
                        </button>
                    </div>
                </div>
            `;
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            autoLoadUNOData();
        });

        // Initialize upload functionality
        function initUpload() {
            const dropzone = document.getElementById('dropzone');
            const csvFile = document.getElementById('csvFile');


            // Dropzone click handler
            dropzone.addEventListener('click', () => {
                csvFile.click();
            });

            // Drag and drop handlers
            dropzone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropzone.classList.add('border-blue-400', 'bg-blue-50');
            });

            dropzone.addEventListener('dragleave', () => {
                dropzone.classList.remove('border-blue-400', 'bg-blue-50');
            });

            dropzone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropzone.classList.remove('border-blue-400', 'bg-blue-50');
                
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type === 'text/csv') {
                    handleFileUpload(files[0]);
                }
            });

            // File selection handler
            csvFile.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileUpload(e.target.files[0]);
                }
            });


        }

        function handleFileUpload(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvContent = e.target.result;
                    parseCSV(csvContent);
                } catch (error) {
                    showError('Error reading file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function parseCSV(csvContent) {
            try {
                const lines = csvContent.trim().split('\n');
                if (lines.length < 2) {
                    throw new Error('CSV file must have at least a header and one data row');
                }

                const headers = lines[0].split(',').map(h => h.replace(/"/g, '').trim());
                const data = [];

                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',').map(v => v.replace(/"/g, '').trim());
                    if (values.length === headers.length && values.some(v => v !== '')) {
                        const row = {};
                        headers.forEach((header, index) => {
                            // Handle flexible column mapping
                            const normalizedHeader = header.toLowerCase();
                            if (normalizedHeader.includes('level') || normalizedHeader.includes('floor')) {
                                row['level / floor'] = values[index] || null;
                            } else if (normalizedHeader.includes('state') || normalizedHeader.includes('status')) {
                                row.state = values[index] || null;
                            } else if (normalizedHeader.includes('capture') && normalizedHeader.includes('date')) {
                                row.capture_date = values[index] || null;
                            } else if (normalizedHeader.includes('complete') && normalizedHeader.includes('date')) {
                                row.complete_date = values[index] || null;
                            } else {
                                row[header] = values[index] || null;
                            }
                        });
                        data.push(row);
                    }
                }

                if (data.length === 0) {
                    throw new Error('No valid data rows found in CSV');
                }

                // Validate required columns
                const requiredFields = ['trade', 'location'];
                const missingFields = requiredFields.filter(field => 
                    !data[0].hasOwnProperty(field) || data.every(row => !row[field])
                );

                if (missingFields.length > 0) {
                    throw new Error(`Missing required columns: ${missingFields.join(', ')}`);
                }

                // Clear any existing data completely
                currentData = [];
                chatHistory = [];
                
                // Load fresh UNO data
                currentData = data;
                console.log('âœ… CLEAN DATA LOADED - currentData length:', currentData.length);
                console.log('ðŸŽ¯ Sample record:', currentData[0]);
                
                loadAndAnalyzeData();

            } catch (error) {
                showError('Error parsing CSV: ' + error.message);
            }
        }



        function showProgress(message) {
            // Update loading screen with progress message
            const loadingSection = document.getElementById('loading-section');
            if (loadingSection) {
                const existingMessage = loadingSection.querySelector('p');
                if (existingMessage) {
                    existingMessage.textContent = message;
                }
            }
        }

        function showError(message) {
            showLoadingError(message);
        }

        function reloadData() {
            // Reset everything and reload UNO data
            chatHistory = [];
            selectedInsight = null;
            activeChart = null;
            dashboardData = null;
            currentData = [];
            
            document.getElementById('chat-app').classList.add('hidden');
            autoLoadUNOData();
        }

        async function loadAndAnalyzeData() {
            try {
                // Use uploaded data
                const analysis = analyzeData(currentData);
                dashboardData = analysis;
                
                // Update data statistics display
                updateDataStats();
                
                // Reset chat history and generate new insights
                chatHistory = [];
                generateInitialInsights(analysis);
                
                // Hide loading and show chat
                document.getElementById('loading-section').classList.add('hidden');
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('chat-app').classList.remove('hidden');
            } catch (error) {
                console.error('Error loading data:', error);
                showError('Error analyzing data: ' + error.message);
            }
        }

        function updateDataStats() {
            // Count unique location-trade combinations (actual tasks)
            const uniqueTasks = new Set(currentData.map(row => `${row.location}_${row.trade}`));
            const totalTasks = uniqueTasks.size;
            const uniqueTrades = [...new Set(currentData.map(row => row.trade))].length;
            const uniqueLocations = [...new Set(currentData.map(row => row.location))].length;
            
            document.getElementById('data-stats').textContent = 
                `${totalTasks} tasks â€¢ ${uniqueTrades} trades â€¢ ${uniqueLocations} locations`;
        }

        // Velocity Comparison Analysis - with proper 'no data' handling
        function analyzeVelocityComparison(data) {
            const captureDates = [...new Set(data.map(row => row.capture_date))].sort();
            const startTransitions = {};
            const completionTransitions = {};
            
            captureDates.forEach(date => {
                startTransitions[date] = 0;
                completionTransitions[date] = 0;
            });
            
            const taskStates = {};
            // Only process valid states, skip 'no data' entries
            data.filter(row => row.state !== 'no data').forEach(row => {
                const taskKey = `${row.location}_${row.trade}`;
                if (!taskStates[taskKey]) {
                    taskStates[taskKey] = [];
                }
                taskStates[taskKey].push({
                    date: row.capture_date,
                    state: row.state
                });
            });
            
            Object.values(taskStates).forEach(taskHistory => {
                taskHistory.sort((a, b) => a.date.localeCompare(b.date));
                
                for (let i = 1; i < taskHistory.length; i++) {
                    const prev = taskHistory[i - 1];
                    const curr = taskHistory[i];
                    
                    if (prev.state === 'not started' && curr.state === 'in progress') {
                        startTransitions[curr.date]++;
                    }
                    
                    if (prev.state === 'in progress' && curr.state === 'complete') {
                        completionTransitions[curr.date]++;
                    }
                }
            });
            
            return {
                dates: captureDates,
                starts: captureDates.map(date => startTransitions[date]),
                completions: captureDates.map(date => completionTransitions[date])
            };
        }

        // Enhanced Anomaly Detection - same as dashboard with renamed anomalies
        function detectEnhancedAnomalies(data) {
            const anomalies = {
                stalledTrades: detectStalledTrades(data),
                stackedTrades: detectStackedTrades(data),
                burstStart: detectBurstStart(data),
                swissCheese: detectSwissCheese(data),
                tradeBlockage: detectTradeBlockage(data),
                prematureStart: detectPrematureStart(data)
            };
            
            return anomalies;
        }

        function detectStalledTrades(data) {
            const stalledTasks = [];
            const taskStates = {};
            
            // Only process valid states, skip 'no data' entries
            data.filter(row => row.state !== 'no data').forEach(row => {
                const taskKey = `${row.location}_${row.trade}`;
                if (!taskStates[taskKey]) {
                    taskStates[taskKey] = [];
                }
                taskStates[taskKey].push({
                    date: row.capture_date,
                    state: row.state,
                    location: row.location,
                    trade: row.trade
                });
            });
            
            Object.values(taskStates).forEach(taskHistory => {
                taskHistory.sort((a, b) => a.date.localeCompare(b.date));
                
                const inProgressDates = taskHistory.filter(t => t.state === 'in progress' || t.state === 'in-progress');
                if (inProgressDates.length >= 3) {
                    stalledTasks.push({
                        location: taskHistory[0].location,
                        trade: taskHistory[0].trade,
                        duration: inProgressDates.length
                    });
                }
            });
            
            return stalledTasks;
        }

        function detectStackedTrades(data) {
            const stackedLocations = [];
            const captureDates = [...new Set(data.map(row => row.capture_date))];
            
            captureDates.forEach(date => {
                const dayData = data.filter(row => row.capture_date === date && row.state !== 'no data');
                const locationGroups = {};
                
                dayData.filter(row => row.state === 'in progress' || row.state === 'in-progress').forEach(row => {
                    if (!locationGroups[row.location]) {
                        locationGroups[row.location] = [];
                    }
                    locationGroups[row.location].push(row.trade);
                });
                
                Object.entries(locationGroups).forEach(([location, trades]) => {
                    const uniqueTrades = [...new Set(trades)];
                    if (uniqueTrades.length >= 2) {
                        stackedLocations.push({
                            location: location,
                            date: date,
                            trades: uniqueTrades,
                            count: uniqueTrades.length
                        });
                    }
                });
            });
            
            return stackedLocations;
        }

        function detectBurstStart(data) {
            const startsByWeek = {};
            const captureDates = [...new Set(data.map(row => row.capture_date))].sort();
            
            captureDates.forEach(date => {
                const dateObj = new Date(date);
                const weekStart = new Date(dateObj);
                weekStart.setDate(dateObj.getDate() - dateObj.getDay());
                const weekKey = weekStart.toISOString().split('T')[0];
                
                if (!startsByWeek[weekKey]) {
                    startsByWeek[weekKey] = 0;
                }
                
                const starts = data.filter(row => 
                    row.start_date === date && 
                    row.start_date.trim() !== '' && 
                    row.state !== 'no data'
                );
                startsByWeek[weekKey] += starts.length;
            });
            
            const weeklyStarts = Object.values(startsByWeek);
            const average = weeklyStarts.reduce((sum, val) => sum + val, 0) / weeklyStarts.length;
            
            return Object.entries(startsByWeek).filter(([week, starts]) => starts > average * 1.5);
        }

        function detectSwissCheese(data) {
            const locationCompletion = {};
            
            // Use final states to avoid counting 'no data' entries
            const taskStates = {};
            data.forEach(row => {
                const taskKey = `${row.location}_${row.trade}`;
                const captureDate = row.capture_date;
                
                if (row.state === 'no data') return;
                
                if (!taskStates[taskKey] || captureDate > taskStates[taskKey].date) {
                    taskStates[taskKey] = {
                        state: row.state,
                        location: row.location,
                        trade: row.trade
                    };
                }
            });
            
            // Count completion by location using final states
            Object.values(taskStates).forEach(task => {
                if (!locationCompletion[task.location]) {
                    locationCompletion[task.location] = { total: 0, completed: 0 };
                }
                locationCompletion[task.location].total++;
                if (task.state === 'complete') {
                    locationCompletion[task.location].completed++;
                }
            });
            
            const gapLocations = [];
            Object.entries(locationCompletion).forEach(([location, data]) => {
                const percentage = (data.completed / data.total) * 100;
                if (percentage > 30 && percentage < 90) {
                    gapLocations.push({ location, percentage: percentage.toFixed(1) });
                }
            });
            
            return gapLocations;
        }

        function detectTradeBlockage(data) {
            const sections = [...new Set(data.map(row => row.section).filter(Boolean))];
            const blockedTrades = {};
            
            sections.forEach(section => {
                const sectionData = data.filter(row => row.section === section && row.state !== 'no data');
                const inProgressTrades = {};
                
                sectionData.forEach(row => {
                    if (row.state === 'in progress' || row.state === 'in-progress') {
                        const taskKey = `${row.location}_${row.trade}`;
                        if (!inProgressTrades[taskKey]) {
                            inProgressTrades[taskKey] = { trade: row.trade, dates: [] };
                        }
                        inProgressTrades[taskKey].dates.push(row.capture_date);
                    }
                });
                
                const blocked = [];
                Object.values(inProgressTrades).forEach(task => {
                    if (task.dates.length >= 3) {
                        blocked.push(task.trade);
                    }
                });
                
                if (blocked.length > 0) {
                    blockedTrades[section] = [...new Set(blocked)];
                }
            });
            
            return blockedTrades;
        }

        function detectPrematureStart(data) {
            const prematureStarts = [];
            // Implementation would check for trades starting before prerequisites are complete
            // Simplified for now
            return prematureStarts;
        }

        function analyzeData(data) {
            console.log('ðŸ”„ ANALYZING DATA WITH PROPER NO DATA HANDLING');
            
            // Get final state for each unique task, ignoring 'no data' entries
            const taskStates = {};
            data.forEach(row => {
                const taskKey = `${row.location}_${row.trade}`;
                const captureDate = row.capture_date;
                
                // Skip 'no data' entries - they mean location wasn't captured that day
                if (row.state === 'no data') {
                    return;
                }
                
                if (!taskStates[taskKey] || captureDate > taskStates[taskKey].date) {
                    taskStates[taskKey] = {
                        state: row.state,
                        date: captureDate,
                        location: row.location,
                        trade: row.trade,
                        level: row['level / floor'] || 'Unknown'
                    };
                }
            });
            
            const allTaskKeys = Object.keys(taskStates);
            const totalTasks = allTaskKeys.length;
            
            const completedTaskKeys = allTaskKeys.filter(taskKey => 
                taskStates[taskKey].state === 'complete'
            );
            const completedTasks = completedTaskKeys.length;
            
            const inProgressTaskKeys = allTaskKeys.filter(taskKey => 
                isInProgress(taskStates[taskKey].state)
            );
            const inProgressTasks = inProgressTaskKeys.length;
            
            const overallCompletion = totalTasks > 0 ? ((completedTasks / totalTasks) * 100).toFixed(1) : '0.0';
            
            console.log(`ðŸ“Š Final state analysis: ${completedTasks}/${totalTasks} = ${overallCompletion}%`);

            // Level analysis - using final states from taskStates
            const levelGroups = {};
            
            allTaskKeys.forEach(taskKey => {
                const task = taskStates[taskKey];
                const level = task.level;
                
                if (!levelGroups[level]) {
                    levelGroups[level] = { total: 0, completed: 0 };
                }
                
                levelGroups[level].total++;
                if (task.state === 'complete') {
                    levelGroups[level].completed++;
                }
            });

            // Trade analysis - using final states from taskStates
            const tradeGroups = {};
            
            allTaskKeys.forEach(taskKey => {
                const task = taskStates[taskKey];
                const trade = task.trade;
                
                if (!tradeGroups[trade]) {
                    tradeGroups[trade] = { total: 0, completed: 0, inProgress: 0, items: [] };
                }
                
                tradeGroups[trade].total++;
                tradeGroups[trade].items.push(task); // Add final state task info
                
                if (task.state === 'complete') {
                    tradeGroups[trade].completed++;
                } else if (isInProgress(task.state)) {
                    tradeGroups[trade].inProgress++;
                }
            });

            const tradeAnalysis = Object.entries(tradeGroups).map(([trade, tradeData]) => {
                const completionRate = (tradeData.completed / tradeData.total) * 100;
                return {
                    trade,
                    completionRate: completionRate.toFixed(1),
                    completed: tradeData.completed,
                    inProgress: tradeData.inProgress,
                    total: tradeData.total,
                    alertLevel: completionRate < 15 ? 'red' : completionRate < 30 ? 'yellow' : 'green'
                };
            }).sort((a, b) => parseFloat(a.completionRate) - parseFloat(b.completionRate));

            // Velocity analysis - using final states and completion dates
            const velocityData = {};
            
            // Use only tasks with final state 'complete' and valid completion dates
            const completedTasksWithDates = allTaskKeys.filter(taskKey => {
                const task = taskStates[taskKey];
                return task.state === 'complete';
            }).map(taskKey => taskStates[taskKey]);
            
            // Get completion dates from original data for completed tasks
            const uniqueCompletions = new Map();
            data.forEach(item => {
                if (item.state === 'complete' && item.complete_date && item.complete_date.trim() !== '' && item.state !== 'no data') {
                    const taskKey = `${item.location}_${item.trade}`;
                    // Only include if this task's final state is complete
                    if (completedTaskKeys.includes(taskKey)) {
                const key = `${item.location}_${item.trade}_${item.complete_date}`;
                if (!uniqueCompletions.has(key)) {
                    uniqueCompletions.set(key, {
                        date: item.complete_date,
                        trade: item.trade,
                        location: item.location
                    });
                        }
                    }
                }
            });
            
            // Now count unique completions per date/trade
            uniqueCompletions.forEach(completion => {
                const date = completion.date;
                const trade = completion.trade;
                
                if (!velocityData[date]) {
                    velocityData[date] = {};
                }
                if (!velocityData[date][trade]) {
                    velocityData[date][trade] = 0;
                }
                velocityData[date][trade]++;
            });

            const timeSeriesData = Object.entries(velocityData)
                .map(([date, trades]) => ({
                    date: new Date(date),
                    dateStr: date,
                    ...trades
                }))
                .sort((a, b) => a.date - b.date);

            const availableTrades = [...new Set(tradeAnalysis.map(t => t.trade))];
            const allTrades = getOrderedTrades(availableTrades);
            
            // Velocity Comparison Analysis - transitions between states
            const velocityComparison = analyzeVelocityComparison(data);
            
            // Enhanced Anomaly Detection with renamed anomalies
            const anomalies = detectEnhancedAnomalies(data);

            return {
                overview: { totalTasks, completedTasks, inProgressTasks, overallCompletion },
                tradeAnalysis,
                levelAnalysis: levelGroups,
                velocityData: timeSeriesData,
                velocityComparison,
                anomalies,
                allTrades
            };
        }

        // Use the same dashboard functions - copied from dashboard-simple_UNO.html
        function populateExecutiveDashboard(data) {
            console.log('Populating executive dashboard with data:', data);
            console.log('Current raw data length:', currentData.length);
            
            // Use dashboard's updateDataStats logic
            updateDataStats();
            
            // Populate insights and timeline using dashboard functions
            populateInsights();
            populateMilestoneTimeline();
        }

        function updateDataStats() {
            console.log('ðŸ“Š UPDATING DATA STATS');
            console.log('ðŸ“‹ Current data length:', currentData.length);
            
            // Use same logic as milestone timeline - get final state for each unique task
            // Skip 'no data' entries as they mean the location wasn't captured that day
            const taskStates = {};
            currentData.forEach(row => {
                const taskKey = `${row.location}_${row.trade}`;
                const captureDate = row.capture_date;
                
                // Skip 'no data' entries - they mean location wasn't captured that day
                if (row.state === 'no data') {
                    return;
                }
                
                if (!taskStates[taskKey] || captureDate > taskStates[taskKey].date) {
                    taskStates[taskKey] = {
                        state: row.state,
                        date: captureDate,
                        location: row.location,
                        trade: row.trade
                    };
                }
            });
            
            const allTaskKeys = Object.keys(taskStates);
            const totalTasks = allTaskKeys.length;
            console.log('ðŸŽ¯ Unique tasks:', totalTasks);

            const completedTaskKeys = allTaskKeys.filter(taskKey => 
                taskStates[taskKey].state === 'complete'
            );
            const completedTasks = completedTaskKeys.length;
            console.log('âœ… Completed tasks:', completedTasks);

            const inProgressTaskKeys = allTaskKeys.filter(taskKey => 
                isInProgress(taskStates[taskKey].state)
            );
            const inProgressTasks = inProgressTaskKeys.length;

            const activeTrades = new Set(
                inProgressTaskKeys.map(taskKey => taskStates[taskKey].trade)
            ).size;

            const activeLocations = new Set(
                inProgressTaskKeys.map(taskKey => taskStates[taskKey].location)
            ).size;

            const overallCompletion = totalTasks > 0 ? ((completedTasks / totalTasks) * 100).toFixed(1) : '0.0';

            // Calculate completion rate (unique tasks completed per day average)
            // Skip 'no data' entries as they mean the location wasn't captured that day
            const completionsByDate = {};
            const uniqueCompletedByDate = new Set();
            
            currentData.filter(row => 
                row.complete_date && 
                row.complete_date.trim() !== '' && 
                row.state === 'complete' &&
                row.state !== 'no data'  // Skip no data entries
            ).forEach(row => {
                const date = row.complete_date;
                const taskKey = `${row.location}_${row.trade}_${date}`;
                if (!uniqueCompletedByDate.has(taskKey)) {
                    completionsByDate[date] = (completionsByDate[date] || 0) + 1;
                    uniqueCompletedByDate.add(taskKey);
                }
            });
            
            const avgCompletionRate = Object.keys(completionsByDate).length > 0 
                ? (Object.values(completionsByDate).reduce((sum, val) => sum + val, 0) / Object.keys(completionsByDate).length).toFixed(1)
                : '0.0';

            // Update the dashboard elements
            document.getElementById('completion-rate').textContent = `${overallCompletion}%`;
            document.getElementById('completion-tasks').textContent = `${completedTasks} of ${totalTasks} tasks`;
            document.getElementById('work-velocity').textContent = avgCompletionRate;
            document.getElementById('active-trades').textContent = activeTrades;
            document.getElementById('active-locations').textContent = activeLocations;

            console.log('âœ… DASHBOARD UPDATED WITH CLEAN UNO DATA:', {
                totalTasks, completedTasks, inProgressTasks, 
                activeTrades, activeLocations, overallCompletion, avgCompletionRate
            });
            console.log('ðŸŽ¯ KPI Elements updated successfully');
        }

        function populateInsights() {
            const container = document.getElementById('insights-container');
            if (!container) return;

            // Simple insights for now - can be enhanced later
            container.innerHTML = `
                <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                    <h4 class="font-semibold text-blue-900">Project Status</h4>
                    <p class="text-blue-700 text-sm">Project is progressing with ${document.getElementById('active-trades').textContent} active trades across ${document.getElementById('active-locations').textContent} locations.</p>
                </div>
                <div class="bg-green-50 border border-green-200 rounded-lg p-4">
                    <h4 class="font-semibold text-green-900">Completion Rate</h4>
                    <p class="text-green-700 text-sm">Averaging ${document.getElementById('work-velocity').textContent} tasks completed per day.</p>
                </div>
            `;
        }

        function populateMilestoneTimeline() {
            const container = document.getElementById('timeline-container');
            if (!container) return;

            console.log('ðŸ—ï¸ POPULATING MILESTONE TIMELINE');
            console.log('ðŸ“Š Current data length:', currentData.length);
            console.log('ðŸ“‹ Data sample:', currentData[0]);
            console.log('ðŸ” Unique states in data:', [...new Set(currentData.map(row => row.state))]);

            // Get completion data for each trade - using ALL data (not filtered like dashboard)
            const tradeCompletion = {};
            const allTrades = [...new Set(currentData.map(row => row.trade))];
            console.log('ðŸ”§ All trades before ordering:', allTrades);
            console.log('ðŸ” Using currentData length:', currentData.length, '(not filteredData)');
            
            allTrades.forEach(trade => {
                const tradeData = currentData.filter(row => row.trade === trade);
                
                // Get all unique location-trade combinations for this trade
                const allTaskKeys = new Set(tradeData.map(row => `${row.location}_${row.trade}`));
                
                // For each unique task, determine its final state by looking at the most recent VALID record
                // Filter 'no data' entries upfront like dashboard does
                const taskStates = {};
                tradeData.filter(row => row.state !== 'no data').forEach(row => {
                    const taskKey = `${row.location}_${row.trade}`;
                    const captureDate = row.capture_date;
                    
                    if (!taskStates[taskKey] || captureDate > taskStates[taskKey].date) {
                        taskStates[taskKey] = {
                            state: row.state,
                            date: captureDate,
                            location: row.location
                        };
                    }
                });
                
                // Count completed tasks based on final state
                const allTaskKeysFromStates = Object.keys(taskStates);
                const completedTaskKeys = allTaskKeysFromStates.filter(taskKey => 
                    taskStates[taskKey].state === 'complete'
                );
                
                const totalTasks = allTaskKeysFromStates.length;  // Use final states count, not raw data count
                const completedTasks = completedTaskKeys.length;
                
                const completion = totalTasks > 0 ? 
                    Math.round((completedTasks / totalTasks) * 100) : 0;
                
                console.log(`ðŸ” ${trade}: ${completedTasks}/${totalTasks} = ${completion}%`);
                if (trade === 'Structural Piles') {
                    console.log('ðŸ“Š Structural Piles detailed analysis:');
                    console.log('   All raw records:', tradeData.length);
                    console.log('   Records after excluding no data:', tradeData.filter(row => row.state !== 'no data').length);
                    console.log('   Task states:', taskStates);
                    console.log('   Completed keys:', completedTaskKeys);
                    console.log('   Should be 100% (3/3) if all locations are complete');
                }
                
                tradeCompletion[trade] = {
                    percentage: completion,
                    completed: completedTasks,
                    total: totalTasks
                };
            });

            // Use ordered trades
            const orderedTrades = getOrderedTrades(allTrades);
            console.log('âœ… ORDERED TRADES FOR TIMELINE:', orderedTrades);
            console.log('ðŸ”¢ Total trades to display:', orderedTrades.length);
            console.log('ðŸ“ˆ Trade completion data:', Object.entries(tradeCompletion).map(([trade, data]) => 
                `${trade}: ${data.percentage}%`
            ));
            
            // Debug: Check if Structural Piles is in the ordered trades
            console.log('ðŸ” Structural Piles in ordered trades?', orderedTrades.includes('Structural Piles'));
            console.log('ðŸ” Structural Piles completion data:', tradeCompletion['Structural Piles']);
            
            let timelineHTML = '';
            orderedTrades.forEach((trade, index) => {
                const completion = tradeCompletion[trade];
                const percentage = completion ? completion.percentage : 0;
                const isCompleted = percentage >= 100;
                const isInProgress = percentage > 0 && percentage < 100;
                
                const statusColor = isCompleted ? 'blue' : isInProgress ? 'yellow' : 'gray';
                const bgColor = isCompleted ? 'bg-blue-600' : isInProgress ? 'bg-yellow-500' : 'bg-gray-300';
                
                timelineHTML += `
                    <div class="relative flex items-start mb-6">
                        <div class="flex-shrink-0 w-12 h-12 ${bgColor} rounded-full flex items-center justify-center z-10">
                            <span class="text-white font-bold text-sm">${index + 1}</span>
                        </div>
                        <div class="ml-4 min-w-0 flex-1">
                            <div class="text-sm font-medium text-gray-900">${trade}</div>
                            <div class="text-sm text-gray-500">
                                ${percentage}% complete 
                                ${completion ? `(${completion.completed}/${completion.total} tasks)` : ''}
                            </div>
                            <div class="mt-1 w-full bg-gray-200 rounded-full h-2">
                                <div class="bg-blue-600 h-2 rounded-full" style="width: ${percentage}%"></div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = timelineHTML;
            console.log('ðŸ“ Timeline HTML generated, length:', timelineHTML.length);
            console.log('ðŸŽ¯ Timeline container height:', container.scrollHeight, 'px');
            console.log('ðŸ” Timeline items generated:', orderedTrades.length);
        }



        function generateInitialInsights(data) {
            // Populate the executive dashboard first
            populateExecutiveDashboard(data);
            
            // Generate executive summary for the last week
            const executiveSummary = generateWeeklyExecutiveSummary(data);
            addChatMessage("assistant", executiveSummary);
            
            // Add velocity comparison insight block
            const totalStarts = data.velocityComparison.starts.reduce((sum, val) => sum + val, 0);
            const totalCompletions = data.velocityComparison.completions.reduce((sum, val) => sum + val, 0);
            const velocityInsight = {
                id: 'velocity-comparison',
                type: 'velocity-analysis',
                title: 'ðŸ“Š Work Velocity Analysis',
                description: `Comparing ${totalStarts} tasks started vs ${totalCompletions} completed this period. ${totalStarts > totalCompletions ? 'You\'re starting more than finishing - potential bottleneck building.' : 'Healthy completion rate maintaining good flow.'}`,
                severity: 'info',
                data: data.velocityComparison,
                chartType: 'velocity-comparison'
            };
            addClickableTile("assistant", velocityInsight);
            
            // Add anomaly insight blocks
            addAnomalyInsightBlocks(data);
        }

        function generateWeeklyExecutiveSummary(data) {
            // Get last week's data for analysis
            const lastWeekData = getLastWeekData();
            const completedLastWeek = lastWeekData.filter(row => row.state === 'complete').length;
            const startedLastWeek = lastWeekData.filter(row => isInProgress(row.state)).length;
            
            // Identify most active trades and zones
            const tradeActivity = {};
            const zoneActivity = {};
            
            lastWeekData.forEach(row => {
                tradeActivity[row.trade] = (tradeActivity[row.trade] || 0) + 1;
                const zone = row.section || 'Unknown Zone';
                zoneActivity[zone] = (zoneActivity[zone] || 0) + 1;
            });
            
            const topTrade = Object.entries(tradeActivity).sort((a, b) => b[1] - a[1])[0];
            const topZone = Object.entries(zoneActivity).sort((a, b) => b[1] - a[1])[0];
            
            // Detect any significant changes or issues
            const stalledCount = data.anomalies.stalledTrades.length;
            const stackedCount = data.anomalies.stackedTrades.length;
            
            let summary = `ðŸ“‹ **Weekly Executive Summary**: Over the past week, your project maintained ${data.overview.overallCompletion}% completion with ${completedLastWeek} tasks completed and ${startedLastWeek} new tasks initiated. `;
            
            if (topTrade) {
                summary += `${topTrade[0]} showed the highest activity with ${topTrade[1]} task updates. `;
            }
            
            if (topZone) {
                summary += `${topZone[0]} was the most active zone with ${topZone[1]} total updates. `;
            }
            
            if (stalledCount > 0) {
                summary += `âš ï¸ Notable concern: ${stalledCount} trades showing stalled progress requiring attention. `;
            }
            
            if (stackedCount > 0) {
                summary += `ðŸš§ ${stackedCount} locations have multiple competing trades that may benefit from coordination. `;
            }
            
            if (stalledCount === 0 && stackedCount === 0) {
                summary += `âœ… No major bottlenecks detected - project flow appears healthy.`;
            }
            
            return summary;
        }

        function getLastWeekData() {
            const oneWeekAgo = new Date();
            oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
            
            return currentData.filter(row => {
                const captureDate = new Date(row.capture_date);
                return captureDate >= oneWeekAgo;
            });
        }

        function addAnomalyInsightBlocks(data) {
            // Stalled Trades
            if (data.anomalies.stalledTrades.length > 0) {
                const stalledInsight = {
                    id: 'stalled-trades',
                    type: 'anomaly-stalled',
                    title: `ðŸš¨ Stalled Trades (${data.anomalies.stalledTrades.length})`,
                    description: `${data.anomalies.stalledTrades.length} trades have been stuck in progress for extended periods. This represents potential workflow bottlenecks that need immediate attention to maintain project momentum.`,
                    severity: 'critical',
                    data: data.anomalies.stalledTrades,
                    chartType: 'stalled-trades'
                };
                addClickableTile("assistant", stalledInsight);
            }
            
            // Stacked Trades
            if (data.anomalies.stackedTrades.length > 0) {
                const stackedInsight = {
                    id: 'stacked-trades',
                    type: 'anomaly-stacked',
                    title: `âš¡ Stacked Trades (${data.anomalies.stackedTrades.length})`,
                    description: `${data.anomalies.stackedTrades.length} locations have multiple trades competing for the same space simultaneously. Better coordination could improve efficiency and reduce conflicts.`,
                severity: 'warning',
                    data: data.anomalies.stackedTrades,
                    chartType: 'stacked-trades'
                };
                addClickableTile("assistant", stackedInsight);
            }
            
            // Burst Start Analysis
            if (data.anomalies.burstStart.length > 0) {
                const burstInsight = {
                    id: 'burst-start',
                    type: 'anomaly-burst',
                    title: `ðŸš€ Burst Start Activity (${data.anomalies.burstStart.length})`,
                    description: `${data.anomalies.burstStart.length} periods of unusually high task initiation detected. These bursts may indicate resource allocation spikes or catch-up efforts after delays.`,
                    severity: 'info',
                    data: data.anomalies.burstStart,
                    chartType: 'burst-start'
                };
                addClickableTile("assistant", burstInsight);
            }
            
            // Swiss Cheese Flow
            if (data.anomalies.swissCheese.length > 0) {
                const swissInsight = {
                    id: 'swiss-cheese',
                    type: 'anomaly-swiss',
                    title: `ðŸ§€ Swiss Cheese Flow (${data.anomalies.swissCheese.length})`,
                    description: `${data.anomalies.swissCheese.length} locations show incomplete work patterns with gaps. This scattered completion pattern may indicate coordination issues or resource constraints.`,
                    severity: 'warning',
                    data: data.anomalies.swissCheese,
                    chartType: 'swiss-cheese'
                };
                addClickableTile("assistant", swissInsight);
            }
            
            // Trade Blockage
            const blockedSections = Object.keys(data.anomalies.tradeBlockage).length;
            if (blockedSections > 0) {
                const blockageInsight = {
                    id: 'trade-blockage',
                    type: 'anomaly-blockage',
                    title: `ðŸš§ Trade Blockage (${blockedSections} sections)`,
                    description: `${blockedSections} sections show signs of blocked trades with extended in-progress periods. These blockages may require intervention to restore normal workflow patterns.`,
                    severity: 'warning',
                    data: data.anomalies.tradeBlockage,
                    chartType: 'trade-blockage'
                };
                addClickableTile("assistant", blockageInsight);
            }
        }

        function addChatMessage(sender, message) {
            chatHistory.push({ 
                sender, 
                message, 
                timestamp: new Date(),
                type: 'message'
            });
            renderChatHistory();
        }

        function addUserMessage(message) {
            chatHistory.push({ 
                sender: 'user', 
                message, 
                timestamp: new Date(),
                type: 'message'
            });
            renderChatHistory();
        }

        function addClickableTile(sender, tileData) {
            chatHistory.push({ 
                sender, 
                type: 'tile',
                tileData,
                timestamp: new Date()
            });
            renderChatHistory();
        }

        // Handle keyboard input
        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        // Send user message and generate AI response
        function sendMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Add user message
            addUserMessage(message);
            
            // Clear input
            input.value = '';
            
            // Disable input while processing
            input.disabled = true;
            document.getElementById('send-button').disabled = true;
            
            // Generate response immediately
            generateAIResponse(message);
            
            // Re-enable input
            input.disabled = false;
            document.getElementById('send-button').disabled = false;
            input.focus();
        }

        // Generate intelligent response using rule-based logic
        function generateAIResponse(userMessage) {
            const lowerMessage = userMessage.toLowerCase();
            
            // Enhanced intent recognition with multiple patterns and context
            const intents = analyzeUserIntent(lowerMessage, userMessage);
            
            // Execute the most confident intent or combination of intents
            if (intents.completion.confidence > 0.7) {
                handleCompletionQuery(userMessage, intents);
            } else if (intents.trade.confidence > 0.7) {
                handleTradeQuery(userMessage, intents);
            } else if (intents.location.confidence > 0.7) {
                handleLocationQuery(userMessage, intents);
            } else if (intents.timeline.confidence > 0.7) {
                handleTimelineQuery(userMessage, intents);
            } else if (intents.comparison.confidence > 0.7) {
                handleComparisonQuery(userMessage, intents);
            } else if (intents.prediction.confidence > 0.7) {
                handlePredictionQuery(userMessage, intents);
            } else if (intents.problem.confidence > 0.7) {
                handleProblemQuery(userMessage, intents);
            } else if (intents.recommendation.confidence > 0.7) {
                handleRecommendationQuery(userMessage, intents);
            } else if (intents.summary.confidence > 0.7) {
                handleSummaryQuery(userMessage, intents);
            } else if (intents.help.confidence > 0.7) {
                handleHelpQuery(userMessage, intents);
            } else {
                // Handle complex queries or multiple intents
                handleComplexQuery(userMessage, intents);
            }
        }

        function analyzeUserIntent(lowerMessage, originalMessage) {
            const intents = {
                completion: { confidence: 0, keywords: [], entities: [] },
                trade: { confidence: 0, keywords: [], entities: [] },
                location: { confidence: 0, keywords: [], entities: [] },
                timeline: { confidence: 0, keywords: [], entities: [] },
                comparison: { confidence: 0, keywords: [], entities: [] },
                prediction: { confidence: 0, keywords: [], entities: [] },
                problem: { confidence: 0, keywords: [], entities: [] },
                recommendation: { confidence: 0, keywords: [], entities: [] },
                summary: { confidence: 0, keywords: [], entities: [] },
                help: { confidence: 0, keywords: [], entities: [] }
            };

            // Completion intent patterns
            const completionPatterns = [
                /(?:how much|what.*percent|completion rate|progress|status|done|finished|complete)/,
                /(?:overall|total|project).*(?:progress|completion|done)/,
                /(?:where.*stand|current.*status|how.*doing)/
            ];
            intents.completion.confidence = calculatePatternConfidence(lowerMessage, completionPatterns);
            intents.completion.keywords = extractKeywords(lowerMessage, ['completion', 'progress', 'status', 'done', 'finished', 'complete', 'percent']);

            // Trade-specific intent patterns
            const tradePatterns = [
                /(?:trade|crew|worker|team|contractor).*(?:performance|doing|progress|status)/,
                /(?:which|what).*trade.*(?:best|worst|struggling|behind|ahead)/,
                /(?:wall|overhead|insulation|drywall|plumbing|duct|paint).*(?:progress|status|completion)/
            ];
            intents.trade.confidence = calculatePatternConfidence(lowerMessage, tradePatterns);
            intents.trade.keywords = extractKeywords(lowerMessage, ['trade', 'crew', 'worker', 'team', 'contractor', 'wall', 'overhead', 'insulation', 'drywall', 'plumbing', 'duct', 'paint']);
            intents.trade.entities = extractTradeEntities(originalMessage);

            // Location/level intent patterns
            const locationPatterns = [
                /(?:level|floor|location|room|area|zone).*(?:progress|completion|status|doing)/,
                /(?:which|what).*(?:level|floor|location).*(?:best|worst|behind|ahead)/,
                /(?:compare|comparison).*(?:level|floor|location)/
            ];
            intents.location.confidence = calculatePatternConfidence(lowerMessage, locationPatterns);
            intents.location.keywords = extractKeywords(lowerMessage, ['level', 'floor', 'location', 'room', 'area', 'zone']);
            intents.location.entities = extractLocationEntities(originalMessage);

            // Timeline intent patterns
            const timelinePatterns = [
                /(?:when|timeline|schedule|date|time).*(?:complete|finish|done)/,
                /(?:how long|duration|timeframe|estimate)/,
                /(?:velocity|speed|rate|pace|daily|weekly|trend)/
            ];
            intents.timeline.confidence = calculatePatternConfidence(lowerMessage, timelinePatterns);
            intents.timeline.keywords = extractKeywords(lowerMessage, ['when', 'timeline', 'schedule', 'date', 'time', 'velocity', 'speed', 'rate', 'pace', 'daily', 'weekly']);

            // Comparison intent patterns
            const comparisonPatterns = [
                /(?:compare|comparison|versus|vs|difference|better|worse)/,
                /(?:which.*(?:better|worse|faster|slower|ahead|behind))/,
                /(?:best|worst|top|bottom|highest|lowest).*(?:performing|completion)/
            ];
            intents.comparison.confidence = calculatePatternConfidence(lowerMessage, comparisonPatterns);
            intents.comparison.keywords = extractKeywords(lowerMessage, ['compare', 'comparison', 'versus', 'vs', 'difference', 'better', 'worse', 'best', 'worst']);

            // Prediction intent patterns
            const predictionPatterns = [
                /(?:predict|forecast|estimate|projection|expect|will|future)/,
                /(?:when.*(?:complete|finish|done)|completion.*date)/,
                /(?:trend|trajectory|direction|outlook)/
            ];
            intents.prediction.confidence = calculatePatternConfidence(lowerMessage, predictionPatterns);
            intents.prediction.keywords = extractKeywords(lowerMessage, ['predict', 'forecast', 'estimate', 'projection', 'expect', 'will', 'future', 'trend']);

            // Problem intent patterns
            const problemPatterns = [
                /(?:problem|issue|delay|bottleneck|stuck|stalled|blocked|concern)/,
                /(?:what.*wrong|why.*slow|trouble|difficulty|challenge)/,
                /(?:behind|lagging|struggling|failing)/
            ];
            intents.problem.confidence = calculatePatternConfidence(lowerMessage, problemPatterns);
            intents.problem.keywords = extractKeywords(lowerMessage, ['problem', 'issue', 'delay', 'bottleneck', 'stuck', 'stalled', 'blocked', 'concern']);

            // Recommendation intent patterns
            const recommendationPatterns = [
                /(?:recommend|suggest|advice|should|need.*do|what.*next|action)/,
                /(?:improve|optimize|fix|solve|address)/,
                /(?:priority|focus|urgent|important)/
            ];
            intents.recommendation.confidence = calculatePatternConfidence(lowerMessage, recommendationPatterns);
            intents.recommendation.keywords = extractKeywords(lowerMessage, ['recommend', 'suggest', 'advice', 'should', 'improve', 'optimize', 'fix', 'solve']);

            // Summary intent patterns
            const summaryPatterns = [
                /(?:summary|report|overview|dashboard|executive|brief)/,
                /(?:overall|general|high.*level|big.*picture)/,
                /(?:key.*(?:metrics|insights|findings|points))/
            ];
            intents.summary.confidence = calculatePatternConfidence(lowerMessage, summaryPatterns);
            intents.summary.keywords = extractKeywords(lowerMessage, ['summary', 'report', 'overview', 'dashboard', 'executive', 'brief']);

            // Help intent patterns
            const helpPatterns = [
                /(?:help|what.*can|how.*do|what.*possible|capabilities)/,
                /(?:guide|tutorial|explain|show.*me)/,
                /(?:commands|options|features)/
            ];
            intents.help.confidence = calculatePatternConfidence(lowerMessage, helpPatterns);
            intents.help.keywords = extractKeywords(lowerMessage, ['help', 'guide', 'tutorial', 'explain', 'show', 'commands', 'options']);

            return intents;
        }

        function calculatePatternConfidence(message, patterns) {
            let maxConfidence = 0;
            patterns.forEach(pattern => {
                const matches = message.match(pattern);
                if (matches) {
                    // Base confidence from pattern match
                    let confidence = 0.6;
                    
                    // Boost confidence based on match quality
                    const matchLength = matches[0].length;
                    const messageLength = message.length;
                    confidence += (matchLength / messageLength) * 0.3;
                    
                    // Boost for question words
                    if (/(?:what|how|when|where|why|which|who)/.test(message)) {
                        confidence += 0.1;
                    }
                    
                    maxConfidence = Math.max(maxConfidence, Math.min(confidence, 1.0));
                }
            });
            
            return maxConfidence;
        }

        function extractKeywords(message, keywordList) {
            return keywordList.filter(keyword => message.includes(keyword));
        }

        function extractTradeEntities(message) {
            const trades = [];
            if (dashboardData && dashboardData.tradeAnalysis) {
                dashboardData.tradeAnalysis.forEach(trade => {
                    if (message.toLowerCase().includes(trade.trade.toLowerCase())) {
                        trades.push(trade.trade);
                    }
                });
            }
            return trades;
        }

        function extractLocationEntities(message) {
            const locations = [];
            if (dashboardData && dashboardData.levelAnalysis) {
                Object.keys(dashboardData.levelAnalysis).forEach(level => {
                    if (message.toLowerCase().includes(level.toLowerCase())) {
                        locations.push(level);
                    }
                });
            }
            return locations;
        }

        function handleCompletionQuery(userMessage, intents = {}) {
            if (!dashboardData) {
                addChatMessage("assistant", "Please upload your construction data first to analyze completion rates.");
                return;
            }

            const completion = dashboardData.overview.overallCompletion;
            const completed = dashboardData.overview.completedTasks;
            const total = dashboardData.overview.totalTasks;
            
            addChatMessage("assistant", `Your project is currently ${completion}% complete. You've finished ${completed} out of ${total} total tasks.`);
            
            // Add completion tile
            const completionTile = {
                id: 'completion-breakdown',
                type: 'completion',
                title: `Project Completion: ${completion}%`,
                description: `${completed}/${total} tasks complete`,
                severity: parseFloat(completion) > 70 ? 'good' : parseFloat(completion) > 40 ? 'warning' : 'critical',
                data: dashboardData.overview,
                chartType: 'completion-chart'
            };
            addClickableTile("assistant", completionTile);
        }

        function handleTradeQuery(userMessage, intents = {}) {
            if (!dashboardData) {
                addChatMessage("assistant", "Please upload your construction data first to analyze trade performance.");
                return;
            }

            const worstTrade = dashboardData.tradeAnalysis[0];
            const bestTrade = dashboardData.tradeAnalysis[dashboardData.tradeAnalysis.length - 1];
            
            addChatMessage("assistant", `Here's your trade performance summary:`);
            addChatMessage("assistant", `ðŸš¨ Lowest performing: ${worstTrade.trade} at ${worstTrade.completionRate}% completion`);
            addChatMessage("assistant", `âœ… Best performing: ${bestTrade.trade} at ${bestTrade.completionRate}% completion`);
            
            // Add worst trade tile
            const tradeTile = {
                id: 'worst-trade-analysis',
                type: 'trade-performance',
                title: `${worstTrade.trade}: ${worstTrade.completionRate}%`,
                description: `Needs immediate attention - ${worstTrade.completed}/${worstTrade.total} tasks done`,
                severity: 'critical',
                data: worstTrade,
                chartType: 'trade-progress'
            };
            addClickableTile("assistant", tradeTile);
        }

        function handleLocationQuery(userMessage, intents = {}) {
            if (!dashboardData || !dashboardData.levelAnalysis) {
                addChatMessage("assistant", "Level analysis requires floor/level data in your CSV. Please check your data includes level information.");
                return;
            }

            const levels = Object.keys(dashboardData.levelAnalysis);
            if (levels.length < 2) {
                addChatMessage("assistant", "I need data from multiple levels/floors to provide level analysis.");
                return;
            }

            const levelRates = levels.map(level => {
                const data = dashboardData.levelAnalysis[level];
                return {
                    level,
                    rate: (data.completed / data.total * 100).toFixed(1)
                };
            }).sort((a, b) => parseFloat(a.rate) - parseFloat(b.rate));

            addChatMessage("assistant", `Level completion analysis:`);
            levelRates.forEach(level => {
                addChatMessage("assistant", `ðŸ“Š Level ${level.level}: ${level.rate}% complete`);
            });

            const gap = Math.abs(parseFloat(levelRates[0].rate) - parseFloat(levelRates[levelRates.length - 1].rate));
            if (gap > 20) {
                addChatMessage("assistant", `âš ï¸ Significant ${gap.toFixed(1)}% completion gap detected between levels. Consider focusing resources to balance progress.`);
            }
        }

        function handleTimelineQuery(userMessage, intents = {}) {
            if (!dashboardData) {
                addChatMessage("assistant", "Please upload your construction data first to analyze velocity.");
                return;
            }

            if (!dashboardData.velocityData || dashboardData.velocityData.length === 0) {
                addChatMessage("assistant", "Velocity analysis requires completion dates in your data. Please ensure your CSV includes complete_date information.");
                return;
            }

            const avgDaily = (dashboardData.overview.completedTasks / dashboardData.velocityData.length).toFixed(1);
            const peakDay = Math.max(...dashboardData.velocityData.map(d => 
                dashboardData.allTrades.reduce((sum, trade) => sum + (d[trade] || 0), 0)
            ));

            addChatMessage("assistant", `ðŸ“ˆ Your project velocity metrics:`);
            addChatMessage("assistant", `â€¢ Average daily completion: ${avgDaily} tasks/day`);
            addChatMessage("assistant", `â€¢ Peak performance day: ${peakDay} tasks completed`);
            addChatMessage("assistant", `â€¢ Active working days: ${dashboardData.velocityData.length}`);

            // Add velocity tile
            const velocityTile = {
                id: 'velocity-analysis',
                type: 'velocity',
                title: `Daily Rate: ${avgDaily} tasks/day`,
                description: `Peak day: ${peakDay} tasks completed`,
                severity: parseFloat(avgDaily) > 50 ? 'good' : 'warning',
                data: { 
                    velocityData: dashboardData.velocityData, 
                    allTrades: dashboardData.allTrades,
                    totalCompleted: dashboardData.overview.completedTasks 
                },
                chartType: 'velocity-trend'
            };
            addClickableTile("assistant", velocityTile);
        }

        function handleProblemQuery(userMessage, intents = {}) {
            if (!dashboardData) {
                addChatMessage("assistant", "Please upload your construction data first to identify problems.");
                return;
            }

            const criticalTrades = dashboardData.tradeAnalysis.filter(t => parseFloat(t.completionRate) < 20);
            const stalledTrades = dashboardData.tradeAnalysis.filter(t => t.inProgress > t.completed && parseFloat(t.completionRate) < 30);

            addChatMessage("assistant", `ðŸ” Problem analysis results:`);

            if (criticalTrades.length > 0) {
                addChatMessage("assistant", `ðŸš¨ ${criticalTrades.length} critical bottlenecks found:`);
                criticalTrades.forEach(trade => {
                    addChatMessage("assistant", `â€¢ ${trade.trade}: Only ${trade.completionRate}% complete`);
                });
            }

            if (stalledTrades.length > 0) {
                addChatMessage("assistant", `âš ï¸ ${stalledTrades.length} trades appear stalled with more in-progress than completed work.`);
            }

            if (criticalTrades.length === 0 && stalledTrades.length === 0) {
                addChatMessage("assistant", `âœ… No major problems detected! All trades are progressing within acceptable ranges.`);
            }
        }

        function handleRecommendationQuery(userMessage, intents = {}) {
            if (!dashboardData) {
                addChatMessage("assistant", "Please upload your construction data first to provide recommendations.");
                return;
            }

            addChatMessage("assistant", `ðŸ’¡ Based on your data analysis, here are my recommendations:`);

            const criticalTrades = dashboardData.tradeAnalysis.filter(t => parseFloat(t.completionRate) < 15);
            const goodTrades = dashboardData.tradeAnalysis.filter(t => parseFloat(t.completionRate) > 60);

            if (criticalTrades.length > 0) {
                addChatMessage("assistant", `ðŸŽ¯ **Immediate Actions:**`);
                addChatMessage("assistant", `â€¢ Focus resources on ${criticalTrades[0].trade} (${criticalTrades[0].completionRate}% complete)`);
                addChatMessage("assistant", `â€¢ Consider adding crews or reviewing material availability`);
                addChatMessage("assistant", `â€¢ Increase focus and monitoring for critical trades`);
            }

            if (goodTrades.length > 0) {
                addChatMessage("assistant", `ðŸ“ˆ **Resource Optimization:**`);
                addChatMessage("assistant", `â€¢ ${goodTrades[goodTrades.length - 1].trade} is performing well (${goodTrades[goodTrades.length - 1].completionRate}% complete)`);
                addChatMessage("assistant", `â€¢ Consider reallocating some crews from high-performing to struggling trades`);
            }

            addChatMessage("assistant", `ðŸ”„ **Next Steps:** Click the tiles above for detailed analysis and specific action plans.`);
        }

        function handleSummaryQuery(userMessage, intents = {}) {
            if (!dashboardData) {
                addChatMessage("assistant", "Please upload your construction data first to generate a project summary.");
                return;
            }

            addChatMessage("assistant", `ðŸ“‹ **Executive Project Summary**`);
            addChatMessage("assistant", `Your project is ${dashboardData.overview.overallCompletion}% complete with ${dashboardData.overview.completedTasks} of ${dashboardData.overview.totalTasks} tasks finished. Currently ${dashboardData.overview.inProgressTasks} tasks are in progress across ${dashboardData.tradeAnalysis.length} different trades.`);
            
            const criticalTrades = dashboardData.tradeAnalysis.filter(t => parseFloat(t.completionRate) < 20);
            const performingTrades = dashboardData.tradeAnalysis.filter(t => parseFloat(t.completionRate) > 60);
            
            if (criticalTrades.length > 0) {
                addChatMessage("assistant", `ðŸš¨ **Critical Issues:** ${criticalTrades.length} trades require immediate attention: ${criticalTrades.map(t => t.trade).join(', ')}`);
            }
            
            if (performingTrades.length > 0) {
                addChatMessage("assistant", `âœ… **Performing Well:** ${performingTrades.length} trades with good completion rates: ${performingTrades.slice(0, 3).map(t => t.trade).join(', ')}${performingTrades.length > 3 ? ' and others' : ''}`);
            }
            
            // Add summary tile
            const summaryTile = {
                id: 'executive-summary',
                type: 'summary',
                title: `Executive Summary: ${dashboardData.overview.overallCompletion}% Complete`,
                description: `${criticalTrades.length} critical issues, ${performingTrades.length} trades performing well`,
                severity: criticalTrades.length > 2 ? 'critical' : criticalTrades.length > 0 ? 'warning' : 'good',
                data: dashboardData.overview,
                chartType: 'completion-chart'
            };
            addClickableTile("assistant", summaryTile);
        }

        function handleHelpQuery(userMessage, intents = {}) {
            addChatMessage("assistant", `ðŸ¤– **UNO Construction Intelligence Assistant**`);
            addChatMessage("assistant", `I'm now much more robust and can understand complex questions! Here's what I can help with:`);
            
            addChatMessage("assistant", `ðŸ“Š **Project Status & Progress:**`);
            addChatMessage("assistant", `â€¢ "What's our completion rate?" "How much progress have we made?" "Where do we stand?"`);
            
            addChatMessage("assistant", `ðŸ”§ **Trade Performance Analysis:**`);
            addChatMessage("assistant", `â€¢ "Which trades are struggling?" "How is wall drywall performing?" "Trade status overview"`);
            
            addChatMessage("assistant", `ðŸ“ˆ **Comparisons & Rankings:**`);
            addChatMessage("assistant", `â€¢ "Compare all trades" "Which level is best?" "Rank trade performance" "Wall vs overhead trades"`);
            
            addChatMessage("assistant", `ðŸ”® **Predictions & Forecasting:**`);
            addChatMessage("assistant", `â€¢ "When will we finish?" "Estimate completion time" "Project forecast" "Velocity trends"`);
            
            addChatMessage("assistant", `ðŸ¢ **Location & Level Analysis:**`);
            addChatMessage("assistant", `â€¢ "How do the floors compare?" "Which level needs attention?" "Location progress"`);
            
            addChatMessage("assistant", `ðŸš¨ **Problem Detection:**`);
            addChatMessage("assistant", `â€¢ "What problems do we have?" "Any bottlenecks?" "Issues and delays" "Risk factors"`);
            
            addChatMessage("assistant", `ðŸ’¡ **Smart Recommendations:**`);
            addChatMessage("assistant", `â€¢ "What should we do next?" "Improve project speed" "Priority actions" "Focus areas"`);
            
            addChatMessage("assistant", `ðŸ“‹ **Executive Summaries:**`);
            addChatMessage("assistant", `â€¢ "Executive summary" "Project overview" "Key insights" "Dashboard report"`);
            
            if (dashboardData) {
                addChatMessage("assistant", `ðŸ“Š **Currently analyzing:** ${dashboardData.overview.totalTasks} tasks across ${dashboardData.tradeAnalysis.length} trades`);
                addChatMessage("assistant", `ðŸŽ¯ **Try complex questions like:** "Why is wall drywall behind and when will it catch up?" or "Compare level 2 vs level 3 and recommend actions"`);
            } else {
                addChatMessage("assistant", `ðŸ“ **Note:** Auto-loading your UNO data for immediate analysis...`);
            }
        }

        function handleComparisonQuery(userMessage, intents = {}) {
            if (!dashboardData) {
                addChatMessage("assistant", "Please upload your construction data first to perform comparisons.");
                return;
            }

            // Determine what to compare based on entities and keywords
            if (intents.trade && intents.trade.entities.length > 1) {
                // Compare specific trades
                const trades = intents.trade.entities;
                const tradeData = trades.map(tradeName => 
                    dashboardData.tradeAnalysis.find(t => t.trade === tradeName)
                ).filter(Boolean);

                if (tradeData.length >= 2) {
                    addChatMessage("assistant", `ðŸ“Š **Trade Comparison:**`);
                    tradeData.forEach(trade => {
                        addChatMessage("assistant", `â€¢ ${trade.trade}: ${trade.completionRate}% complete (${trade.completed}/${trade.total} tasks)`);
                    });

                    const bestTrade = tradeData.reduce((a, b) => parseFloat(a.completionRate) > parseFloat(b.completionRate) ? a : b);
                    const worstTrade = tradeData.reduce((a, b) => parseFloat(a.completionRate) < parseFloat(b.completionRate) ? a : b);
                    
                    addChatMessage("assistant", `ðŸ† Best performing: ${bestTrade.trade} at ${bestTrade.completionRate}%`);
                    addChatMessage("assistant", `âš ï¸ Needs attention: ${worstTrade.trade} at ${worstTrade.completionRate}%`);
                }
            } else if (intents.location && intents.location.entities.length > 0) {
                // Compare levels/locations
                const levelData = Object.entries(dashboardData.levelAnalysis).map(([level, data]) => ({
                    level,
                    completionRate: ((data.completed / data.total) * 100).toFixed(1),
                    completed: data.completed,
                    total: data.total
                })).sort((a, b) => parseFloat(b.completionRate) - parseFloat(a.completionRate));

                addChatMessage("assistant", `ðŸ¢ **Level Performance Comparison:**`);
                levelData.forEach((level, index) => {
                    const emoji = index === 0 ? 'ðŸ¥‡' : index === levelData.length - 1 ? 'ðŸ”´' : 'ðŸ“Š';
                    addChatMessage("assistant", `${emoji} Level ${level.level}: ${level.completionRate}% complete (${level.completed}/${level.total} tasks)`);
                });
            } else {
                // General comparison of all trades
                const sortedTrades = [...dashboardData.tradeAnalysis].sort((a, b) => parseFloat(b.completionRate) - parseFloat(a.completionRate));
                
                addChatMessage("assistant", `ðŸ“Š **Overall Trade Performance Ranking:**`);
                sortedTrades.slice(0, 5).forEach((trade, index) => {
                    const emoji = index === 0 ? 'ðŸ¥‡' : index === 1 ? 'ðŸ¥ˆ' : index === 2 ? 'ðŸ¥‰' : 'ðŸ“ˆ';
                    addChatMessage("assistant", `${emoji} ${trade.trade}: ${trade.completionRate}% complete`);
                });

                if (sortedTrades.length > 5) {
                    addChatMessage("assistant", `... and ${sortedTrades.length - 5} more trades`);
                }
            }
        }

        function handlePredictionQuery(userMessage, intents = {}) {
            if (!dashboardData) {
                addChatMessage("assistant", "Please upload your construction data first to make predictions.");
                return;
            }

            if (!dashboardData.velocityData || dashboardData.velocityData.length === 0) {
                addChatMessage("assistant", "Prediction analysis requires completion dates in your data. Please ensure your CSV includes complete_date information.");
                return;
            }

            // Calculate current velocity
            const recentData = dashboardData.velocityData.slice(-7); // Last 7 days
            const avgDailyCompletion = recentData.reduce((sum, day) => {
                return sum + dashboardData.allTrades.reduce((daySum, trade) => daySum + (day[trade] || 0), 0);
            }, 0) / recentData.length;

            const remainingTasks = dashboardData.overview.totalTasks - dashboardData.overview.completedTasks;
            const estimatedDaysToComplete = Math.ceil(remainingTasks / avgDailyCompletion);

            addChatMessage("assistant", `ðŸ”® **Project Completion Prediction:**`);
            addChatMessage("assistant", `ðŸ“ˆ Current velocity: ${avgDailyCompletion.toFixed(1)} tasks completed per day (7-day average)`);
            addChatMessage("assistant", `ðŸ“‹ Remaining tasks: ${remainingTasks}`);
            addChatMessage("assistant", `â° Estimated completion: ${estimatedDaysToComplete} days`);

            // Add prediction tile
            const predictionTile = {
                id: 'completion-prediction',
                type: 'prediction',
                title: `Completion Forecast: ${estimatedDaysToComplete} days`,
                description: `Based on current velocity of ${avgDailyCompletion.toFixed(1)} tasks/day`,
                severity: estimatedDaysToComplete > 30 ? 'warning' : 'good',
                data: {
                    avgDailyCompletion,
                    remainingTasks,
                    estimatedDays: estimatedDaysToComplete,
                    velocityData: dashboardData.velocityData
                },
                chartType: 'velocity-trend'
            };
            addClickableTile("assistant", predictionTile);

            // Provide trade-specific predictions
            const criticalTrades = dashboardData.tradeAnalysis.filter(trade => parseFloat(trade.completionRate) < 30);
            if (criticalTrades.length > 0) {
                addChatMessage("assistant", `âš ï¸ **Risk Factors:** ${criticalTrades.length} trades below 30% completion may impact timeline:`);
                criticalTrades.forEach(trade => {
                    addChatMessage("assistant", `â€¢ ${trade.trade}: ${trade.completionRate}% complete`);
                });
            }
        }

        function handleComplexQuery(userMessage, intents) {
            // Handle queries that don't clearly fit one category or combine multiple intents
            const sortedIntents = Object.entries(intents)
                .map(([type, data]) => ({ type, ...data }))
                .sort((a, b) => b.confidence - a.confidence)
                .filter(intent => intent.confidence > 0.3);

            if (sortedIntents.length === 0) {
                // No clear intent detected
                addChatMessage("assistant", "I'm not sure exactly what you're looking for. Here are some things I can help with:");
                addChatMessage("assistant", "ðŸ“Š Project completion status and progress");
                addChatMessage("assistant", "ðŸ”§ Trade performance analysis and comparisons");
                addChatMessage("assistant", "ðŸ¢ Level/floor progress analysis");
                addChatMessage("assistant", "âš¡ Project velocity and timeline predictions");
                addChatMessage("assistant", "ðŸš¨ Problem identification and recommendations");
                addChatMessage("assistant", "Try asking something like: 'How are the trades performing?' or 'What problems do we have?'");
                return;
            }

            if (sortedIntents.length === 1) {
                // Single intent with lower confidence - provide context-aware response
                const intent = sortedIntents[0];
                addChatMessage("assistant", `I think you're asking about ${intent.type}. Let me provide some insights:`);
                
                // Route to appropriate handler with lower threshold
                switch (intent.type) {
                    case 'completion':
                        handleCompletionQuery(userMessage, intents);
                        break;
                    case 'trade':
                        handleTradeQuery(userMessage, intents);
                        break;
                    case 'location':
                        handleLocationQuery(userMessage, intents);
                        break;
                    case 'timeline':
                        handleTimelineQuery(userMessage, intents);
                        break;
                    case 'comparison':
                        handleComparisonQuery(userMessage, intents);
                        break;
                    case 'prediction':
                        handlePredictionQuery(userMessage, intents);
                        break;
                    case 'problem':
                        handleProblemQuery(userMessage, intents);
                        break;
                    case 'recommendation':
                        handleRecommendationQuery(userMessage, intents);
                        break;
                    case 'summary':
                        handleSummaryQuery(userMessage, intents);
                        break;
                    default:
                        handleGeneralQuery(userMessage);
                }
            } else {
                // Multiple intents detected - provide comprehensive response
                addChatMessage("assistant", "I can see you're interested in multiple aspects. Let me address each:");
                
                sortedIntents.slice(0, 2).forEach(intent => {
                    if (intent.confidence > 0.4) {
                        switch (intent.type) {
                            case 'completion':
                                addChatMessage("assistant", `ðŸ“Š **Completion Status:** ${dashboardData.overview.overallCompletion}% complete`);
                                break;
                            case 'trade':
                                const worstTrade = dashboardData.tradeAnalysis[0];
                                addChatMessage("assistant", `ðŸ”§ **Trade Issues:** ${worstTrade.trade} needs attention at ${worstTrade.completionRate}%`);
                                break;
                            case 'problem':
                                const criticalTrades = dashboardData.tradeAnalysis.filter(t => parseFloat(t.completionRate) < 20);
                                addChatMessage("assistant", `ðŸš¨ **Problems:** ${criticalTrades.length} critical bottlenecks identified`);
                                break;
                        }
                    }
                });
                
                addChatMessage("assistant", "Would you like me to dive deeper into any of these areas?");
            }
        }

        function handleGeneralQuery(userMessage) {
            const responses = [
                "I can help you analyze your construction data! Try asking about completion rates, trade performance, velocity, or specific problems.",
                "What would you like to know about your project? I can analyze completion rates, identify bottlenecks, compare floor progress, or provide recommendations.",
                "I'm here to help with construction analytics! Ask me about trade performance, project velocity, completion trends, or any specific concerns.",
                "Feel free to ask about your construction progress! I can analyze trades, levels, completion rates, or help identify issues and solutions."
            ];
            
            const randomResponse = responses[Math.floor(Math.random() * responses.length)];
            addChatMessage("assistant", randomResponse);
            
            if (dashboardData) {
                addChatMessage("assistant", `ðŸ“Š Quick stats: ${dashboardData.overview.overallCompletion}% complete â€¢ ${dashboardData.tradeAnalysis.length} trades â€¢ ${dashboardData.overview.completedTasks} tasks done`);
            }
            
            addChatMessage("assistant", `ðŸ’¬ Try asking: "What's our status?", "Which trades need help?", "Give me a summary", or "What problems do we have?"`);
        }

        function renderChatHistory() {
            const container = document.getElementById('chat-history');
            container.innerHTML = '';

            chatHistory.forEach((msg, index) => {
                const messageDiv = document.createElement('div');
                
                if (msg.type === 'message') {
                    messageDiv.className = msg.sender === 'user' ? 'flex justify-end' : 'flex justify-start';
                    
                    const messageClass = msg.sender === 'user' 
                        ? 'px-4 py-2 rounded-lg bg-blue-600 text-white max-w-xs lg:max-w-md'
                        : 'px-4 py-2 rounded-lg bg-gray-100 text-gray-900 max-w-full';
                    
                    messageDiv.innerHTML = `
                        <div class="${msg.sender === 'user' ? 'max-w-xs lg:max-w-md' : 'max-w-full'}">
                            <div class="${messageClass}">
                                <p class="text-sm">${msg.message}</p>
                            </div>
                        </div>
                    `;
                } else if (msg.type === 'tile') {
                    messageDiv.className = 'flex justify-start';
                    const severityClasses = {
                        critical: 'border-red-500 bg-red-50 hover:bg-red-100',
                        warning: 'border-yellow-500 bg-yellow-50 hover:bg-yellow-100',
                        good: 'border-green-500 bg-green-50 hover:bg-green-100'
                    };

                    const severityLabels = {
                        critical: 'Critical',
                        warning: 'Action Needed',
                        good: 'Performing Well'
                    };

                    const severityBadgeClasses = {
                        critical: 'bg-red-100 text-red-800',
                        warning: 'bg-yellow-100 text-yellow-800',
                        good: 'bg-green-100 text-green-800'
                    };

                    messageDiv.innerHTML = `
                        <div class="max-w-full">
                            <div class="mt-2 p-3 rounded-lg border-l-4 cursor-pointer transition-all tile-hover ${severityClasses[msg.tileData.severity]}" 
                                 onclick="handleTileClick(${index})">
                                <h4 class="font-semibold text-gray-900 text-sm">${msg.tileData.title}</h4>
                                <p class="text-xs text-gray-600 mt-1">${msg.tileData.description}</p>
                                <div class="flex items-center justify-between mt-2">
                                    <span class="px-2 py-1 text-xs rounded-full ${severityBadgeClasses[msg.tileData.severity]}">
                                        ${severityLabels[msg.tileData.severity]}
                                    </span>
                                    <span class="text-xs text-gray-500">Click to analyze â†’</span>
                                </div>
                            </div>
                        </div>
                    `;
                }

                container.appendChild(messageDiv);
            });

            // Scroll to bottom
            container.scrollTop = container.scrollHeight;
        }

        function handleTileClick(index) {
            const msg = chatHistory[index];
            selectedInsight = msg.tileData;
            activeChart = msg.tileData.chartType;
            
            // Hide default view and executive dashboard
            document.getElementById('default-chart-view').classList.add('hidden');
            document.getElementById('executive-dashboard').classList.add('hidden');
            
            // Hide all chart views
            document.getElementById('trade-progress-chart').classList.add('hidden');
            document.getElementById('level-comparison-chart').classList.add('hidden');
            document.getElementById('velocity-trend-chart').classList.add('hidden');
            document.getElementById('velocity-comparison-chart').classList.add('hidden');
            document.getElementById('stalled-trades-chart').classList.add('hidden');
            document.getElementById('stacked-trades-chart').classList.add('hidden');
            document.getElementById('burst-start-chart').classList.add('hidden');
            document.getElementById('swiss-cheese-chart').classList.add('hidden');
            document.getElementById('trade-blockage-chart').classList.add('hidden');
            document.getElementById('premature-start-chart').classList.add('hidden');
            
            // Show appropriate chart
            renderChart();
        }

        function renderChart() {
            switch (activeChart) {
                case 'trade-progress':
                    renderTradeProgressChart();
                    break;
                case 'level-comparison':
                    renderLevelComparisonChart();
                    break;
                case 'velocity-trend':
                    renderVelocityTrendChart();
                    break;
                case 'velocity-comparison':
                    renderVelocityComparisonChart();
                    break;
                case 'stalled-trades':
                    renderStalledTradesChart();
                    break;
                case 'stacked-trades':
                    renderStackedTradesChart();
                    break;
                case 'burst-start':
                    renderBurstStartChart();
                    break;
                case 'swiss-cheese':
                    renderSwissCheeseChart();
                    break;
                case 'trade-blockage':
                    renderTradeBlockageChart();
                    break;
                case 'premature-start':
                    renderPrematureStartChart();
                    break;
                default:
                    document.getElementById('executive-dashboard').classList.remove('hidden');
            }
        }

        function renderTradeProgressChart() {
            const container = document.getElementById('trade-progress-chart');
            container.classList.remove('hidden');
            
            const data = selectedInsight.data;
            const remaining = data.total - data.completed - data.inProgress;
            
            container.innerHTML = `
                <div class="p-6 space-y-6">
                    <div class="border-b border-gray-200 pb-4">
                        <h1 class="text-xl font-bold text-gray-900">${data.trade} Progress Analysis</h1>
                        <p class="text-gray-600">Detailed breakdown of completion status and bottlenecks</p>
                    </div>

                    <!-- Progress Overview -->
                    <div class="grid grid-cols-3 gap-4">
                        <div class="bg-green-50 p-4 rounded-lg border border-green-200">
                            <div class="text-center">
                                <p class="text-sm font-medium text-green-800">Completed</p>
                                <p class="text-2xl font-bold text-green-600">${data.completed}</p>
                                <p class="text-xs text-green-700">${data.completionRate}% of total</p>
                            </div>
                        </div>
                        <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                            <div class="text-center">
                                <p class="text-sm font-medium text-blue-800">In Progress</p>
                                <p class="text-2xl font-bold text-blue-600">${data.inProgress}</p>
                                <p class="text-xs text-blue-700">Active work items</p>
                            </div>
                        </div>
                        <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
                            <div class="text-center">
                                <p class="text-sm font-medium text-gray-600">Remaining</p>
                                <p class="text-2xl font-bold text-gray-900">${remaining}</p>
                                <p class="text-xs text-gray-500">Not started</p>
                            </div>
                        </div>
                    </div>

                    <!-- Visual Progress Bar -->
                    <div class="bg-white p-6 rounded-lg border border-gray-200">
                        <h3 class="text-lg font-semibold text-gray-900 mb-4">Progress Visualization</h3>
                        <div class="space-y-3">
                            <div class="flex justify-between text-sm font-medium text-gray-700">
                                <span>Overall Progress</span>
                                <span>${data.completionRate}%</span>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-4">
                                <div 
                                    class="h-4 rounded-full transition-all duration-500 ${
                                        parseFloat(data.completionRate) < 15 ? 'bg-red-500' :
                                        parseFloat(data.completionRate) < 30 ? 'bg-yellow-500' : 'bg-green-500'
                                    }"
                                    style="width: ${data.completionRate}%">
                                </div>
                            </div>
                            <div class="flex justify-between text-xs text-gray-500">
                                <span>0%</span>
                                <span>Target: 85%</span>
                                <span>100%</span>
                            </div>
                        </div>

                        <!-- Recommendations -->
                        <div class="mt-6">
                            <h4 class="font-semibold text-gray-900 mb-2">Recommendations</h4>
                            ${parseFloat(data.completionRate) < 15 ? `
                                <div class="bg-red-50 border border-red-200 rounded p-3">
                                    <p class="text-sm text-red-800">
                                        <strong>Critical Action Required:</strong> This trade has very low completion rates. 
                                        Consider adding additional crews, reviewing material availability, and increasing monitoring focus.
                                    </p>
                                </div>
                            ` : parseFloat(data.completionRate) < 30 ? `
                                <div class="bg-yellow-50 border border-yellow-200 rounded p-3">
                                    <p class="text-sm text-yellow-800">
                                        <strong>Monitor Closely:</strong> This trade needs attention. Consider increasing focus and resource allocation to improve completion rates.
                                    </p>
                                </div>
                            ` : `
                                <div class="bg-green-50 border border-green-200 rounded p-3">
                                    <p class="text-sm text-green-800">
                                        <strong>Performing Well:</strong> This trade has good completion rates. Continue monitoring and consider using excess capacity to support struggling trades.
                                    </p>
                                </div>
                            `}
                        </div>
                    </div>

                    <!-- Chart Container -->
                    <div class="bg-white p-6 rounded-lg border border-gray-200">
                        <h3 class="text-lg font-semibold text-gray-900 mb-4">Completion Status Breakdown</h3>
                        <div class="h-64">
                            <canvas id="tradeProgressChartCanvas"></canvas>
                        </div>
                    </div>
                </div>
            `;

            // Create doughnut chart
            setTimeout(() => {
                const ctx = document.getElementById('tradeProgressChartCanvas');
                if (ctx) {
                    new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: ['Completed', 'In Progress', 'Not Started'],
                            datasets: [{
                                data: [data.completed, data.inProgress, remaining],
                                backgroundColor: ['#10b981', '#3b82f6', '#6b7280'],
                                borderWidth: 2
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom'
                                }
                            }
                        }
                    });
                }
            }, 100);
        }

        function renderLevelComparisonChart() {
            const container = document.getElementById('level-comparison-chart');
            container.classList.remove('hidden');
            
            const data = selectedInsight.data;
            
            container.innerHTML = `
                <div class="p-6 space-y-6">
                    <div class="border-b border-gray-200 pb-4">
                        <h1 class="text-xl font-bold text-gray-900">Level Completion Analysis</h1>
                        <p class="text-gray-600">Vertical progress comparison and resource allocation insights</p>
                    </div>

                    <div class="grid grid-cols-2 gap-6">
                        <div class="bg-blue-50 p-6 rounded-lg border border-blue-200">
                            <h3 class="text-lg font-semibold text-blue-900 mb-2">Level 1</h3>
                            <div class="text-center mb-4">
                                <div class="text-4xl font-bold text-blue-600">${data.level1Rate}%</div>
                                <p class="text-blue-700">Completion Rate</p>
                            </div>
                            <div class="w-full bg-blue-200 rounded-full h-3">
                                <div 
                                    class="h-3 bg-blue-600 rounded-full transition-all duration-500"
                                    style="width: ${data.level1Rate}%">
                                </div>
                            </div>
                        </div>

                        <div class="bg-red-50 p-6 rounded-lg border border-red-200">
                            <h3 class="text-lg font-semibold text-red-900 mb-2">Level 2</h3>
                            <div class="text-center mb-4">
                                <div class="text-4xl font-bold text-red-600">${data.level2Rate}%</div>
                                <p class="text-red-700">Completion Rate</p>
                            </div>
                            <div class="w-full bg-red-200 rounded-full h-3">
                                <div 
                                    class="h-3 bg-red-600 rounded-full transition-all duration-500"
                                    style="width: ${data.level2Rate}%">
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-6">
                        <h3 class="text-lg font-semibold text-yellow-900 mb-4">âš ï¸ Resource Reallocation Needed</h3>
                        <p class="text-yellow-800 mb-4">
                            The ${data.gap.toFixed(1)}% completion gap between levels indicates inefficient resource distribution.
                        </p>
                        <div class="space-y-2 text-sm text-yellow-800">
                            <p>â€¢ <strong>Immediate Action:</strong> Move 30% of Level 1 crews to Level 2</p>
                            <p>â€¢ <strong>Expected Impact:</strong> Could accelerate Level 2 by 2-3 weeks</p>
                            <p>â€¢ <strong>Risk Mitigation:</strong> Maintain minimum crews on Level 1 for completion tasks</p>
                        </div>
                    </div>

                    <!-- Chart Container -->
                    <div class="bg-white p-6 rounded-lg border border-gray-200">
                        <h3 class="text-lg font-semibold text-gray-900 mb-4">Level Comparison Chart</h3>
                        <div class="h-64">
                            <canvas id="levelComparisonChartCanvas"></canvas>
                        </div>
                    </div>
                </div>
            `;

            // Create bar chart
            setTimeout(() => {
                const ctx = document.getElementById('levelComparisonChartCanvas');
                if (ctx) {
                    new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: ['Level 1', 'Level 2'],
                            datasets: [{
                                label: 'Completion Rate (%)',
                                data: [parseFloat(data.level1Rate), parseFloat(data.level2Rate)],
                                backgroundColor: ['#3b82f6', '#ef4444'],
                                borderWidth: 1
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    max: 100,
                                    title: {
                                        display: true,
                                        text: 'Completion Percentage'
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    display: false
                                }
                            }
                        }
                    });
                }
            }, 100);
        }

        function renderVelocityTrendChart() {
            const container = document.getElementById('velocity-trend-chart');
            container.classList.remove('hidden');
            
            const data = selectedInsight.data;
            
            if (!data.velocityData || data.velocityData.length === 0) {
                container.innerHTML = `
                    <div class="p-6">
                        <div class="text-center">
                            <p class="text-gray-500">No velocity data available - completion dates missing from data</p>
                        </div>
                    </div>
                `;
                return;
            }

            const topCompletionDays = data.velocityData
                .map(day => ({
                    ...day,
                    total: data.allTrades.reduce((sum, trade) => sum + (day[trade] || 0), 0)
                }))
                .sort((a, b) => b.total - a.total)
                .slice(0, 10)
                .sort((a, b) => a.date - b.date);

            const peakDay = Math.max(...data.velocityData.map(d => 
                data.allTrades.reduce((sum, trade) => sum + (d[trade] || 0), 0)
            ));

            const avgDaily = (data.totalCompleted / data.velocityData.length).toFixed(0);

            container.innerHTML = `
                <div class="p-6 space-y-6">
                    <div class="border-b border-gray-200 pb-4">
                        <h1 class="text-xl font-bold text-gray-900">Project Velocity Analysis</h1>
                        <p class="text-gray-600">Daily task completions by trade over time</p>
                    </div>

                    <!-- Summary Stats -->
                    <div class="grid grid-cols-4 gap-4">
                        <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                            <div class="text-center">
                                <p class="text-sm font-medium text-blue-800">Total Completed</p>
                                <p class="text-2xl font-bold text-blue-600">${data.totalCompleted}</p>
                                <p class="text-xs text-blue-700">tasks finished</p>
                            </div>
                        </div>
                        <div class="bg-green-50 p-4 rounded-lg border border-green-200">
                            <div class="text-center">
                                <p class="text-sm font-medium text-green-800">Peak Day</p>
                                <p class="text-2xl font-bold text-green-600">${peakDay}</p>
                                <p class="text-xs text-green-700">tasks in one day</p>
                            </div>
                        </div>
                        <div class="bg-purple-50 p-4 rounded-lg border border-purple-200">
                            <div class="text-center">
                                <p class="text-sm font-medium text-purple-800">Active Period</p>
                                <p class="text-2xl font-bold text-purple-600">${data.velocityData.length}</p>
                                <p class="text-xs text-purple-700">working days</p>
                            </div>
                        </div>
                        <div class="bg-yellow-50 p-4 rounded-lg border border-yellow-200">
                            <div class="text-center">
                                <p class="text-sm font-medium text-yellow-800">Avg Daily Rate</p>
                                <p class="text-2xl font-bold text-yellow-600">${avgDaily}</p>
                                <p class="text-xs text-yellow-700">tasks per day</p>
                            </div>
                        </div>
                    </div>

                    <!-- Chart Container -->
                    <div class="bg-white p-6 rounded-lg border border-gray-200">
                        <h3 class="text-lg font-semibold text-gray-900 mb-4">Daily Completions Trend</h3>
                        <div class="h-80">
                            <canvas id="velocityTrendChartCanvas"></canvas>
                        </div>
                    </div>

                    <!-- Top Performance Days -->
                    <div class="bg-green-50 border border-green-200 rounded-lg p-6">
                        <h3 class="text-lg font-semibold text-green-900 mb-4">ðŸ† Top Performance Days</h3>
                        <div class="space-y-2">
                            ${data.velocityData
                                .map(day => ({
                                    ...day,
                                    total: data.allTrades.reduce((sum, trade) => sum + (day[trade] || 0), 0)
                                }))
                                .sort((a, b) => b.total - a.total)
                                .slice(0, 5)
                                .map(day => `
                                    <div class="flex items-center justify-between bg-white p-3 rounded">
                                        <span class="text-sm font-medium">${day.dateStr}</span>
                                        <span class="text-lg font-bold text-green-600">${day.total} tasks</span>
                                    </div>
                                `).join('')}
                        </div>
                    </div>
                </div>
            `;

            // Create line chart
            setTimeout(() => {
                const ctx = document.getElementById('velocityTrendChartCanvas');
                if (ctx) {
                    const tradeColors = {
                        'Wall Drywall': '#10b981',
                        'Wall Drywall Finish': '#06b6d4', 
                        'In Wall Insulation': '#8b5cf6',
                        'Wall Prime Paint': '#f59e0b',
                        'Overhead Duct Insulation': '#ef4444',
                        'Overhead Plumbing': '#ec4899',
                        'Overhead Duct Rough In': '#6366f1'
                    };

                    const datasets = data.allTrades.map(trade => ({
                        label: trade,
                        data: data.velocityData.map(day => day[trade] || 0),
                        borderColor: tradeColors[trade] || '#6b7280',
                        backgroundColor: (tradeColors[trade] || '#6b7280') + '20',
                        tension: 0.4,
                        fill: false
                    }));

                    new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: data.velocityData.map(day => day.dateStr),
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: {
                                    beginAtZero: true,
                                    title: {
                                        display: true,
                                        text: 'Tasks Completed'
                                    }
                                },
                                x: {
                                    title: {
                                        display: true,
                                        text: 'Date'
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    position: 'bottom'
                                }
                            }
                        }
                    });
                }
            }, 100);
        }
        // New chart rendering functions for enhanced anomalies
        function renderVelocityComparisonChart() {
            const container = document.getElementById('velocity-comparison-chart');
            container.classList.remove('hidden');
            
            const data = selectedInsight.data;
            
            container.innerHTML = `
                <div class="p-6 space-y-6">
                    <div class="border-b border-gray-200 pb-4">
                        <h1 class="text-xl font-bold text-gray-900">Work Velocity Comparison</h1>
                        <p class="text-gray-600">Comparing task starts vs completions over time</p>
                    </div>
                    <div class="bg-white rounded-lg border p-4">
                        <div style="height: 300px;">
                            <canvas id="velocityComparisonChartCanvas"></canvas>
                        </div>
                    </div>
                </div>
            `;
            
            setTimeout(() => {
                const ctx = document.getElementById('velocityComparisonChartCanvas');
                if (ctx) {
                    new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: data.dates,
                            datasets: [{
                                label: 'Started (Not Started â†’ In Progress)',
                                data: data.starts,
                                borderColor: '#3B82F6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                tension: 0.4
                            }, {
                                label: 'Completed (In Progress â†’ Complete)',
                                data: data.completions,
                                borderColor: '#10B981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)',
                                tension: 0.4
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { beginAtZero: true }
                            }
                        }
                    });
                }
            }, 100);
        }

        function renderStalledTradesChart() {
            const container = document.getElementById('stalled-trades-chart');
            container.classList.remove('hidden');
            
            const data = selectedInsight.data;
            
            container.innerHTML = `
                <div class="p-6 space-y-6">
                    <div class="border-b border-gray-200 pb-4">
                        <h1 class="text-xl font-bold text-gray-900">Stalled Trades Analysis</h1>
                        <p class="text-gray-600">Tasks stuck in progress for extended periods</p>
                    </div>
                    <div class="bg-white rounded-lg border p-4">
                        <div style="height: 300px;">
                            <canvas id="stalledTradesChartCanvas"></canvas>
                        </div>
                    </div>
                    <div class="grid grid-cols-1 gap-4">
                        ${data.map(task => `
                            <div class="bg-red-50 border border-red-200 rounded-lg p-4">
                                <h3 class="font-semibold text-red-900">${task.location}</h3>
                                <p class="text-red-700">${task.trade} - ${task.duration} periods in progress</p>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            
            setTimeout(() => {
                const ctx = document.getElementById('stalledTradesChartCanvas');
                if (ctx) {
                    new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: data.map(task => task.location),
                            datasets: [{
                                label: 'Days Stalled',
                                data: data.map(task => task.duration),
                                backgroundColor: '#EF4444'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false } },
                            scales: { y: { beginAtZero: true } }
                        }
                    });
                }
            }, 100);
        }

        function renderStackedTradesChart() {
            const container = document.getElementById('stacked-trades-chart');
            container.classList.remove('hidden');
            
            const data = selectedInsight.data;
            
            container.innerHTML = `
                <div class="p-6 space-y-6">
                    <div class="border-b border-gray-200 pb-4">
                        <h1 class="text-xl font-bold text-gray-900">Stacked Trades Analysis</h1>
                        <p class="text-gray-600">Multiple competing trades at same locations</p>
                    </div>
                    <div class="bg-white rounded-lg border p-4">
                        <div style="height: 300px;">
                            <canvas id="stackedTradesChartCanvas"></canvas>
                        </div>
                    </div>
                    <div class="grid grid-cols-1 gap-4">
                        ${data.map(entry => `
                            <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
                                <h3 class="font-semibold text-yellow-900">${entry.location} (${entry.date})</h3>
                                <p class="text-yellow-700">${entry.count} competing trades: ${entry.trades.join(', ')}</p>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            
            setTimeout(() => {
                const ctx = document.getElementById('stackedTradesChartCanvas');
                if (ctx) {
                    new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: data.map(entry => entry.location),
                            datasets: [{
                                label: 'Competing Trades',
                                data: data.map(entry => entry.count),
                                backgroundColor: '#F59E0B'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false } },
                            scales: { y: { beginAtZero: true } }
                        }
                    });
                }
            }, 100);
        }

        function renderBurstStartChart() {
            const container = document.getElementById('burst-start-chart');
            container.classList.remove('hidden');
            
            const data = selectedInsight.data;
            
            container.innerHTML = `
                <div class="p-6 space-y-6">
                    <div class="border-b border-gray-200 pb-4">
                        <h1 class="text-xl font-bold text-gray-900">Burst Start Analysis</h1>
                        <p class="text-gray-600">Periods of unusually high task initiation</p>
                    </div>
                    <div class="bg-white rounded-lg border p-4">
                        <div style="height: 300px;">
                            <canvas id="burstStartChartCanvas"></canvas>
                        </div>
                    </div>
                </div>
            `;
            
            setTimeout(() => {
                const ctx = document.getElementById('burstStartChartCanvas');
                if (ctx) {
                    new Chart(ctx, {
                        type: 'line',
                        data: {
                            labels: data.map(entry => entry[0]),
                            datasets: [{
                                label: 'Task Starts',
                                data: data.map(entry => entry[1]),
                                borderColor: '#8B5CF6',
                                backgroundColor: 'rgba(139, 92, 246, 0.1)',
                                tension: 0.4,
                                fill: true
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: { y: { beginAtZero: true } }
                        }
                    });
                }
            }, 100);
        }

        function renderSwissCheeseChart() {
            const container = document.getElementById('swiss-cheese-chart');
            container.classList.remove('hidden');
            
            const data = selectedInsight.data;
            
            container.innerHTML = `
                <div class="p-6 space-y-6">
                    <div class="border-b border-gray-200 pb-4">
                        <h1 class="text-xl font-bold text-gray-900">Swiss Cheese Flow Analysis</h1>
                        <p class="text-gray-600">Locations with incomplete work patterns</p>
                    </div>
                    <div class="bg-white rounded-lg border p-4">
                        <div style="height: 300px;">
                            <canvas id="swissCheeseChartCanvas"></canvas>
                        </div>
                    </div>
                    <div class="grid grid-cols-1 gap-4">
                        ${data.map(location => `
                            <div class="bg-orange-50 border border-orange-200 rounded-lg p-4">
                                <h3 class="font-semibold text-orange-900">${location.location}</h3>
                                <p class="text-orange-700">${location.percentage}% completion - incomplete work pattern</p>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
            
            setTimeout(() => {
                const ctx = document.getElementById('swissCheeseChartCanvas');
                if (ctx) {
                    new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: data.map(location => location.location),
                            datasets: [{
                                label: 'Completion %',
                                data: data.map(location => parseFloat(location.percentage)),
                                backgroundColor: '#F97316'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false } },
                            scales: { y: { beginAtZero: true, max: 100 } }
                        }
                    });
                }
            }, 100);
        }

        function renderTradeBlockageChart() {
            const container = document.getElementById('trade-blockage-chart');
            container.classList.remove('hidden');
            
            const data = selectedInsight.data;
            
            container.innerHTML = `
                <div class="p-6 space-y-6">
                    <div class="border-b border-gray-200 pb-4">
                        <h1 class="text-xl font-bold text-gray-900">Trade Blockage Analysis</h1>
                        <p class="text-gray-600">Sections with blocked trades</p>
                    </div>
                    <div class="grid grid-cols-1 gap-4">
                        ${Object.entries(data).map(([section, trades]) => `
                            <div class="bg-red-50 border border-red-200 rounded-lg p-4">
                                <h3 class="font-semibold text-red-900">${section}</h3>
                                <p class="text-red-700">Blocked trades: ${trades.join(', ')}</p>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function renderPrematureStartChart() {
            const container = document.getElementById('premature-start-chart');
            container.classList.remove('hidden');
            
            container.innerHTML = `
                <div class="p-6 space-y-6">
                    <div class="border-b border-gray-200 pb-4">
                        <h1 class="text-xl font-bold text-gray-900">Premature Start Analysis</h1>
                        <p class="text-gray-600">Tasks started before prerequisites completed</p>
                    </div>
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <p class="text-blue-700">No premature starts detected in current data.</p>
                    </div>
                </div>
            `;
        }

    </script>
</body>
</html>
