<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNO UNO Construction Analytics Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .tab-button.active {
            border-bottom: 2px solid #3b82f6;
            color: #2563eb;
            background-color: #eff6ff;
        }
        .anomaly-tile {
            transition: all 0.2s;
            cursor: pointer;
        }
        .anomaly-tile:hover {
            border-color: #d1d5db;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .filter-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            z-index: 50;
            max-height: 200px;
            overflow-y: auto;
        }
        .filter-option {
            padding: 0.5rem;
            cursor: pointer;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .filter-option:hover {
            background-color: #f3f4f6;
        }
        .filter-option.selected {
            background-color: #eff6ff;
            color: #2563eb;
        }
        .filter-checkbox {
            width: 12px;
            height: 12px;
            border: 1px solid #d1d5db;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .filter-checkbox.checked {
            background-color: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="root" class="min-h-screen p-6">
        <div class="max-w-7xl mx-auto">
            <!-- Header -->
            <div class="mb-8">
                <div class="flex items-center justify-between mb-4">
                    <div>
                        <h1 class="text-3xl font-bold text-gray-900 mb-2">UNO Construction Analytics Dashboard</h1>
                        <p class="text-gray-600">Comprehensive analytics for construction project insights</p>
                    </div>
                    <a href="https://alicia-li-auckland.github.io/toys/uno_platform/" class="inline-flex items-center px-4 py-2 text-sm font-medium text-blue-600 bg-blue-50 border border-blue-200 rounded-lg hover:bg-blue-100 hover:text-blue-700 transition-colors duration-200">
                        <svg class="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
                        </svg>
                        Back to Platform
                    </a>
                </div>
            </div>

            <!-- Loading Section -->
            <div id="loading-section" class="min-h-screen flex items-center justify-center">
                <div class="max-w-2xl w-full">
                    <div class="text-center">
                        <div class="animate-spin w-16 h-16 border-4 border-blue-600 border-t-transparent rounded-full mx-auto mb-4"></div>
                        <h1 class="text-3xl font-bold text-gray-900 mb-2">UNO Construction Analytics Dashboard</h1>
                        <p class="text-gray-600">Loading UNO project data...</p>
                    </div>
                    </div>
                    
                    <div id="upload-progress" class="hidden mt-6">
                        <div class="text-center">
                            <div class="inline-flex items-center gap-2 text-blue-600">
                                <svg class="animate-spin h-4 w-4" fill="none" viewBox="0 0 24 24">
                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                    <path class="opacity-75" fill="currentColor" d="m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                                <span id="upload-status">Processing CSV file...</span>
                            </div>
                        </div>
                    </div>

                    <div id="upload-error" class="hidden mt-6 p-4 bg-red-50 border border-red-200 rounded-lg">
                        <div class="flex">
                            <svg class="w-5 h-5 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                            </svg>
                            <div class="ml-3">
                                <h3 class="text-sm font-medium text-red-800">Error processing file</h3>
                                <p id="error-message" class="text-sm text-red-700 mt-1"></p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Loading State -->
            <div id="loading" class="min-h-screen flex items-center justify-center hidden">
                <div class="text-center">
                    <svg class="w-12 h-12 text-gray-400 mx-auto mb-4 animate-pulse" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                    </svg>
                    <p class="text-gray-600">Loading construction analytics...</p>
                </div>
            </div>

            <!-- Main Dashboard -->
            <div id="dashboard" class="hidden">
                <!-- File Info & Filters -->
                <div class="bg-white p-4 rounded-lg shadow-sm border border-gray-200 mb-6">
                    <div class="flex items-center justify-between mb-4">
                        <div class="flex items-center gap-3">
                            <svg class="w-5 h-5 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            <div>
                                <p class="text-sm font-medium text-gray-900" id="file-info">Data loaded successfully</p>
                                <p class="text-xs text-gray-500" id="data-stats">Processing data...</p>
                            </div>
                        </div>
                        <button onclick="reloadData()" class="text-blue-600 hover:text-blue-800 text-sm font-medium">
                            Upload New File
                        </button>
                    </div>
                    
                    <div class="flex items-center gap-6 flex-wrap">
                        <div class="flex items-center gap-2">
                            <svg class="w-4 h-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.414A1 1 0 013 6.707V4z"></path>
                            </svg>
                            <span class="text-sm font-medium text-gray-700">Filters:</span>
                        </div>
                        
                        <div class="flex items-center gap-2">
                            <label class="text-xs text-gray-600">Level:</label>
                            <div class="relative">
                                <div id="levelFilterDisplay" class="text-xs border rounded px-2 py-1 min-w-24 bg-white cursor-pointer hover:bg-gray-50 flex items-center justify-between">
                                    <span>All Levels</span>
                                    <svg class="w-3 h-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                    </svg>
                                </div>
                            </div>
                        </div>
                        
                        <div class="flex items-center gap-2">
                            <label class="text-xs text-gray-600">Section:</label>
                            <div class="relative">
                                <div id="sectionFilterDisplay" class="text-xs border rounded px-2 py-1 min-w-24 bg-white cursor-pointer hover:bg-gray-50 flex items-center justify-between">
                                    <span>All Sections</span>
                                    <svg class="w-3 h-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                    </svg>
                                </div>
                            </div>
                        </div>
                        
                        <div class="flex items-center gap-2">
                            <label class="text-xs text-gray-600">Trade:</label>
                            <div class="relative">
                                <div id="tradeFilterDisplay" class="text-xs border rounded px-2 py-1 min-w-32 bg-white cursor-pointer hover:bg-gray-50 flex items-center justify-between">
                                    <span>All Trades</span>
                                    <svg class="w-3 h-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                    </svg>
                                </div>
                            </div>
                        </div>
                        
                        <div class="flex items-center gap-2">
                            <label class="text-xs text-gray-600">Time:</label>
                            <div class="relative">
                                <div id="timeFilterDisplay" class="text-xs border rounded px-2 py-1 min-w-32 bg-white cursor-pointer hover:bg-gray-50 flex items-center justify-between">
                                    <span>All Time</span>
                                    <svg class="w-3 h-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                    </svg>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Navigation Tabs -->
                <div class="bg-white rounded-lg shadow-sm border border-gray-200 mb-6">
                    <div class="flex border-b border-gray-200">
                        <button onclick="switchTab('executive')" class="tab-button px-6 py-3 text-sm font-medium border-b-2 border-transparent text-gray-500" id="executive-tab">
                            Executive Dashboard
                        </button>
                        <button onclick="switchTab('overview')" class="tab-button active px-6 py-3 text-sm font-medium border-b-2 border-blue-500 text-blue-600" id="overview-tab">
                            Project Overview
                        </button>
                        <button onclick="switchTab('anomalies')" class="tab-button px-6 py-3 text-sm font-medium border-b-2 border-transparent text-gray-500" id="anomalies-tab">
                            Trade Anomalies
                        </button>
                    </div>
                </div>

                <!-- Tab Content -->
                <div id="tab-content">
                    <!-- Executive Dashboard -->
                    <div id="executive-content" class="space-y-6 hidden">
                        <!-- Row 1: Key Metrics Cards -->
                        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
                            <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <p class="text-sm font-medium text-gray-600">Project Completion</p>
                                        <p class="text-3xl font-bold text-blue-600" id="completion-rate">0%</p>
                                        <p class="text-xs text-gray-500" id="completion-tasks">0 of 0 tasks</p>
                                    </div>
                                    <div class="w-10 h-10 bg-blue-100 rounded-full flex items-center justify-center">
                                        <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                        </svg>
                                    </div>
                                </div>
                            </div>

                            <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <p class="text-sm font-medium text-gray-600">Completion Rate</p>
                                        <p class="text-3xl font-bold text-green-600" id="work-velocity">0</p>
                                        <p class="text-xs text-gray-500">tasks/day average</p>
                                    </div>
                                    <div class="w-10 h-10 bg-green-100 rounded-full flex items-center justify-center">
                                        <svg class="w-6 h-6 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path>
                                        </svg>
                                    </div>
                                </div>
                            </div>

                            <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <p class="text-sm font-medium text-gray-600">Active Trades</p>
                                        <p class="text-3xl font-bold text-purple-600" id="active-trades">0</p>
                                        <p class="text-xs text-gray-500">currently working</p>
                                    </div>
                                    <div class="w-10 h-10 bg-purple-100 rounded-full flex items-center justify-center">
                                        <svg class="w-6 h-6 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                                        </svg>
                                    </div>
                                </div>
                            </div>

                            <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <p class="text-sm font-medium text-gray-600">Active Locations</p>
                                        <p class="text-3xl font-bold text-orange-600" id="active-locations">0</p>
                                        <p class="text-xs text-gray-500">with ongoing work</p>
                                    </div>
                                    <div class="w-10 h-10 bg-orange-100 rounded-full flex items-center justify-center">
                                        <svg class="w-6 h-6 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"></path>
                                        </svg>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Key Insights & Actions -->
                        <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                            <h3 class="text-lg font-semibold text-gray-900 mb-4 flex items-center gap-2">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                                </svg>
                                Key Insights & Actions
                            </h3>
                            <div class="grid grid-cols-1 lg:grid-cols-2 gap-4" id="insights-container">
                                <!-- Insights will be populated by JavaScript -->
                            </div>
                        </div>

                        <!-- Project Milestone Timeline -->
                        <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                            <h3 class="text-lg font-semibold text-gray-900 mb-6 flex items-center gap-2">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                                </svg>
                                Project Milestone Timeline
                            </h3>
                            
                            <!-- Timeline visualization -->
                            <div class="relative">
                                <!-- Timeline line -->
                                <div class="absolute left-6 top-0 bottom-0 w-0.5 bg-gray-300"></div>
                                
                                <div class="max-h-none overflow-visible" id="timeline-container">
                                    <!-- Timeline items will be populated by JavaScript -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Project Overview -->
                    <div id="overview-content" class="space-y-6">
                        <!-- Charts will be dynamically created here -->
                    </div>

                    <!-- Trade Anomalies -->
                    <div id="anomalies-content" class="space-y-6 hidden">
                        <!-- Anomaly Tiles -->
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4" id="anomaly-tiles">
                            <!-- Tiles will be populated by JavaScript -->
                        </div>

                        <!-- Anomaly Detail Chart -->
                        <div id="anomaly-chart-container" class="bg-white p-6 rounded-lg shadow-sm border border-gray-200 hidden">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="text-lg font-semibold text-gray-900" id="anomaly-chart-title">Anomaly Analysis</h3>
                                <button onclick="closeAnomalyChart()" class="text-gray-400 hover:text-gray-600">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                            <div class="h-80">
                                <canvas id="anomalyChart"></canvas>
                            </div>
                        </div>


                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize anomaly types with zero counts - will be updated by analyzeAnomalies()
        let anomalyTypes = [
            { id: 'abandonment', name: 'Stalled Trades', category: 'Time-based', count: 0, severity: 'high', color: '#ef4444' },
            { id: 'starvation', name: 'Stacked Trades', category: 'Time-based', count: 0, severity: 'high', color: '#ef4444' },
            { id: 'burst_start', name: 'Burst Start', category: 'Time-based', count: 0, severity: 'medium', color: '#f97316' },
            { id: 'swiss_cheese', name: 'Swiss-Cheese Flow', category: 'Spatial', count: 0, severity: 'medium', color: '#f97316' },
            { id: 'blockage', name: 'Trade Blockage', category: 'Cross-trade', count: 0, severity: 'high', color: '#ef4444' },
            { id: 'premature_start', name: 'Premature Start', category: 'Cross-trade', count: 0, severity: 'medium', color: '#f97316' }
        ];

        // Data arrays - start empty until CSV is uploaded
        let currentData = [];
        let filteredData = [];
        let charts = {};

        // Automatically load UNO data
        async function autoLoadUNOData() {
            try {
                showLoadingScreen();
                const response = await fetch('UNO_construction_data_fixed.csv');
                
                if (!response.ok) {
                    throw new Error(`Failed to load data: ${response.status}`);
                }
                
                const csvContent = await response.text();
                const data = parseCSV(csvContent);
                
                if (data.length === 0) {
                    throw new Error('No data found in CSV file');
                }

                currentData = data;
                filteredData = [...data];
                
                initDashboard();
                
            } catch (error) {
                console.error('Error loading UNO data:', error);
                showLoadingError(error.message);
            }
        }

        function showLoadingScreen() {
            document.getElementById('loading-section').classList.remove('hidden');
            document.getElementById('dashboard').classList.add('hidden');
        }

        function showLoadingError(message) {
            const loadingSection = document.getElementById('loading-section');
            loadingSection.innerHTML = `
                <div class="max-w-2xl w-full">
                    <div class="text-center">
                        <svg class="w-16 h-16 text-red-500 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16c-.77.833.192 2.5 1.732 2.5z"/>
                        </svg>
                        <h1 class="text-3xl font-bold text-gray-900 mb-2">Error Loading Data</h1>
                        <p class="text-gray-600 mb-4">${message}</p>
                        <button onclick="autoLoadUNOData()" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700">
                            Retry
                        </button>
                    </div>
                </div>
            `;
        }

        // Initialize upload functionality
        function initUpload() {
            const dropzone = document.getElementById('dropzone');
            const csvFile = document.getElementById('csvFile');

            // Dropzone click handler
            dropzone.addEventListener('click', () => {
                csvFile.click();
            });

            // File selection handler
            csvFile.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileUpload(e.target.files[0]);
                }
            });

            // Drag and drop handlers
            dropzone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropzone.classList.add('border-blue-400', 'bg-blue-50');
            });

            dropzone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dropzone.classList.remove('border-blue-400', 'bg-blue-50');
            });

            dropzone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropzone.classList.remove('border-blue-400', 'bg-blue-50');
                
                if (e.dataTransfer.files.length > 0) {
                    const file = e.dataTransfer.files[0];
                    if (file.type === 'text/csv' || file.name.endsWith('.csv')) {
                        handleFileUpload(file);
                    } else {
                        showError('Please upload a CSV file.');
                    }
                }
            });


        }

        // Handle CSV file upload
        function handleFileUpload(file) {
            if (!file.name.endsWith('.csv')) {
                showError('Please select a CSV file.');
                return;
            }

            showProgress('Reading CSV file...');

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvContent = e.target.result;
                    parseCSV(csvContent);
                } catch (error) {
                    showError('Error reading file: ' + error.message);
                }
            };
            reader.onerror = function() {
                showError('Error reading file.');
            };
            reader.readAsText(file);
        }

        // Parse CSV content
        function parseCSV(csvContent) {
            showProgress('Processing CSV data...');

            try {
                const lines = csvContent.trim().split('\n');
                if (lines.length < 2) {
                    throw new Error('CSV file must contain at least a header row and one data row.');
                }

                const headers = lines[0].split(',').map(h => h.replace(/"/g, '').trim().toLowerCase());
                const data = [];

                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',').map(v => v.replace(/"/g, '').trim());
                    if (values.length !== headers.length) continue; // Skip malformed rows
                    
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index] || '';
                    });

                    // Only include rows that have essential data
                    if (row.trade && row.location) {
                        data.push(row);
                    }
                }

                if (data.length === 0) {
                    throw new Error('No valid data rows found. Please ensure your CSV has trade and location columns.');
                }

                // Validate required columns
                const requiredColumns = ['trade', 'location'];
                const missingColumns = requiredColumns.filter(col => !headers.includes(col));
                if (missingColumns.length > 0) {
                    throw new Error(`Missing required columns: ${missingColumns.join(', ')}`);
                }

                // Update data and initialize dashboard
                currentData = data.map(row => ({
                    trade: row.trade,
                    location: row.location,
                    state: row.state || row.status || 'unknown',
                    level: row.level || row['level / floor'] || row.floor || '1',
                    section: row.section || 'A',
                    capture_date: row.capture_date || row.date || new Date().toISOString().split('T')[0],
                    complete_date: row.complete_date || row.completion_date || null
                }));

                filteredData = [...currentData];
                
                showProgress('Initializing dashboard...');
                setTimeout(() => {
                    initDashboard();
                }, 500);

            } catch (error) {
                showError('Error parsing CSV: ' + error.message);
            }
        }



        // Initialize dashboard
        function initDashboard() {
            document.getElementById('loading-section').classList.add('hidden');
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('dashboard').classList.remove('hidden');
            
            updateDataStats();
            populateFilters();
            updateMetrics();
            
            // Analyze anomalies with real data before rendering tiles
            analyzeAnomalies(currentData);
            renderAnomalyTiles();
            
            renderInsights();
            renderTimeline();
            
            // Initialize Project Overview tab since it's the default
            switchTab('overview');
        }

        // Update data statistics
        function updateDataStats() {
            // Count unique location-trade combinations (actual tasks, not CSV rows)
            const uniqueTasks = new Set(currentData.map(row => `${row.location}_${row.trade}`));
            const totalTasks = uniqueTasks.size;
            const uniqueTrades = [...new Set(currentData.map(row => row.trade))].length;
            const uniqueLocations = [...new Set(currentData.map(row => row.location))].length;
            
            document.getElementById('data-stats').textContent = 
                `${totalTasks} tasks • ${uniqueTrades} trades • ${uniqueLocations} locations`;
        }

        // Reload data
        function reloadData() {
            document.getElementById('dashboard').classList.add('hidden');
            
            // Reset data
            currentData = [];
            filteredData = [];
            
            // Reload UNO data
            autoLoadUNOData();
        }

        // Show upload progress
        function showProgress(message) {
            document.getElementById('upload-error').classList.add('hidden');
            document.getElementById('upload-progress').classList.remove('hidden');
            document.getElementById('upload-status').textContent = message;
        }

        // Show error message
        function showError(message) {
            document.getElementById('upload-progress').classList.add('hidden');
            document.getElementById('upload-error').classList.remove('hidden');
            document.getElementById('error-message').textContent = message;
        }

        // Multi-select filter state
        const filterState = {
            levels: [],
            sections: [],
            trades: [],
            time: []
        };

        // Populate filter dropdowns with multi-select functionality
        function populateFilters() {
            const levels = [...new Set(currentData.map(row => row.level))].sort();
            const sections = [...new Set(currentData.map(row => row.section).filter(Boolean))].sort();
            const availableTrades = [...new Set(currentData.map(row => row.trade))];
            const trades = getOrderedTrades(availableTrades);
            const captureDates = [...new Set(currentData.map(row => row.capture_date).filter(Boolean))].sort();

            // Initialize filter state
            filterState.levels = [];
            filterState.sections = [];
            filterState.trades = [];
            filterState.time = [];

            // Setup multi-select for levels
            setupMultiSelect('level', levels, (level) => `Level ${level}`);
            
            // Setup multi-select for sections
            setupMultiSelect('section', sections, (section) => `Section ${section}`);
            
            // Setup multi-select for trades
            setupMultiSelect('trade', trades, (trade) => trade);
            
            // Setup multi-select for time with special handling
            setupTimeFilter(captureDates);
        }

        // Setup multi-select dropdown functionality
        function setupMultiSelect(filterType, options, labelFormatter) {
            const display = document.getElementById(`${filterType}FilterDisplay`);
            const container = display.parentElement;
            
            // Remove existing dropdown if any
            const existingDropdown = container.querySelector('.filter-dropdown');
            if (existingDropdown) {
                existingDropdown.remove();
            }

            // Create dropdown
            const dropdown = document.createElement('div');
            dropdown.className = 'filter-dropdown hidden';
            
            // Add "All" option
            const allOption = document.createElement('div');
            allOption.className = 'filter-option selected';
            allOption.innerHTML = `
                <div class="filter-checkbox checked">✓</div>
                <span>All ${filterType.charAt(0).toUpperCase() + filterType.slice(1)}s</span>
            `;
            allOption.onclick = () => selectAllOptions(filterType, dropdown, display);
            dropdown.appendChild(allOption);

            // Add individual options
            options.forEach(option => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'filter-option';
                optionDiv.innerHTML = `
                    <div class="filter-checkbox"></div>
                    <span>${labelFormatter(option)}</span>
                `;
                optionDiv.dataset.value = option;
                optionDiv.onclick = () => toggleOption(filterType, option, optionDiv, dropdown, display);
                dropdown.appendChild(optionDiv);
            });

            container.appendChild(dropdown);

            // Toggle dropdown on display click
            display.onclick = () => {
                dropdown.classList.toggle('hidden');
                // Close other dropdowns
                document.querySelectorAll('.filter-dropdown').forEach(d => {
                    if (d !== dropdown) d.classList.add('hidden');
                });
            };

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!container.contains(e.target)) {
                    dropdown.classList.add('hidden');
                }
            });
        }

        // Setup time filter with both individual dates and period options
        function setupTimeFilter(captureDates) {
            const display = document.getElementById('timeFilterDisplay');
            const container = display.parentElement;
            
            // Remove existing dropdown if any
            const existingDropdown = container.querySelector('.filter-dropdown');
            if (existingDropdown) {
                existingDropdown.remove();
            }

            // Create dropdown
            const dropdown = document.createElement('div');
            dropdown.className = 'filter-dropdown hidden';
            
            // Add "All Time" option
            const allOption = document.createElement('div');
            allOption.className = 'filter-option selected';
            allOption.innerHTML = `
                <div class="filter-checkbox checked">✓</div>
                <span>All Time</span>
            `;
            allOption.onclick = () => selectAllTimeOptions(dropdown, display);
            dropdown.appendChild(allOption);

            // Add period options
            const periods = [
                { id: 'last_week', label: 'Last 7 Days' },
                { id: 'last_2_weeks', label: 'Last 2 Weeks' },
                { id: 'last_month', label: 'Last 30 Days' }
            ];

            periods.forEach(period => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'filter-option';
                optionDiv.innerHTML = `
                    <div class="filter-checkbox"></div>
                    <span>${period.label}</span>
                `;
                optionDiv.dataset.value = period.id;
                optionDiv.onclick = () => toggleTimePeriod(period.id, optionDiv, dropdown, display, captureDates);
                dropdown.appendChild(optionDiv);
            });

            // Add separator
            const separator = document.createElement('div');
            separator.className = 'border-t border-gray-200 my-1';
            dropdown.appendChild(separator);

            // Add individual capture dates
            captureDates.forEach(date => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'filter-option';
                optionDiv.innerHTML = `
                    <div class="filter-checkbox"></div>
                    <span>${date}</span>
                `;
                optionDiv.dataset.value = date;
                optionDiv.onclick = () => toggleTimeOption(date, optionDiv, dropdown, display);
                dropdown.appendChild(optionDiv);
            });

            container.appendChild(dropdown);

            // Toggle dropdown on display click
            display.onclick = () => {
                dropdown.classList.toggle('hidden');
                // Close other dropdowns
                document.querySelectorAll('.filter-dropdown').forEach(d => {
                    if (d !== dropdown) d.classList.add('hidden');
                });
            };

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!container.contains(e.target)) {
                    dropdown.classList.add('hidden');
                }
            });
        }

        // Helper functions for multi-select
        function selectAllOptions(filterType, dropdown, display) {
            // Clear current selection
            filterState[filterType + 's'] = [];
            
            // Update visual state
            dropdown.querySelectorAll('.filter-option').forEach((option, index) => {
                option.classList.remove('selected');
                const checkbox = option.querySelector('.filter-checkbox');
                checkbox.classList.remove('checked');
                checkbox.textContent = '';
                
                // Select "All" option (first option)
                if (index === 0) {
                    option.classList.add('selected');
                    checkbox.classList.add('checked');
                    checkbox.textContent = '✓';
                }
            });
            
            // Update display
            updateFilterDisplay(filterType, display);
            
            // Apply filters
            applyFilters();
        }

        function toggleOption(filterType, value, optionDiv, dropdown, display) {
            const filterArray = filterState[filterType + 's'];
            const allOption = dropdown.querySelector('.filter-option');
            const checkbox = optionDiv.querySelector('.filter-checkbox');
            const allCheckbox = allOption.querySelector('.filter-checkbox');
            
            if (filterArray.includes(value)) {
                // Remove from selection
                const index = filterArray.indexOf(value);
                filterArray.splice(index, 1);
                optionDiv.classList.remove('selected');
                checkbox.classList.remove('checked');
                checkbox.textContent = '';
            } else {
                // Add to selection
                filterArray.push(value);
                optionDiv.classList.add('selected');
                checkbox.classList.add('checked');
                checkbox.textContent = '✓';
                
                // Remove "All" selection when individual items are selected
                allOption.classList.remove('selected');
                allCheckbox.classList.remove('checked');
                allCheckbox.textContent = '';
            }
            
            // If no individual options selected, select "All"
            if (filterArray.length === 0) {
                allOption.classList.add('selected');
                allCheckbox.classList.add('checked');
                allCheckbox.textContent = '✓';
            }
            
            updateFilterDisplay(filterType, display);
            applyFilters();
        }

        function updateFilterDisplay(filterType, display) {
            const filterArray = filterState[filterType + 's'];
            const textSpan = display.querySelector('span');
            
            if (filterArray.length === 0) {
                textSpan.textContent = `All ${filterType.charAt(0).toUpperCase() + filterType.slice(1)}s`;
            } else if (filterArray.length === 1) {
                const label = filterType === 'level' ? `Level ${filterArray[0]}` : 
                             filterType === 'section' ? `Section ${filterArray[0]}` : 
                             filterArray[0];
                textSpan.textContent = label;
            } else {
                textSpan.textContent = `${filterArray.length} ${filterType.charAt(0).toUpperCase() + filterType.slice(1)}s`;
            }
        }

        // Time filter helper functions
        function selectAllTimeOptions(dropdown, display) {
            filterState.time = [];
            
            dropdown.querySelectorAll('.filter-option').forEach((option, index) => {
                option.classList.remove('selected');
                const checkbox = option.querySelector('.filter-checkbox');
                checkbox.classList.remove('checked');
                checkbox.textContent = '';
                
                if (index === 0) {
                    option.classList.add('selected');
                    checkbox.classList.add('checked');
                    checkbox.textContent = '✓';
                }
            });
            
            updateTimeFilterDisplay(display);
            applyFilters();
        }

        function toggleTimePeriod(periodId, optionDiv, dropdown, display, captureDates) {
            const allOption = dropdown.querySelector('.filter-option');
            const checkbox = optionDiv.querySelector('.filter-checkbox');
            const allCheckbox = allOption.querySelector('.filter-checkbox');
            
            // Clear all other selections
            dropdown.querySelectorAll('.filter-option').forEach(option => {
                option.classList.remove('selected');
                const cb = option.querySelector('.filter-checkbox');
                cb.classList.remove('checked');
                cb.textContent = '';
            });
            
            // Select this period
            optionDiv.classList.add('selected');
            checkbox.classList.add('checked');
            checkbox.textContent = '✓';
            
            // Calculate dates for this period
            const now = new Date();
            let daysBack = 7;
            if (periodId === 'last_2_weeks') daysBack = 14;
            if (periodId === 'last_month') daysBack = 30;
            
            const cutoffDate = new Date(now.getTime() - (daysBack * 24 * 60 * 60 * 1000));
            filterState.time = captureDates.filter(date => new Date(date) >= cutoffDate);
            
            updateTimeFilterDisplay(display);
            applyFilters();
        }

        function toggleTimeOption(date, optionDiv, dropdown, display) {
            const allOption = dropdown.querySelector('.filter-option');
            const checkbox = optionDiv.querySelector('.filter-checkbox');
            const allCheckbox = allOption.querySelector('.filter-checkbox');
            
            if (filterState.time.includes(date)) {
                const index = filterState.time.indexOf(date);
                filterState.time.splice(index, 1);
                optionDiv.classList.remove('selected');
                checkbox.classList.remove('checked');
                checkbox.textContent = '';
            } else {
                filterState.time.push(date);
                optionDiv.classList.add('selected');
                checkbox.classList.add('checked');
                checkbox.textContent = '✓';
                allOption.classList.remove('selected');
                allCheckbox.classList.remove('checked');
                allCheckbox.textContent = '';
            }
            
            if (filterState.time.length === 0) {
                allOption.classList.add('selected');
                allCheckbox.classList.add('checked');
                allCheckbox.textContent = '✓';
            }
            
            updateTimeFilterDisplay(display);
            applyFilters();
        }

        function updateTimeFilterDisplay(display) {
            const textSpan = display.querySelector('span');
            
            if (filterState.time.length === 0) {
                textSpan.textContent = 'All Time';
            } else if (filterState.time.length === 1) {
                textSpan.textContent = filterState.time[0];
            } else {
                textSpan.textContent = `${filterState.time.length} Days`;
            }
        }

        // Apply filters with multi-select support
        function applyFilters() {
            filteredData = currentData.filter(row => {
                const levelMatch = filterState.levels.length === 0 || filterState.levels.includes(row.level);
                const sectionMatch = filterState.sections.length === 0 || filterState.sections.includes(row.section);
                const tradeMatch = filterState.trades.length === 0 || filterState.trades.includes(row.trade);
                const timeMatch = filterState.time.length === 0 || filterState.time.includes(row.capture_date);
                
                return levelMatch && sectionMatch && tradeMatch && timeMatch;
            });

            updateMetrics();
            
            // Re-analyze anomalies with filtered data
            analyzeAnomalies(filteredData);
            renderAnomalyTiles();
            
            updateCharts();
        }

        // Update metrics
        function updateMetrics() {
            console.log('📊 UPDATING METRICS WITH PROPER NO DATA HANDLING');
            
            // Get final state for each unique task, ignoring 'no data' entries
            const taskStates = {};
            filteredData.forEach(row => {
                const taskKey = `${row.location}_${row.trade}`;
                const captureDate = row.capture_date;
                
                // Skip 'no data' entries - they mean location wasn't captured that day
                if (row.state === 'no data') {
                    return;
                }
                
                if (!taskStates[taskKey] || captureDate > taskStates[taskKey].date) {
                    taskStates[taskKey] = {
                        state: row.state,
                        date: captureDate,
                        location: row.location,
                        trade: row.trade
                    };
                }
            });
            
            const allTaskKeys = Object.keys(taskStates);
            const totalTasks = allTaskKeys.length;
            
            const completedTaskKeys = allTaskKeys.filter(taskKey => 
                taskStates[taskKey].state === 'complete'
            );
            const completedTasks = completedTaskKeys.length;
            
            // Count unique trades that have at least one "in progress" task based on final states
            const activeTrades = [...new Set(allTaskKeys.filter(taskKey => {
                const task = taskStates[taskKey];
                return task.state === 'in progress' || task.state === 'in-progress';
            }).map(taskKey => taskStates[taskKey].trade))].length;
            
            const completionRate = totalTasks > 0 ? ((completedTasks / totalTasks) * 100).toFixed(1) : 0;
            
            console.log(`📊 Metrics: ${completedTasks}/${totalTasks} = ${completionRate}% (${activeTrades} active trades)`);

            // Calculate work velocity using completed tasks with final state
            const completionDates = [...new Set(filteredData
                .filter(row => 
                    row.complete_date && 
                    row.state === 'complete' && 
                    row.state !== 'no data' &&
                    completedTaskKeys.includes(`${row.location}_${row.trade}`)
                )
                .map(row => row.complete_date)
            )];
            
            const workVelocity = completionDates.length > 0 ? 
                Math.round(completedTasks / completionDates.length) : 0;

            // Get last capture date (excluding 'no data' entries)
            const captureDates = [...new Set(filteredData
                .filter(row => row.state !== 'no data')
                .map(row => row.capture_date)
                .filter(Boolean)
            )].sort();
            const lastCaptureDate = captureDates.length > 0 ? 
                captureDates[captureDates.length - 1] : 'N/A';
            
            // Format last capture date for display
            let formattedLastCapture = lastCaptureDate;
            if (lastCaptureDate !== 'N/A') {
                const parts = lastCaptureDate.split('/');
                if (parts.length === 3) {
                    formattedLastCapture = parts[1] + '/' + parts[2]; // MM/DD
                } else {
                    const dateParts = lastCaptureDate.split('-');
                    if (dateParts.length === 3) {
                        formattedLastCapture = dateParts[1] + '/' + dateParts[2]; // MM/DD from YYYY-MM-DD
                    }
                }
            }

            // Count unique locations that have at least one "in progress" task based on final states
            const activeLocations = [...new Set(allTaskKeys.filter(taskKey => {
                const task = taskStates[taskKey];
                return task.state === 'in progress' || task.state === 'in-progress';
            }).map(taskKey => taskStates[taskKey].location))].length;

            // Update DOM elements
            document.getElementById('completion-rate').textContent = `${completionRate}%`;
            document.getElementById('completion-tasks').textContent = `${completedTasks} of ${totalTasks} tasks`;
            document.getElementById('active-trades').textContent = activeTrades;
            document.getElementById('work-velocity').textContent = workVelocity > 0 ? `+${workVelocity}` : '0';
            document.getElementById('active-locations').textContent = activeLocations;
        }

        // Switch tabs
        function switchTab(tab) {
            console.log('Switching to tab:', tab);
            
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`${tab}-tab`).classList.add('active');

            // Show/hide content
            if (tab === 'anomalies') {
                console.log('Showing anomalies tab');
                document.getElementById('executive-content').classList.add('hidden');
                document.getElementById('anomalies-content').classList.remove('hidden');
                if (document.getElementById('overview-content')) {
                    document.getElementById('overview-content').classList.add('hidden');
                }
                console.log('Anomalies content visibility:', !document.getElementById('anomalies-content').classList.contains('hidden'));
            } else if (tab === 'overview') {
                document.getElementById('executive-content').classList.add('hidden');
                document.getElementById('anomalies-content').classList.add('hidden');
                
                // Create overview content with charts if it's empty
                const overviewContent = document.getElementById('overview-content');
                if (overviewContent.children.length === 0) {
                    createOverviewTab();
                }
                overviewContent.classList.remove('hidden');
            } else {
                // Executive dashboard
                document.getElementById('executive-content').classList.remove('hidden');
                document.getElementById('anomalies-content').classList.add('hidden');
                if (document.getElementById('overview-content')) {
                    document.getElementById('overview-content').classList.add('hidden');
                }
            }
        }

        // Create overview tab with charts
        function createOverviewTab() {
            const overviewContent = document.getElementById('overview-content');
            overviewContent.innerHTML = `
                <!-- Row 2: Trade Progress Chart -->
                <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                    <h3 class="text-lg font-semibold text-gray-900 mb-4">Trade Progress Over Time</h3>
                    <div class="h-80">
                        <canvas id="progressChart"></canvas>
                    </div>
                </div>

                <!-- Row 3: Velocity Chart -->
                <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                    <h3 class="text-lg font-semibold text-gray-900 mb-4">Daily Completion Velocity</h3>
                    <div class="h-80">
                        <canvas id="velocityChart"></canvas>
                    </div>
                </div>

                <!-- Row 4: Velocity Comparison Chart -->
                <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                    <h3 class="text-lg font-semibold text-gray-900 mb-4">Trade Velocity Comparison</h3>
                    <div class="h-80">
                        <canvas id="velocityComparisonChart"></canvas>
                    </div>
                </div>

                <!-- Row 5: Distribution Charts -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                        <h3 class="text-lg font-semibold text-gray-900 mb-4">Trade Distribution</h3>
                        <div class="h-64">
                            <canvas id="distributionChart"></canvas>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                        <h3 class="text-lg font-semibold text-gray-900 mb-4">Trade Performance</h3>
                        <div class="h-64">
                            <canvas id="performanceChart"></canvas>
                        </div>
                    </div>
                </div>
            `;
            
            // Create charts after DOM is updated
            setTimeout(() => {
                createCharts();
            }, 100);
        }

        // Centralized trade ordering function
        function getOrderedTrades(availableTrades) {
            const tradeOrder = [
                'Concrete Formwork',
                'Concrete Rebar',
                'Backfill',
                'Electrical Yard Equipment Conduit',
                'Structural Piles',
                'Concrete Pour',
                'Structural Steel',
                'Generator Placement',
                'DWTR Installation',
                'MWT Installation',
                'Mechanical Yard - Equipment Placement',
                'Electrical Yard 96 Equipment Placement',
                'Conveyance',
                'Booster Pump System Installation',
                'Roofing Metal Deck',
                'Roofing Insulation',
                'Roofing Membrane',
                'Roofing Flashing'
            ];
            
            // Function to normalize trade names for comparison
            function normalizeTradeForComparison(trade) {
                return trade.toLowerCase()
                    .replace(/[-\s]+/g, ' ')
                    .replace(/\s+/g, ' ')
                    .trim();
            }
            
            // Get trades in preferred order first
            const orderedTrades = tradeOrder.filter(orderTrade => {
                return availableTrades.some(availableTrade => {
                    const normalizedOrder = normalizeTradeForComparison(orderTrade);
                    const normalizedAvailable = normalizeTradeForComparison(availableTrade);
                    return normalizedOrder === normalizedAvailable || 
                           normalizedAvailable.includes(normalizedOrder) ||
                           normalizedOrder.includes(normalizedAvailable);
                });
            }).map(orderTrade => {
                return availableTrades.find(availableTrade => {
                    const normalizedOrder = normalizeTradeForComparison(orderTrade);
                    const normalizedAvailable = normalizeTradeForComparison(availableTrade);
                    return normalizedOrder === normalizedAvailable || 
                           normalizedAvailable.includes(normalizedOrder) ||
                           normalizedOrder.includes(normalizedAvailable);
                });
            });
            
            // Add any trades not in the sequence at the end
            const otherTrades = availableTrades.filter(trade => !orderedTrades.includes(trade)).sort();
            return [...orderedTrades, ...otherTrades];
        }

        // Create charts
        function createCharts() {
            createProgressChart();
            createVelocityChart();
            createVelocityComparisonChart();
            createDistributionChart();
            createPerformanceChart();
        }

        function createProgressChart() {
            const ctx = document.getElementById('progressChart').getContext('2d');
            
            // Get all unique dates and sort them
            const allDates = [...new Set(filteredData.map(row => row.capture_date).filter(Boolean))].sort();
            const availableTrades = [...new Set(filteredData.map(row => row.trade).filter(Boolean))];
            const trades = getOrderedTrades(availableTrades);
            
            // If no dates, use placeholder
            if (allDates.length === 0) {
                allDates.push(new Date().toISOString().split('T')[0]);
            }
            
            // Format dates for display (MM/DD)
            const dateLabels = allDates.map(date => {
                const parts = date.split('/');
                if (parts.length === 3) {
                    return parts[1] + '/' + parts[2]; // MM/DD
                }
                return date.split('-').slice(1).join('/'); // Handle YYYY-MM-DD format
            });
            
            // Create datasets for each trade
            const datasets = trades.map((trade, index) => {
                const tradeData = allDates.map(date => {
                    // Get unique completed location-trade combinations up to this date
                    const completedUpToDate = new Set(
                        filteredData
                            .filter(row => 
                                row.trade === trade && 
                                row.state === 'complete' && 
                                row.complete_date && 
                                row.complete_date <= date
                            )
                            .map(row => `${row.location}_${row.trade}`)
                    );
                    
                    // Get total unique tasks for this trade
                    const totalTradeTasks = new Set(
                        filteredData
                            .filter(row => row.trade === trade)
                            .map(row => `${row.location}_${row.trade}`)
                    ).size;
                    
                    return totalTradeTasks > 0 ? Math.round((completedUpToDate.size / totalTradeTasks) * 100) : 0;
                });
                
                const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#06b6d4', '#84cc16'];
                
                return {
                    label: trade,
                    data: tradeData,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '20',
                    tension: 0.1,
                    fill: false
                };
            });
            
            charts.progress = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dateLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: '% Complete'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Capture Date'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    }
                }
            });
        }

        function createVelocityChart() {
            const ctx = document.getElementById('velocityChart').getContext('2d');
            
            // Get all unique completion dates and sort them, filtering out 'no data'
            const completionDates = [...new Set(filteredData
                .filter(row => 
                    row.complete_date && 
                    row.state === 'complete' && 
                    row.state !== 'no data'
                )
                .map(row => row.complete_date)
            )].sort();
            
            const availableTrades = [...new Set(filteredData.map(row => row.trade).filter(Boolean))];
            const trades = getOrderedTrades(availableTrades);
            
            // If no completion dates, show placeholder
            if (completionDates.length === 0) {
                charts.velocity = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: ['No Data'],
                        datasets: [{
                            label: 'No completed tasks found',
                            data: [0],
                            borderColor: '#9ca3af',
                            backgroundColor: 'rgba(156, 163, 175, 0.1)',
                            tension: 0.1,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Tasks Completed'
                                }
                            }
                        }
                    }
                });
                return;
            }
            
            // Format dates for display
            const dateLabels = completionDates.map(date => {
                const parts = date.split('/');
                if (parts.length === 3) {
                    return parts[1] + '/' + parts[2]; // MM/DD
                }
                return date.split('-').slice(1).join('/'); // Handle YYYY-MM-DD format
            });
            
            // Create datasets for each trade showing daily completions (unique location-trade combinations)
            const datasets = trades.map((trade, index) => {
                const tradeData = completionDates.map(date => {
                    // Get unique location-trade combinations for this date and trade
                    const uniqueCompletions = new Set(
                        filteredData
                            .filter(row => 
                                row.trade === trade && 
                                row.complete_date === date && 
                                row.state === 'complete'
                            )
                            .map(row => `${row.location}_${row.trade}`)
                    );
                    return uniqueCompletions.size;
                });
                
                const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#06b6d4', '#84cc16'];
                
                return {
                    label: trade,
                    data: tradeData,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '20',
                    tension: 0.1,
                    fill: false
                };
            });
            
            // Add total line - using final states
            const totalData = completionDates.map(date => {
                // Count unique location-trade combinations completed on this date with final state complete
                const uniqueCompletions = new Set(
                    filteredData
                        .filter(row => 
                            row.complete_date === date && 
                            row.state === 'complete' &&
                            row.state !== 'no data'
                        )
                        .map(row => `${row.location}_${row.trade}`)
                );
                return uniqueCompletions.size;
            });
            
            datasets.push({
                label: 'Total (All Trades)',
                data: totalData,
                borderColor: '#1f2937',
                backgroundColor: 'rgba(31, 41, 55, 0.1)',
                tension: 0.1,
                fill: true,
                borderWidth: 3
            });
            
            charts.velocity = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dateLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Tasks Completed Per Day'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Completion Date'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    }
                }
            });
        }

        function createVelocityComparisonChart() {
            const ctx = document.getElementById('velocityComparisonChart').getContext('2d');
            
            // Get all unique capture dates and sort them, filtering out 'no data'
            const captureDates = [...new Set(filteredData
                .filter(row => row.state !== 'no data')
                .map(row => row.capture_date)
            )].sort();
            
            if (captureDates.length === 0) {
                charts.velocityComparison = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: ['No Data'],
                        datasets: [{
                            label: 'No data available',
                            data: [0],
                            borderColor: '#9ca3af',
                            backgroundColor: 'rgba(156, 163, 175, 0.1)'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false
                    }
                });
                return;
            }
            
            // Track transitions for each date
            const startTransitions = {}; // not started -> in progress
            const completionTransitions = {}; // in progress -> complete
            
            // Initialize date tracking
            captureDates.forEach(date => {
                startTransitions[date] = 0;
                completionTransitions[date] = 0;
            });
            
            // Group data by location and trade to track transitions - skip 'no data' entries
            const taskStates = {};
            
            filteredData.filter(row => row.state !== 'no data').forEach(row => {
                const taskKey = `${row.location}_${row.trade}`;
                if (!taskStates[taskKey]) {
                    taskStates[taskKey] = [];
                }
                taskStates[taskKey].push({
                    date: row.capture_date,
                    state: row.state
                });
            });
            
            // Sort each task's states by date and detect transitions
            Object.values(taskStates).forEach(taskHistory => {
                taskHistory.sort((a, b) => a.date.localeCompare(b.date));
                
                for (let i = 1; i < taskHistory.length; i++) {
                    const prev = taskHistory[i - 1];
                    const curr = taskHistory[i];
                    
                    // Detect not started -> in progress transition
                    if (prev.state === 'not started' && curr.state === 'in progress') {
                        startTransitions[curr.date]++;
                    }
                    
                    // Detect in progress -> complete transition
                    if (prev.state === 'in progress' && curr.state === 'complete') {
                        completionTransitions[curr.date]++;
                    }
                }
            });
            
            // Format dates for display
            const dateLabels = captureDates.map(date => {
                const parts = date.split('/');
                if (parts.length === 3) {
                    return parts[1] + '/' + parts[2]; // MM/DD
                }
                return date;
            });
            
            const startData = captureDates.map(date => startTransitions[date]);
            const completeData = captureDates.map(date => completionTransitions[date]);
            
            charts.velocityComparison = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dateLabels,
                    datasets: [
                        {
                            label: 'Started (Not Started → In Progress)',
                            data: startData,
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            tension: 0.1,
                            fill: false
                        },
                        {
                            label: 'Completed (In Progress → Complete)',
                            data: completeData,
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            tension: 0.1,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        },
                        y: {
                            display: true,
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Transitions'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return 'Date: ' + captureDates[context[0].dataIndex];
                                }
                            }
                        }
                    }
                }
            });
        }

        function createDistributionChart() {
            const ctx = document.getElementById('distributionChart').getContext('2d');
            const availableTrades = [...new Set(filteredData.map(row => row.trade))];
            const trades = getOrderedTrades(availableTrades);
            
            // Calculate real completion percentages for each trade
            const tradeData = trades.map(trade => {
                const tradeRows = filteredData.filter(row => row.trade === trade);
                const completed = tradeRows.filter(row => row.state === 'complete').length;
                const total = tradeRows.length;
                return total > 0 ? Math.round((completed / total) * 100) : 0;
            });
            
            charts.distribution = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: trades,
                    datasets: [{
                        data: tradeData,
                        backgroundColor: [
                            '#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#06b6d4', '#84cc16'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const trade = context.label;
                                    const percentage = context.raw;
                                    const tradeRows = filteredData.filter(row => row.trade === trade);
                                    const completed = tradeRows.filter(row => row.state === 'complete').length;
                                    const total = tradeRows.length;
                                    return `${trade}: ${percentage}% (${completed}/${total})`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function createPerformanceChart() {
            const ctx = document.getElementById('performanceChart').getContext('2d');
            
            const availableTrades = [...new Set(filteredData.map(row => row.trade))];
            const trades = getOrderedTrades(availableTrades);
            
            charts.performance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: trades,
                    datasets: [{
                        label: 'Completion %',
                        data: trades.map(trade => {
                            const uniqueTradeTasks = new Set(
                                filteredData
                                    .filter(row => row.trade === trade)
                                    .map(row => `${row.location}_${row.trade}`)
                            );
                            const uniqueCompletedTasks = new Set(
                                filteredData
                                    .filter(row => row.trade === trade && row.state === 'complete')
                                    .map(row => `${row.location}_${row.trade}`)
                            );
                            const total = uniqueTradeTasks.size;
                            const completed = uniqueCompletedTasks.size;
                            return total > 0 ? Math.round((completed / total) * 100) : 0;
                        }),
                        backgroundColor: '#3b82f6'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: '% Complete'
                            }
                        }
                    }
                }
            });
        }

        function updateCharts() {
            // Destroy existing charts and recreate them with filtered data
            if (charts.progress) {
                charts.progress.destroy();
            }
            if (charts.velocity) {
                charts.velocity.destroy();
            }
            if (charts.distribution) {
                charts.distribution.destroy();
            }
            if (charts.performance) {
                charts.performance.destroy();
            }
            
            // Recreate all charts with filtered data
            createCharts();
        }

        // Analyze real data for anomalies
        function analyzeAnomalies(data) {
            // Reset all counts
            anomalyTypes.forEach(anomaly => anomaly.count = 0);
            
            // 1. Stalled Trades: Tasks in-progress for extended periods without completion
            const abandonmentCount = detectAbandonedTrades(data);
            anomalyTypes.find(a => a.id === 'abandonment').count = abandonmentCount;
            
            // 2. Stacked Trades: Locations with multiple trades stuck
            const starvationCount = detectStarvation(data);
            anomalyTypes.find(a => a.id === 'starvation').count = starvationCount;
            
            // 3. Burst Start: Unusual concentration of trade starts
            const burstCount = detectBurstStart(data);
            anomalyTypes.find(a => a.id === 'burst_start').count = burstCount;
            
            // 4. Swiss Cheese Flow: Random gaps in completion patterns
            const swissCheeseCount = detectSwissCheese(data);
            anomalyTypes.find(a => a.id === 'swiss_cheese').count = swissCheeseCount;
            
            // 5. Trade Blockage: Conflicting trades in same location
            const blockageCount = detectTradeBlockage(data);
            anomalyTypes.find(a => a.id === 'blockage').count = blockageCount;
            
            // 6. Premature Start: Trades starting before prerequisites
            const prematureCount = detectPrematureStart(data);
            anomalyTypes.find(a => a.id === 'premature_start').count = prematureCount;
        }

        // Detection algorithms for each anomaly type
        function detectAbandonedTrades(data) {
            const now = new Date();
            
            // Find unique location-trade combinations that have been in-progress for >14 days
            const inProgressTrades = data.filter(row => row.state === 'in progress' || row.state === 'in-progress');
            
            const abandonedTasks = new Set();
            inProgressTrades.forEach(row => {
                if (row.capture_date) {
                    const captureDate = new Date(row.capture_date);
                    const daysDiff = (now - captureDate) / (1000 * 60 * 60 * 24);
                    
                    // Count unique tasks stalled for more than 14 days
                    if (daysDiff > 14) {
                        abandonedTasks.add(`${row.location}_${row.trade}`);
                    }
                }
            });
            
            return abandonedTasks.size;
        }

        function detectStarvation(data) {
            // Find locations where multiple trades compete on individual days
            let starvationCount = 0;
            const captureDates = [...new Set(data.map(row => row.capture_date).filter(Boolean))];
            
            captureDates.forEach(date => {
                const dayData = data.filter(row => row.capture_date === date && (row.state === 'in progress' || row.state === 'in-progress'));
                const locationGroups = {};
                
                dayData.forEach(row => {
                    if (!locationGroups[row.location]) {
                        locationGroups[row.location] = [];
                    }
                    locationGroups[row.location].push(row);
                });
                
                // Count instances where multiple unique trades compete on the same day
                Object.values(locationGroups).forEach(trades => {
                    const uniqueTrades = [...new Set(trades.map(t => t.trade))];
                    if (uniqueTrades.length >= 2) {
                        starvationCount++;
                    }
                });
            });
            
            return starvationCount;
        }

        function detectBurstStart(data) {
            // Look for unusual clustering of trade starts
            const startDates = {};
            
            data.forEach(row => {
                if (row.capture_date) {
                    const date = row.capture_date;
                    if (!startDates[date]) {
                        startDates[date] = 0;
                    }
                    startDates[date]++;
                }
            });
            
            // Find dates with unusually high activity (>20 starts)
            return Object.values(startDates).filter(count => count > 20).length;
        }

        function detectSwissCheese(data) {
            // Find random gaps in otherwise completed areas using unique tasks
            const completedByLocation = {};
            const locationTasks = {};
            
            // First collect unique tasks per location
            data.forEach(row => {
                if (!locationTasks[row.location]) {
                    locationTasks[row.location] = {
                        allTasks: new Set(),
                        completedTasks: new Set()
                    };
                }
                locationTasks[row.location].allTasks.add(`${row.location}_${row.trade}`);
                if (row.state === 'complete') {
                    locationTasks[row.location].completedTasks.add(`${row.location}_${row.trade}`);
                }
            });
            
            // Convert to completion stats
            Object.keys(locationTasks).forEach(location => {
                completedByLocation[location] = {
                    total: locationTasks[location].allTasks.size,
                    completed: locationTasks[location].completedTasks.size
                };
            });
            
            // Find locations that are completely empty (0% complete) surrounded by completed areas
            const locations = Object.keys(completedByLocation).sort();
            let gapCount = 0;
            
            for (let i = 1; i < locations.length - 1; i++) {
                const current = completedByLocation[locations[i]];
                const prev = completedByLocation[locations[i-1]];
                const next = completedByLocation[locations[i+1]];
                
                // If current is 0% complete but neighbors are >80% complete
                if (current.completed === 0 && 
                    prev.completed / prev.total > 0.8 && 
                    next.completed / next.total > 0.8) {
                    gapCount++;
                }
            }
            
            return gapCount;
        }

        function detectVerticalLag(data) {
            // Check if upper levels/floors are behind lower levels using unique tasks
            const levelGroups = {};
            const levelTasks = {};
            
            // First collect unique tasks per level
            data.forEach(row => {
                const level = row.level || row.floor || '1';
                if (!levelTasks[level]) {
                    levelTasks[level] = {
                        allTasks: new Set(),
                        completedTasks: new Set()
                    };
                }
                levelTasks[level].allTasks.add(`${row.location}_${row.trade}`);
                if (row.state === 'complete') {
                    levelTasks[level].completedTasks.add(`${row.location}_${row.trade}`);
                }
            });
            
            // Convert to completion stats
            Object.keys(levelTasks).forEach(level => {
                levelGroups[level] = {
                    total: levelTasks[level].allTasks.size,
                    completed: levelTasks[level].completedTasks.size
                };
            });
            
            // Check if higher numbered levels have lower completion rates
            const levels = Object.keys(levelGroups).sort((a, b) => parseInt(a) - parseInt(b));
            let lagCount = 0;
            
            for (let i = 1; i < levels.length; i++) {
                const currentLevel = levelGroups[levels[i]];
                const prevLevel = levelGroups[levels[i-1]];
                
                const currentRate = currentLevel.completed / currentLevel.total;
                const prevRate = prevLevel.completed / prevLevel.total;
                
                // If current level is significantly behind previous level
                if (prevRate - currentRate > 0.2) {
                    lagCount++;
                }
            }
            
            return lagCount;
        }

        function detectOrphanLocations(data) {
            // Find isolated incomplete locations using unique tasks
            const locationCompletion = {};
            const locationTasks = {};
            
            // First collect unique tasks per location
            data.forEach(row => {
                if (!locationTasks[row.location]) {
                    locationTasks[row.location] = {
                        allTasks: new Set(),
                        completedTasks: new Set()
                    };
                }
                locationTasks[row.location].allTasks.add(`${row.location}_${row.trade}`);
                if (row.state === 'complete') {
                    locationTasks[row.location].completedTasks.add(`${row.location}_${row.trade}`);
                }
            });
            
            // Convert to completion stats
            Object.keys(locationTasks).forEach(location => {
                locationCompletion[location] = {
                    total: locationTasks[location].allTasks.size,
                    completed: locationTasks[location].completedTasks.size
                };
            });
            
            // Count locations with very low completion rates (<10%)
            return Object.values(locationCompletion).filter(loc => {
                const rate = loc.completed / loc.total;
                return rate < 0.1 && loc.total > 0;
            }).length;
        }

        function detectTradeBlockage(data) {
            // Find locations where conflicting trades are both in-progress
            const locationTrades = {};
            
            data.filter(row => row.state === 'in progress' || row.state === 'in-progress').forEach(row => {
                if (!locationTrades[row.location]) {
                    locationTrades[row.location] = new Set();
                }
                locationTrades[row.location].add(row.trade);
            });
            
            // Define conflicting trade pairs (from memory)
            const conflicts = [
                ['Overhead Duct Rough In', 'Wall Prime Paint'],
                ['Overhead Plumbing', 'Wall Drywall Finish'],
                ['Overhead Duct Insulation', 'Wall Prime Paint'],
                ['Wall Drywall', 'Overhead Duct Rough In']
            ];
            
            let blockageCount = 0;
            Object.values(locationTrades).forEach(trades => {
                const uniqueTrades = [...trades]; // trades is already a Set
                for (const [trade1, trade2] of conflicts) {
                    if (uniqueTrades.includes(trade1) && uniqueTrades.includes(trade2)) {
                        blockageCount++;
                        break; // Count each location only once
                    }
                }
            });
            
            return blockageCount;
        }

        function detectPrematureStart(data) {
            // Find trades that started before their prerequisites were complete
            // Correct trade sequence based on project milestones
            const tradeSequence = {
                'In Wall Insulation': [], // First trade, no prerequisites
                'Wall Drywall': ['In Wall Insulation'],
                'Overhead Plumbing': ['Wall Drywall'],
                'Overhead Duct Rough In': ['Overhead Plumbing'],
                'Overhead Duct Insulation': ['Overhead Duct Rough In'],
                'Wall Drywall Finish': ['Overhead Duct Insulation'],
                'Wall Prime Paint': ['Wall Drywall Finish']
            };
            
            let violationCount = 0;
            
            Object.keys(tradeSequence).forEach(trade => {
                const prerequisites = tradeSequence[trade];
                
                // Find locations where this trade is in-progress or complete
                const tradeLocations = data.filter(row => 
                    row.trade === trade && (row.state === 'in progress' || row.state === 'in-progress' || row.state === 'complete')
                ).map(row => row.location);
                
                // For each location, check if prerequisites are complete
                tradeLocations.forEach(location => {
                    const hasAllPrereqs = prerequisites.every(prereq => {
                        return data.some(row => 
                            row.location === location && 
                            row.trade === prereq && 
                            row.state === 'complete'
                        );
                    });
                    
                    if (!hasAllPrereqs) {
                        violationCount++;
                    }
                });
            });
            
            return violationCount;
        }

        // Render anomaly tiles
        function renderAnomalyTiles() {
            const container = document.getElementById('anomaly-tiles');
            container.innerHTML = '';

            anomalyTypes.forEach(anomaly => {
                const tile = document.createElement('div');
                tile.className = 'anomaly-tile p-4 rounded-lg border border-gray-200 bg-white cursor-pointer hover:shadow-lg transition-shadow';
                tile.onclick = () => showAnomalyChart(anomaly);
                
                tile.innerHTML = `
                    <div class="flex items-center justify-between mb-2">
                        <div class="flex items-center gap-2">
                            <svg class="w-5 h-5" style="color: ${anomaly.color}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                            </svg>
                            <h4 class="font-semibold text-gray-900 text-sm">${anomaly.name}</h4>
                        </div>
                        <span class="px-2 py-1 text-xs font-medium rounded-full text-white" style="background-color: ${anomaly.color}">
                            ${anomaly.count}
                        </span>
                    </div>
                    <p class="text-xs text-gray-600 mb-2">${anomaly.category}</p>
                    <div class="text-xs px-2 py-1 rounded inline-block ${
                        anomaly.severity === 'high' ? 'bg-red-100 text-red-800' :
                        anomaly.severity === 'medium' ? 'bg-orange-100 text-orange-800' :
                        'bg-yellow-100 text-yellow-800'
                    }">
                        ${anomaly.severity.toUpperCase()} PRIORITY
                    </div>
                `;
                
                container.appendChild(tile);
            });


        }



        // Global variable to track anomaly chart
        let anomalyChart = null;

        // Show anomaly-specific chart
        function showAnomalyChart(anomaly) {
            const container = document.getElementById('anomaly-chart-container');
            const title = document.getElementById('anomaly-chart-title');
            
            title.textContent = `${anomaly.name} Analysis`;
            container.classList.remove('hidden');
            
            // Destroy existing chart if it exists
            if (anomalyChart) {
                anomalyChart.destroy();
            }
            
            // Create appropriate chart based on anomaly type
            createAnomalyVisualization(anomaly);
        }

        // Close anomaly chart
        function closeAnomalyChart() {
            const container = document.getElementById('anomaly-chart-container');
            container.classList.add('hidden');
            
            if (anomalyChart) {
                anomalyChart.destroy();
                anomalyChart = null;
            }
        }

        // Create visualization based on anomaly type
        function createAnomalyVisualization(anomaly) {
            const ctx = document.getElementById('anomalyChart').getContext('2d');
            
            switch(anomaly.id) {
                case 'abandonment':
                    createAbandonmentChart(ctx, anomaly);
                    break;
                case 'starvation':
                    createStarvationChart(ctx, anomaly);
                    break;
                case 'burst_start':
                    createBurstStartChart(ctx, anomaly);
                    break;
                case 'swiss_cheese':
                    createSwissCheeseChart(ctx, anomaly);
                    break;
                case 'blockage':
                    createBlockageChart(ctx, anomaly);
                    break;
                case 'premature_start':
                    createPrematureStartChart(ctx, anomaly);
                    break;
                default:
                    createGenericAnomalyChart(ctx, anomaly);
            }
        }

        // Helper functions to get real data for charts
        function getAbandonedTradesData() {
            const now = new Date();
            
            // Get trades that are in-progress and stalled >14 days
            const abandonedTrades = filteredData.filter(row => {
                if (row.state !== 'in progress' && row.state !== 'in-progress') return false;
                
                // Calculate days stalled from capture date
                if (row.capture_date) {
                    const captureDate = new Date(row.capture_date);
                    const daysDiff = (now - captureDate) / (1000 * 60 * 60 * 24);
                    return daysDiff > 14;
                }
                
                return false;
            });
            
            // Group by location and collect unique task details
            const locationData = {};
            const uniqueTasks = new Map();
            
            // First, create unique task entries with their stall times
            abandonedTrades.forEach(row => {
                const taskKey = `${row.location}_${row.trade}`;
                const captureDate = new Date(row.capture_date);
                const daysStalled = Math.floor((now - captureDate) / (1000 * 60 * 60 * 24));
                
                if (!uniqueTasks.has(taskKey)) {
                    uniqueTasks.set(taskKey, {
                        location: row.location,
                        trade: row.trade,
                        daysStalled: daysStalled
                    });
                } else {
                    // Keep the maximum stall time for this unique task
                    const existing = uniqueTasks.get(taskKey);
                    if (daysStalled > existing.daysStalled) {
                        existing.daysStalled = daysStalled;
                    }
                }
            });
            
            // Now group unique tasks by location
            uniqueTasks.forEach(task => {
                const location = task.location;
                
                if (!locationData[location]) {
                    locationData[location] = {
                        totalStalled: 0,
                        trades: {}
                    };
                }
                
                if (!locationData[location].trades[task.trade]) {
                    locationData[location].trades[task.trade] = {
                        count: 0,
                        maxDays: 0,
                        minDays: Infinity
                    };
                }
                
                locationData[location].totalStalled++;
                locationData[location].trades[task.trade].count++;
                locationData[location].trades[task.trade].maxDays = Math.max(
                    locationData[location].trades[task.trade].maxDays, 
                    task.daysStalled
                );
                locationData[location].trades[task.trade].minDays = Math.min(
                    locationData[location].trades[task.trade].minDays, 
                    task.daysStalled
                );
            });
            
            return locationData;
        }

        function getStarvationData() {
            // Analyze starvation by individual capture days
            const starvationByDay = {};
            
            // Group data by capture date and location
            const captureDates = [...new Set(filteredData.map(row => row.capture_date).filter(Boolean))];
            
            captureDates.forEach(date => {
                const dayData = filteredData.filter(row => row.capture_date === date);
                const locationGroups = {};
                
                // Group by location for this specific day
                dayData.filter(row => row.state === 'in progress' || row.state === 'in-progress').forEach(row => {
                    if (!locationGroups[row.location]) {
                        locationGroups[row.location] = [];
                    }
                    locationGroups[row.location].push(row);
                });
                
                // Find locations with multiple competing trades on this day
                Object.entries(locationGroups).forEach(([location, trades]) => {
                    const uniqueTrades = [...new Set(trades.map(t => t.trade))];
                    if (uniqueTrades.length >= 2) {
                        const key = `${location} (${date})`;
                        if (!starvationByDay[key]) {
                            starvationByDay[key] = {
                                count: uniqueTrades.length,
                                trades: uniqueTrades,
                                date: date,
                                location: location
                            };
                        }
                    }
                });
            });
            
            return starvationByDay;
        }

        function getSwissCheeseData() {
            // Find locations with gaps in completion patterns using unique tasks
            const locationCompletion = {};
            
            // Calculate completion rate for each location using unique tasks
            const locationTasks = {};
            filteredData.forEach(row => {
                if (!locationTasks[row.location]) {
                    locationTasks[row.location] = {
                        allTasks: new Set(),
                        completedTasks: new Set()
                    };
                }
                locationTasks[row.location].allTasks.add(`${row.location}_${row.trade}`);
                if (row.state === 'complete') {
                    locationTasks[row.location].completedTasks.add(`${row.location}_${row.trade}`);
                }
            });
            
            // Convert to completion stats
            Object.keys(locationTasks).forEach(location => {
                locationCompletion[location] = {
                    total: locationTasks[location].allTasks.size,
                    completed: locationTasks[location].completedTasks.size
                };
            });
            
            // Calculate completion percentages and identify gaps
            const completionData = {};
            Object.entries(locationCompletion).forEach(([location, data]) => {
                const percentage = data.total > 0 ? Math.round((data.completed / data.total) * 100) : 0;
                completionData[location] = {
                    percentage: percentage,
                    isGap: percentage === 0 && data.total > 0, // Has tasks but 0% complete
                    total: data.total,
                    completed: data.completed
                };
            });
            
            return completionData;
        }

        function getVerticalLagData() {
            // Analyze completion rates by level
            const levelGroups = {};
            filteredData.forEach(row => {
                const level = row.level || row.floor || '1';
                if (!levelGroups[level]) {
                    levelGroups[level] = { total: 0, completed: 0 };
                }
                levelGroups[level].total++;
                if (row.state === 'complete') {
                    levelGroups[level].completed++;
                }
            });
            
            // Calculate completion rates
            return Object.entries(levelGroups).reduce((acc, [level, data]) => {
                acc[level] = (data.completed / data.total * 100).toFixed(1);
                return acc;
            }, {});
        }

        // Stalled Trades - Bar chart showing locations with stalled tasks >14 days
        function createAbandonmentChart(ctx, anomaly) {
            // Get real abandoned trades data
            const locationData = getAbandonedTradesData();
            const locations = Object.keys(locationData);
            const data = locations.map(location => locationData[location].totalStalled);
            
            // If no data, show placeholder
            if (locations.length === 0) {
                locations.push('No stalled locations found');
                data.push(0);
            }
            
            anomalyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: locations,
                    datasets: [{
                        label: 'Stalled Tasks',
                        data: data,
                        backgroundColor: anomaly.color + '80',
                        borderColor: anomaly.color,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Stalled Tasks'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Locations'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Stalled Trades by Location - Tasks stalled >14 days'
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return `Location: ${context[0].label}`;
                                },
                                label: function(context) {
                                    const location = context.label;
                                    if (!locationData[location]) return 'No data';
                                    
                                    const data = locationData[location];
                                    return `Total Stalled Tasks: ${data.totalStalled}`;
                                },
                                afterLabel: function(context) {
                                    const location = context.label;
                                    if (!locationData[location]) return [];
                                    
                                    const data = locationData[location];
                                    const details = [];
                                    
                                    details.push(''); // Empty line for spacing
                                    details.push('Breakdown by Trade:');
                                    
                                    Object.entries(data.trades).forEach(([trade, tradeInfo]) => {
                                        const daysRange = tradeInfo.minDays === tradeInfo.maxDays 
                                            ? `${tradeInfo.maxDays} days`
                                            : `${tradeInfo.minDays}-${tradeInfo.maxDays} days`;
                                        
                                        details.push(`• ${trade}: ${tradeInfo.count} task${tradeInfo.count > 1 ? 's' : ''} (stalled ${daysRange})`);
                                    });
                                    
                                    return details;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Stacked Trades - Bar chart showing locations with multiple competing trades by day
        function createStarvationChart(ctx, anomaly) {
            const starvationData = getStarvationData();
            const labels = Object.keys(starvationData);
            const data = labels.map(key => starvationData[key].count);
            
            // If no data, show placeholder
            if (labels.length === 0) {
                labels.push('No resource conflicts found');
                data.push(0);
            }
            
            anomalyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Competing Trades',
                        data: data,
                        backgroundColor: anomaly.color + '80',
                        borderColor: anomaly.color,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Competing Trades'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Location (Date)'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Stacked Trades - Daily analysis of competing trades by location'
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return context[0].label;
                                },
                                label: function(context) {
                                    const key = context.label;
                                    const data = starvationData[key];
                                    if (!data) return 'No data';
                                    return `Competing Trades: ${data.count}`;
                                },
                                afterLabel: function(context) {
                                    const key = context.label;
                                    const data = starvationData[key];
                                    if (!data) return [];
                                    
                                    const details = [];
                                    details.push(''); // Empty line
                                    details.push('Competing Trades:');
                                    data.trades.forEach(trade => {
                                        details.push(`• ${trade}`);
                                    });
                                    details.push(''); // Empty line
                                    details.push('Multiple in-progress trades competing for the same location on this day');
                                    
                                    return details;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Burst Start - Line chart showing sudden activity spikes
        function createBurstStartChart(ctx, anomaly) {
            const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
            const normalActivity = [8, 10, 12, 9, 11, 3, 2];
            const burstActivity = [8, 10, 35, 9, 11, 3, 2]; // Spike on Wednesday
            
            anomalyChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: days,
                    datasets: [{
                        label: 'Normal Activity',
                        data: normalActivity,
                        borderColor: '#6b7280',
                        backgroundColor: '#6b728020',
                        borderWidth: 2
                    }, {
                        label: 'Burst Activity',
                        data: burstActivity,
                        borderColor: anomaly.color,
                        backgroundColor: anomaly.color + '30',
                        borderWidth: 3,
                        pointBackgroundColor: anomaly.color,
                        pointRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Tasks Started'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Burst Start Pattern - Sudden large volume of work starting'
                        }
                    }
                }
            });
        }

        // Swiss Cheese Flow - Bar chart showing gaps in completion patterns
        function createSwissCheeseChart(ctx, anomaly) {
            const swissCheeseData = getSwissCheeseData();
            const locations = Object.keys(swissCheeseData);
            const completionPercentages = locations.map(loc => swissCheeseData[loc].percentage);
            
            // If no data, show placeholder
            if (locations.length === 0) {
                locations.push('No completion gaps found');
                completionPercentages.push(0);
            }
            
            anomalyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: locations,
                    datasets: [{
                        label: 'Completion %',
                        data: completionPercentages,
                        backgroundColor: completionPercentages.map((val, idx) => {
                            if (locations.length === 1 && completionPercentages[0] === 0) return anomaly.color;
                            return swissCheeseData[locations[idx]]?.isGap ? '#ef4444' : anomaly.color + '80';
                        }),
                        borderColor: completionPercentages.map((val, idx) => {
                            if (locations.length === 1 && completionPercentages[0] === 0) return anomaly.color;
                            return swissCheeseData[locations[idx]]?.isGap ? '#dc2626' : anomaly.color;
                        }),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Completion Percentage'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Swiss Cheese Flow - Completion gaps in project locations'
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return `Location: ${context[0].label}`;
                                },
                                label: function(context) {
                                    const location = context.label;
                                    const data = swissCheeseData[location];
                                    if (!data) return `Completion: ${context.parsed.y}%`;
                                    
                                    return `Completion: ${data.percentage}% (${data.completed}/${data.total} tasks)`;
                                },
                                afterLabel: function(context) {
                                    const location = context.label;
                                    const data = swissCheeseData[location];
                                    if (!data) return [];
                                    
                                    if (data.isGap) {
                                        return ['', 'This location has tasks but 0% completion - a potential gap!'];
                                    } else if (data.percentage < 50) {
                                        return ['', 'Low completion rate may indicate workflow issues'];
                                    }
                                    return [];
                                }
                            }
                        }
                    }
                }
            });
        }

        // Vertical Lag - Bar chart showing floor-by-floor delays
        function createVerticalLagChart(ctx, anomaly) {
            const verticalData = getVerticalLagData();
            const levels = Object.keys(verticalData).sort((a, b) => parseInt(a) - parseInt(b));
            const completionRates = levels.map(level => parseFloat(verticalData[level]));
            
            anomalyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: levels.map(level => `Level ${level}`),
                    datasets: [{
                        label: 'Completion %',
                        data: completionRates,
                        backgroundColor: levels.map((_, i) => `hsl(${120 - (i * 20)}, 70%, 50%)`), // Green to red gradient
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Completion Percentage'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Vertical Lag - Upper floors lagging behind lower floors'
                        }
                    }
                }
            });
        }

        // Generic chart for remaining anomaly types
        function createOrphanLocationChart(ctx, anomaly) {
            createGenericAnomalyChart(ctx, anomaly, 'Orphan Location - Isolated incomplete areas');
        }

        function createBurstStartChart(ctx, anomaly) {
            // Burst Start: Analyze task starts by week with smoothed average and spikes
            const weeklyData = getBurstStartData();
            
            anomalyChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: weeklyData.labels,
                    datasets: [
                        {
                            label: 'Actual Task Starts',
                            data: weeklyData.actualData,
                            borderColor: anomaly.color,
                            backgroundColor: 'transparent',
                            borderWidth: 2,
                            tension: 0,
                            pointRadius: 4,
                            pointBackgroundColor: anomaly.color
                        },
                        {
                            label: 'Smoothed Average',
                            data: weeklyData.smoothedData,
                            borderColor: '#64748b',
                            backgroundColor: 'rgba(100, 116, 139, 0.1)',
                            borderWidth: 3,
                            tension: 0.4,
                            pointRadius: 0,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Task Starts'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Week'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Burst Start Analysis - Weekly Task Starts with Smoothed Trend'
                        },
                        legend: {
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                afterBody: function(context) {
                                    const dataIndex = context[0].dataIndex;
                                    const actualValue = weeklyData.actualData[dataIndex];
                                    const smoothedValue = weeklyData.smoothedData[dataIndex];
                                    const spike = actualValue > smoothedValue * 1.5;
                                    
                                    if (spike) {
                                        return ['', '⚠️ BURST ACTIVITY DETECTED', `Spike: ${Math.round(((actualValue - smoothedValue) / smoothedValue) * 100)}% above average`];
                                    }
                                    return '';
                                }
                            }
                        }
                    }
                }
            });
        }

        function createBlockageChart(ctx, anomaly) {
            // Trade Blockage: List zones and blocked trades
            const blockageData = getTradeBlockageData();
            
            if (blockageData.zones.length === 0) {
                // Show empty state
                anomalyChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['No Blockages'],
                        datasets: [{
                            label: 'No trade blockages detected',
                            data: [0],
                            backgroundColor: '#e5e7eb',
                            borderColor: '#e5e7eb',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Trade Blockage Analysis - No blockages detected'
                            }
                        }
                    }
                });
                return;
            }
            
            anomalyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: blockageData.zones,
                    datasets: [{
                        label: 'Blocked Trades Count',
                        data: blockageData.counts,
                        backgroundColor: anomaly.color,
                        borderColor: anomaly.color,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Blocked Trades'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Zone/Section'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Trade Blockage Analysis - Blocked Trades by Zone'
                        },
                        tooltip: {
                            callbacks: {
                                afterBody: function(context) {
                                    const zoneIndex = context[0].dataIndex;
                                    const zoneName = blockageData.zones[zoneIndex];
                                    const trades = blockageData.details[zoneName];
                                    
                                    if (trades && trades.length > 0) {
                                        const orderedTrades = getOrderedTrades(trades);
                                        return ['', 'Blocked Trades:', ...orderedTrades.map(trade => `• ${trade}`)];
                                    }
                                    return '';
                                }
                            }
                        }
                    }
                }
            });
        }

        function createPrematureStartChart(ctx, anomaly) {
            // Premature Start: Analyze premature starts by week instead of daily
            const weeklyData = getWeeklyAnomalyData('premature');
            
            anomalyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: weeklyData.labels,
                    datasets: [{
                        label: 'Premature Starts per Week',
                        data: weeklyData.data,
                        backgroundColor: anomaly.color,
                        borderColor: anomaly.color,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Premature Starts'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Week'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Premature Start Analysis - Weekly Premature Starts'
                        }
                    }
                }
            });
        }

        function getTradeBlockageData() {
            // Analyze trade blockages by zone/section
            const zoneBlockages = {};
            
            // Get all sections/zones from the data
            const sections = [...new Set(filteredData.map(row => row.section).filter(Boolean))];
            
            sections.forEach(section => {
                // Find trades in this section that are stuck in 'in progress' for extended periods
                const sectionData = filteredData.filter(row => row.section === section);
                const inProgressTrades = {};
                
                // Group by location and trade to find long-running in-progress tasks
                sectionData.forEach(row => {
                    if (row.state === 'in progress' || row.state === 'in-progress') {
                        const taskKey = `${row.location}_${row.trade}`;
                        if (!inProgressTrades[taskKey]) {
                            inProgressTrades[taskKey] = {
                                trade: row.trade,
                                location: row.location,
                                dates: []
                            };
                        }
                        inProgressTrades[taskKey].dates.push(row.capture_date);
                    }
                });
                
                // Find trades that have been in progress for multiple capture dates (indicating blockage)
                const blockedTrades = [];
                Object.values(inProgressTrades).forEach(task => {
                    if (task.dates.length >= 3) { // In progress for 3+ capture dates = blocked
                        blockedTrades.push(task.trade);
                    }
                });
                
                // Remove duplicates
                const uniqueBlockedTrades = [...new Set(blockedTrades)];
                
                if (uniqueBlockedTrades.length > 0) {
                    zoneBlockages[section] = uniqueBlockedTrades;
                }
            });
            
            // Convert to chart format
            const zones = Object.keys(zoneBlockages);
            const counts = zones.map(zone => zoneBlockages[zone].length);
            const details = zoneBlockages;
            
            return {
                zones: zones,
                counts: counts,
                details: details
            };
        }

        function getBurstStartData() {
            // Generate burst start data with smoothed average
            const weeks = [];
            const actualData = [];
            
            // Get unique capture dates and convert to weeks
            const captureDates = [...new Set(filteredData.map(row => row.capture_date).filter(Boolean))].sort();
            
            if (captureDates.length === 0) {
                console.log('No capture dates found for burst start analysis');
                return { 
                    labels: ['No Data'], 
                    actualData: [0], 
                    smoothedData: [0] 
                };
            }
            
            console.log('Burst Start Analysis Debug:');
            console.log('Total filtered data rows:', filteredData.length);
            console.log('Capture dates:', captureDates);
            
            // Check start_date field usage
            const withStartDates = filteredData.filter(row => row.start_date && row.start_date.trim() !== '');
            console.log('Rows with start_date:', withStartDates.length);
            
            // Check in-progress tasks
            const inProgressTasks = filteredData.filter(row => row.state === 'in progress' || row.state === 'in-progress');
            console.log('In-progress tasks:', inProgressTasks.length);
            
            // Group dates by week
            const weeklyGroups = {};
            captureDates.forEach(date => {
                const dateObj = new Date(date);
                const weekStart = new Date(dateObj);
                weekStart.setDate(dateObj.getDate() - dateObj.getDay()); // Start of week (Sunday)
                const weekKey = weekStart.toISOString().split('T')[0];
                
                if (!weeklyGroups[weekKey]) {
                    weeklyGroups[weekKey] = [];
                }
                weeklyGroups[weekKey].push(date);
            });
            
            // Generate weekly labels and actual start data
            const sortedWeeks = Object.keys(weeklyGroups).sort();
            sortedWeeks.forEach((weekStart, index) => {
                const weekLabel = `Week ${index + 1}`;
                weeks.push(weekLabel);
                
                // Count unique task starts for this week
                let weeklyStarts = 0;
                const weekDates = weeklyGroups[weekStart];
                
                // Simplified approach: Count any activity as potential starts
                weekDates.forEach(date => {
                    // Count tasks with start_date on this date
                    const directStarts = filteredData.filter(row => row.start_date === date && row.start_date.trim() !== '');
                    weeklyStarts += directStarts.length;
                    
                    // If no direct starts, count in-progress tasks as proxy for activity
                    if (directStarts.length === 0) {
                        const inProgressCount = filteredData.filter(row => 
                            row.capture_date === date && 
                            (row.state === 'in progress' || row.state === 'in-progress')
                        ).length;
                        
                        // Use a portion of in-progress tasks as estimated starts
                        weeklyStarts += Math.floor(inProgressCount / 10); // Estimate 10% are new starts
                    }
                });
                
                console.log(`Week ${index + 1}: ${weeklyStarts} starts for dates:`, weekDates);
                
                actualData.push(weeklyStarts);
            });
            
            // Calculate smoothed average using moving average
            const smoothedData = [];
            const windowSize = 3; // 3-week moving average
            
            for (let i = 0; i < actualData.length; i++) {
                const start = Math.max(0, i - Math.floor(windowSize / 2));
                const end = Math.min(actualData.length, i + Math.ceil(windowSize / 2));
                const window = actualData.slice(start, end);
                const average = window.reduce((sum, val) => sum + val, 0) / window.length;
                smoothedData.push(Math.round(average * 10) / 10); // Round to 1 decimal
            }
            
            return {
                labels: weeks,
                actualData: actualData,
                smoothedData: smoothedData
            };
        }

        function getWeeklyAnomalyData(type) {
            // Helper function to generate weekly data for anomaly charts
            const weeks = [];
            const data = [];
            
            // Get unique capture dates and convert to weeks
            const captureDates = [...new Set(filteredData.map(row => row.capture_date).filter(Boolean))].sort();
            
            if (captureDates.length === 0) {
                return { labels: ['No Data'], data: [0] };
            }
            
            // Group dates by week
            const weeklyGroups = {};
            captureDates.forEach(date => {
                const dateObj = new Date(date);
                // Get week number
                const weekStart = new Date(dateObj);
                weekStart.setDate(dateObj.getDate() - dateObj.getDay()); // Start of week (Sunday)
                const weekKey = weekStart.toISOString().split('T')[0];
                
                if (!weeklyGroups[weekKey]) {
                    weeklyGroups[weekKey] = [];
                }
                weeklyGroups[weekKey].push(date);
            });
            
            // Generate weekly labels and data
            const sortedWeeks = Object.keys(weeklyGroups).sort();
            sortedWeeks.forEach((weekStart, index) => {
                const weekEnd = new Date(weekStart);
                weekEnd.setDate(weekEnd.getDate() + 6);
                
                const weekLabel = `Week ${index + 1}`;
                weeks.push(weekLabel);
                
                // Calculate anomaly count for this week based on type
                let weeklyCount = 0;
                const weekDates = weeklyGroups[weekStart];
                
                switch(type) {
                    case 'start':
                        // Count task starts in this week
                        weekDates.forEach(date => {
                            const starts = filteredData.filter(row => 
                                row.start_date === date || 
                                (row.capture_date === date && row.state === 'in progress')
                            );
                            weeklyCount += starts.length;
                        });
                        break;
                    case 'blockage':
                        // Count trade blockages in this week
                        weekDates.forEach(date => {
                            const blocked = filteredData.filter(row => 
                                row.capture_date === date && 
                                (row.state === 'in progress' || row.state === 'in-progress')
                            );
                            weeklyCount += Math.floor(blocked.length / 3); // Approximate blockage count
                        });
                        break;
                    case 'premature':
                        // Count premature starts in this week
                        weekDates.forEach(date => {
                            const premature = filteredData.filter(row => 
                                row.start_date === date && 
                                row.state === 'in progress'
                            );
                            weeklyCount += Math.floor(premature.length / 4); // Approximate premature count
                        });
                        break;
                    default:
                        weeklyCount = Math.floor(Math.random() * 10) + 1;
                }
                
                data.push(weeklyCount);
            });
            
            return { labels: weeks, data: data };
        }

        function createGenericAnomalyChart(ctx, anomaly, titleOverride = null) {
            const data = Array.from({length: 7}, () => Math.floor(Math.random() * 5) + 1);
            const labels = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
            
            anomalyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Occurrences',
                        data: data,
                        backgroundColor: anomaly.color,
                        borderColor: anomaly.color,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Incidents'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: titleOverride || `${anomaly.name} - Weekly occurrence pattern`
                        }
                    }
                }
            });
        }

        // Render insights based on real data
        function renderInsights() {
            const container = document.getElementById('insights-container');
            container.innerHTML = '';

            // Get insights from real data
            const insights = getInsightsFromData();

            insights.forEach(insight => {
                const insightCard = document.createElement('div');
                insightCard.className = `p-4 rounded-lg border-l-4 ${
                    insight.type === 'achievement' ? 'border-green-500 bg-green-50' :
                    insight.type === 'concern' ? 'border-red-500 bg-red-50' :
                    insight.type === 'opportunity' ? 'border-blue-500 bg-blue-50' :
                    'border-yellow-500 bg-yellow-50'
                }`;
                
                insightCard.innerHTML = `
                    <div class="flex items-start justify-between mb-2">
                        <h4 class="font-semibold text-gray-900">${insight.title}</h4>
                        <span class="px-2 py-1 text-xs font-medium rounded-full ${
                            insight.type === 'achievement' ? 'bg-green-100 text-green-800' :
                            insight.type === 'concern' ? 'bg-red-100 text-red-800' :
                            insight.type === 'opportunity' ? 'bg-blue-100 text-blue-800' :
                            'bg-yellow-100 text-yellow-800'
                        }">
                            ${insight.type}
                        </span>
                    </div>
                    <p class="text-sm text-gray-700 mb-3">${insight.description}</p>
                    <p class="text-xs font-medium text-gray-900">
                        <span class="text-gray-600">Action: </span>
                        ${insight.action}
                    </p>
                `;
                
                container.appendChild(insightCard);
            });
        }

        // Get insights from actual data
        function getInsightsFromData() {
            const insights = [];
            const trades = [...new Set(filteredData.map(row => row.trade))];
            
            // Find best performing trade using unique location-trade combinations
            const tradePerformance = trades.map(trade => {
                const uniqueTradeTasks = new Set(
                    filteredData
                        .filter(row => row.trade === trade)
                        .map(row => `${row.location}_${row.trade}`)
                );
                const uniqueCompletedTasks = new Set(
                    filteredData
                        .filter(row => row.trade === trade && row.state === 'complete')
                        .map(row => `${row.location}_${row.trade}`)
                );
                const total = uniqueTradeTasks.size;
                const completed = uniqueCompletedTasks.size;
                const rate = total > 0 ? (completed / total) * 100 : 0;
                return { trade, rate, completed, total };
            }).sort((a, b) => b.rate - a.rate);

            if (tradePerformance.length > 0) {
                const bestTrade = tradePerformance[0];
                if (bestTrade.rate > 50) {
                    insights.push({
                        type: 'achievement',
                        title: `${bestTrade.trade} Leading Progress`,
                        description: `Highest completion rate at ${bestTrade.rate.toFixed(1)}%, setting strong pace for project`,
                        action: 'Allocate excess capacity to support lagging trades'
                    });
                }

                const worstTrade = tradePerformance[tradePerformance.length - 1];
                if (worstTrade.rate < 30 && worstTrade.total > 0) {
                    insights.push({
                        type: 'concern',
                        title: `${worstTrade.trade} Low Completion`,
                        description: `Only ${worstTrade.rate.toFixed(1)}% complete, significantly lagging other trades`,
                        action: 'Increase crew allocation and investigate bottlenecks'
                    });
                }
            }

            // Check for level completion opportunities
            const levels = [...new Set(filteredData.map(row => row.level))];
            levels.forEach(level => {
                const levelData = filteredData.filter(row => row.level === level);
                const completed = levelData.filter(row => row.state === 'complete').length;
                const total = levelData.length;
                const rate = total > 0 ? (completed / total) * 100 : 0;
                
                if (rate > 75) {
                    insights.push({
                        type: 'opportunity',
                        title: `Level ${level} Nearing Completion`,
                        description: `${rate.toFixed(0)}% complete - opportunity to showcase progress to stakeholders`,
                        action: 'Schedule walkthrough with investors'
                    });
                }
            });

            // Add a risk insight about trade coordination
            if (insights.length < 4) {
                insights.push({
                    type: 'risk',
                    title: 'Trade Sequence Violations Increasing',
                    description: 'Multiple instances of premature starts detected this week',
                    action: 'Reinforce sequencing protocols with superintendents'
                });
            }

            // Add default insights if none were generated from data
            if (insights.length === 0) {
                insights.push(
                    {
                        type: 'achievement',
                        title: 'Data Analysis Ready',
                        description: 'Upload your construction CSV data to see real insights',
                        action: 'Upload CSV file to begin analysis'
                    },
                    {
                        type: 'opportunity',
                        title: 'Dashboard Configured',
                        description: 'System ready for construction project tracking',
                        action: 'Begin by uploading project data'
                    }
                );
            }

            return insights.slice(0, 4); // Return max 4 insights
        }

        // Render timeline based on real data
        function renderTimeline() {
            const container = document.getElementById('timeline-container');
            container.innerHTML = '';

            const milestones = getMilestonesFromData();

            milestones.forEach((milestone, index) => {
                const timelineItem = document.createElement('div');
                timelineItem.className = 'relative flex items-start mb-6';
                
                timelineItem.innerHTML = `
                    <!-- Timeline dot -->
                    <div class="relative z-10 w-12 h-12 rounded-full flex items-center justify-center ${
                        milestone.status === 'complete' ? 'bg-blue-600' :
                        milestone.status === 'in-progress' ? 'bg-blue-400' : 'bg-blue-300'
                    }">
                        ${milestone.status === 'complete' ? 
                            '<svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>' :
                            `<span class="text-white font-bold text-sm">${index + 1}</span>`
                        }
                    </div>
                    
                    <!-- Milestone content -->
                    <div class="ml-6 flex-1">
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <div class="flex items-center justify-between mb-2">
                                <h4 class="font-semibold text-gray-900">${milestone.name}</h4>
                                <span class="px-3 py-1 text-xs font-medium rounded-full ${
                                    milestone.status === 'complete' ? 'bg-blue-100 text-blue-800' :
                                    milestone.status === 'in-progress' ? 'bg-blue-50 text-blue-700' :
                                    'bg-blue-50 text-blue-600'
                                }">
                                    ${milestone.status}
                                </span>
                            </div>
                            <p class="text-sm text-gray-600 mb-3">
                                Status: ${milestone.description}
                            </p>
                            
                            <!-- Progress bar -->
                            <div class="flex items-center gap-3">
                                <div class="flex-1 bg-gray-200 rounded-full h-3">
                                    <div 
                                        class="h-3 rounded-full transition-all duration-500 ${
                                            milestone.status === 'complete' ? 'bg-blue-600' :
                                            milestone.status === 'in-progress' ? 'bg-blue-400' : 'bg-blue-300'
                                        }"
                                        style="width: ${milestone.progress}%"
                                    ></div>
                                </div>
                                <span class="text-sm font-medium text-gray-900 w-12">
                                    ${milestone.progress}%
                                </span>
                            </div>
                        </div>
                    </div>
                `;
                
                container.appendChild(timelineItem);
            });
        }

        // Get milestones from actual data
        function getMilestonesFromData() {
            const availableTrades = [...new Set(filteredData.map(row => row.trade))];
            const allTrades = getOrderedTrades(availableTrades);
            

            
            const milestones = [];

            // Create milestones based on trade completion rates using final states - show ALL trades
            allTrades.forEach(trade => {
                // Get final state for each unique task for this trade, ignoring 'no data' entries
                const taskStates = {};
                filteredData.filter(row => row.trade === trade && row.state !== 'no data').forEach(row => {
                    const taskKey = `${row.location}_${row.trade}`;
                    const captureDate = row.capture_date;
                    
                    if (!taskStates[taskKey] || captureDate > taskStates[taskKey].date) {
                        taskStates[taskKey] = {
                            state: row.state,
                            date: captureDate
                        };
                    }
                });
                
                const allTaskKeys = Object.keys(taskStates);
                const total = allTaskKeys.length;
                
                const completedTaskKeys = allTaskKeys.filter(taskKey => 
                    taskStates[taskKey].state === 'complete'
                );
                const completed = completedTaskKeys.length;
                const progress = total > 0 ? Math.round((completed / total) * 100) : 0;
                
                let status = 'in-progress';
                if (progress === 100) status = 'complete';
                
                milestones.push({
                    name: trade,
                    description: `${completed}/${total} tasks completed`,
                    status: status,
                    progress: progress
                });
            });

            // Only show milestones generated from real data
            
            // Sort by progress descending - show ALL milestones
            return milestones.sort((a, b) => b.progress - a.progress);
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Automatically load UNO data
            autoLoadUNOData();
        });
        // Anomaly Detection Functions - with proper 'no data' handling
        function detectAbandonedTrades(data) {
            const stalledTasks = [];
            const taskStates = {};
            
            // Only process valid states, skip 'no data' entries
            data.filter(row => row.state !== 'no data').forEach(row => {
                const taskKey = `${row.location}_${row.trade}`;
                if (!taskStates[taskKey]) {
                    taskStates[taskKey] = [];
                }
                taskStates[taskKey].push({
                    date: row.capture_date,
                    state: row.state,
                    location: row.location,
                    trade: row.trade
                });
            });
            
            Object.values(taskStates).forEach(taskHistory => {
                taskHistory.sort((a, b) => a.date.localeCompare(b.date));
                
                const inProgressDates = taskHistory.filter(t => t.state === 'in progress' || t.state === 'in-progress');
                if (inProgressDates.length >= 14) { // In progress for 14+ days
                    const task = taskHistory[0];
                    stalledTasks.push(task);
                }
            });
            
            return stalledTasks.length;
        }

        function detectStarvation(data) {
            const stackedLocations = [];
            const captureDates = [...new Set(data.map(row => row.capture_date))];
            
            captureDates.forEach(date => {
                const dayData = data.filter(row => row.capture_date === date && row.state !== 'no data');
                const locationGroups = {};
                
                dayData.filter(row => row.state === 'in progress' || row.state === 'in-progress').forEach(row => {
                    if (!locationGroups[row.location]) {
                        locationGroups[row.location] = [];
                    }
                    locationGroups[row.location].push(row.trade);
                });
                
                Object.entries(locationGroups).forEach(([location, trades]) => {
                    const uniqueTrades = [...new Set(trades)];
                    if (uniqueTrades.length >= 3) { // 3+ competing trades
                        stackedLocations.push({ location, date, trades: uniqueTrades });
                    }
                });
            });
            
            return stackedLocations.length;
        }

        function detectBurstStart(data) {
            const startsByWeek = {};
            const captureDates = [...new Set(data.map(row => row.capture_date))].sort();
            
            captureDates.forEach(date => {
                const dateObj = new Date(date);
                const weekStart = new Date(dateObj);
                weekStart.setDate(dateObj.getDate() - dateObj.getDay());
                const weekKey = weekStart.toISOString().split('T')[0];
                
                if (!startsByWeek[weekKey]) {
                    startsByWeek[weekKey] = 0;
                }
                
                const starts = data.filter(row => 
                    row.start_date === date && 
                    row.start_date.trim() !== '' && 
                    row.state !== 'no data'
                );
                startsByWeek[weekKey] += starts.length;
            });
            
            const weeklyStarts = Object.values(startsByWeek);
            const average = weeklyStarts.reduce((sum, val) => sum + val, 0) / weeklyStarts.length;
            
            return Object.entries(startsByWeek).filter(([week, starts]) => starts > average * 1.5).length;
        }

        function detectSwissCheese(data) {
            const locationCompletion = {};
            
            // Use final states to avoid counting 'no data' entries
            const taskStates = {};
            data.forEach(row => {
                const taskKey = `${row.location}_${row.trade}`;
                const captureDate = row.capture_date;
                
                if (row.state === 'no data') return;
                
                if (!taskStates[taskKey] || captureDate > taskStates[taskKey].date) {
                    taskStates[taskKey] = {
                        state: row.state,
                        location: row.location,
                        trade: row.trade
                    };
                }
            });
            
            // Count completion by location using final states
            Object.values(taskStates).forEach(task => {
                if (!locationCompletion[task.location]) {
                    locationCompletion[task.location] = { total: 0, completed: 0 };
                }
                locationCompletion[task.location].total++;
                if (task.state === 'complete') {
                    locationCompletion[task.location].completed++;
                }
            });
            
            const gapLocations = [];
            Object.entries(locationCompletion).forEach(([location, data]) => {
                const percentage = (data.completed / data.total) * 100;
                if (percentage > 30 && percentage < 90) {
                    gapLocations.push({ location, percentage });
                }
            });
            
            return gapLocations.length;
        }

        function detectTradeBlockage(data) {
            const sections = [...new Set(data.map(row => row.section).filter(Boolean))];
            const blockedTrades = {};
            
            sections.forEach(section => {
                const sectionData = data.filter(row => row.section === section && row.state !== 'no data');
                const inProgressTrades = {};
                
                sectionData.forEach(row => {
                    if (row.state === 'in progress' || row.state === 'in-progress') {
                        const taskKey = `${row.location}_${row.trade}`;
                        if (!inProgressTrades[taskKey]) {
                            inProgressTrades[taskKey] = { trade: row.trade, dates: [] };
                        }
                        inProgressTrades[taskKey].dates.push(row.capture_date);
                    }
                });
                
                const blocked = [];
                Object.values(inProgressTrades).forEach(task => {
                    if (task.dates.length >= 3) {
                        blocked.push(task.trade);
                    }
                });
                
                if (blocked.length > 0) {
                    blockedTrades[section] = [...new Set(blocked)];
                }
            });
            
            return Object.keys(blockedTrades).length;
        }

        function detectPrematureStart(data) {
            // Simplified implementation - count trades that started before their dependencies
            const prematureStarts = [];
            
            const tradeSequence = [
                'In Wall Insulation',
                'Wall Drywall', 
                'Overhead Plumbing',
                'Overhead Duct Rough In',
                'Overhead Duct Insulation',
                'Wall Drywall Finish',
                'Wall Prime Paint'
            ];
            
            // Find trades that started before their prerequisites were complete
            const locations = [...new Set(data.map(row => row.location))];
            
            locations.forEach(location => {
                const locationData = data.filter(row => row.location === location && row.state !== 'no data');
                
                tradeSequence.forEach((trade, index) => {
                    if (index === 0) return; // First trade has no prerequisites
                    
                    const prerequisite = tradeSequence[index - 1];
                    const tradeData = locationData.filter(row => row.trade === trade);
                    const prereqData = locationData.filter(row => row.trade === prerequisite);
                    
                    const tradeStarted = tradeData.some(row => row.state === 'in progress' || row.state === 'complete');
                    const prereqComplete = prereqData.some(row => row.state === 'complete');
                    
                    if (tradeStarted && !prereqComplete) {
                        prematureStarts.push({ location, trade, prerequisite });
                    }
                });
            });
            
            return prematureStarts.length;
        }

    </script>
</body>
</html>
