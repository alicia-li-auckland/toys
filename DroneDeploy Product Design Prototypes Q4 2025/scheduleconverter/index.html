<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Schedule to Actual Matcher</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
    }
    .table-container {
      overflow-x: auto;
      max-height: calc(100vh - 400px);
    }
    table {
      border-collapse: collapse;
      width: 100%;
    }
    th {
      position: sticky;
      top: 0;
      background-color: #f8fafc;
      z-index: 10;
      cursor: pointer;
      user-select: none;
    }
    th:hover {
      background-color: #f1f5f9;
    }
    .confidence-high { background-color: #dcfce7; }
    .confidence-medium { background-color: #fef9c3; }
    .confidence-low { background-color: #fee2e2; }
    .confidence-none { background-color: #f1f5f9; }
  </style>
</head>
<body class="bg-slate-50">
  <div class="container mx-auto px-4 py-6 max-w-7xl">
    <!-- Header -->
    <div class="mb-6">
      <h1 class="text-3xl font-bold text-slate-800 mb-2">Schedule to Actual Data Matcher</h1>
      <p class="text-slate-600">Match XER schedule activities with actual construction data using fuzzy matching</p>
    </div>

    <!-- Upload Section -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
      <!-- Schedule Upload -->
      <div class="bg-white rounded-lg shadow-sm p-6">
        <h2 class="text-lg font-semibold text-slate-800 mb-4">1. Upload Schedule (XER)</h2>
        <input type="file" id="scheduleInput" accept=".xer" class="hidden">
        <button 
          onclick="document.getElementById('scheduleInput').click()"
          class="w-full px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition-colors">
          Choose XER File
        </button>
        <div id="scheduleStatus" class="mt-3 text-sm text-slate-600">No file selected</div>
      </div>

      <!-- Actual Data Upload -->
      <div class="bg-white rounded-lg shadow-sm p-6">
        <h2 class="text-lg font-semibold text-slate-800 mb-4">2. Upload Actual Data (CSV/Excel/JSON)</h2>
        <input type="file" id="actualInput" accept=".csv,.xlsx,.xls,.json" class="hidden">
        <button 
          onclick="document.getElementById('actualInput').click()"
          class="w-full px-6 py-3 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700 transition-colors">
          Choose CSV/Excel/JSON File
        </button>
        <div id="actualStatus" class="mt-3 text-sm text-slate-600">No file selected</div>
      </div>
    </div>

    <!-- Match Button and Settings -->
    <div class="bg-white rounded-lg shadow-sm p-6 mb-6">
      <div class="flex flex-wrap items-center gap-4">
        <button 
          id="matchBtn"
          class="px-8 py-3 bg-purple-600 text-white font-semibold rounded-lg hover:bg-purple-700 transition-colors disabled:bg-slate-300 disabled:cursor-not-allowed"
          disabled>
          Match Activities
        </button>
        
        <div class="flex items-center gap-2">
          <label class="text-sm font-medium text-slate-700">Min Confidence:</label>
          <select id="confidenceThreshold" class="px-3 py-2 border border-slate-300 rounded-lg text-sm">
            <option value="0">0% (Show All)</option>
            <option value="50">50%</option>
            <option value="60" selected>60%</option>
            <option value="70">70%</option>
            <option value="80">80%</option>
            <option value="90">90%</option>
          </select>
        </div>

        <div class="flex items-center gap-2">
          <label class="text-sm font-medium text-slate-700">Activity Name Column:</label>
          <select id="actualNameColumn" class="px-3 py-2 border border-slate-300 rounded-lg text-sm">
            <option value="">Auto-detect</option>
          </select>
        </div>

        <button 
          id="exportScheduleBtn"
          class="ml-auto px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition-colors disabled:bg-slate-300 disabled:cursor-not-allowed"
          disabled>
          Export Schedule Only
        </button>
        <button 
          id="exportBtn"
          class="px-6 py-3 bg-slate-600 text-white font-semibold rounded-lg hover:bg-slate-700 transition-colors disabled:bg-slate-300 disabled:cursor-not-allowed"
          disabled>
          Export Merged CSV
        </button>
      </div>
    </div>

    <!-- Results Section -->
    <div id="resultsSection" class="bg-white rounded-lg shadow-sm p-6 hidden">
      <!-- Stats -->
      <div class="grid grid-cols-2 md:grid-cols-5 gap-4 mb-6">
        <div class="bg-slate-50 rounded-lg p-4">
          <div class="text-2xl font-bold text-slate-800" id="totalSchedule">0</div>
          <div class="text-xs text-slate-600">Schedule Activities</div>
        </div>
        <div class="bg-slate-50 rounded-lg p-4">
          <div class="text-2xl font-bold text-slate-800" id="totalActual">0</div>
          <div class="text-xs text-slate-600">Actual Records</div>
        </div>
        <div class="bg-green-50 rounded-lg p-4">
          <div class="text-2xl font-bold text-green-700" id="matchedCount">0</div>
          <div class="text-xs text-green-600">Matched (High)</div>
        </div>
        <div class="bg-yellow-50 rounded-lg p-4">
          <div class="text-2xl font-bold text-yellow-700" id="suggestedCount">0</div>
          <div class="text-xs text-yellow-600">Suggested (Medium)</div>
        </div>
        <div class="bg-red-50 rounded-lg p-4">
          <div class="text-2xl font-bold text-red-700" id="unmatchedCount">0</div>
          <div class="text-xs text-red-600">Unmatched</div>
        </div>
      </div>

      <!-- Filters -->
      <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-4">
        <div class="md:col-span-2">
          <input 
            type="text" 
            id="searchInput" 
            placeholder="Search activities..."
            class="w-full px-4 py-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
        </div>
        
        <select id="matchFilter" class="px-3 py-2 border border-slate-300 rounded-lg">
          <option value="all">All Matches</option>
          <option value="high">High Confidence (≥80%)</option>
          <option value="medium">Medium Confidence (60-79%)</option>
          <option value="low">Low Confidence (40-59%)</option>
          <option value="unmatched">Unmatched (&lt;40%)</option>
        </select>

        <button 
          id="clearFiltersBtn"
          class="px-4 py-2 bg-slate-200 text-slate-700 rounded-lg hover:bg-slate-300 transition-colors">
          Clear Filters
        </button>
      </div>

      <!-- Pagination Info -->
      <div class="flex justify-between items-center mb-4">
        <div class="text-sm text-slate-600">
          Showing <span id="showingStart">0</span>-<span id="showingEnd">0</span> of <span id="totalFiltered">0</span> activities
        </div>
        <div class="flex gap-2 items-center">
          <label class="text-sm text-slate-600">Per page:</label>
          <select id="perPageSelect" class="px-3 py-2 border border-slate-300 rounded-lg text-sm">
            <option value="50">50</option>
            <option value="100" selected>100</option>
            <option value="250">250</option>
            <option value="500">500</option>
          </select>
        </div>
      </div>

      <!-- Table -->
      <div class="table-container mb-4">
        <table id="resultsTable" class="min-w-full">
          <thead>
            <tr class="border-b-2 border-slate-200">
              <th class="px-4 py-3 text-left text-xs font-semibold text-slate-700 uppercase">Schedule Activity</th>
              <th class="px-4 py-3 text-left text-xs font-semibold text-slate-700 uppercase">Activity ID</th>
              <th class="px-4 py-3 text-left text-xs font-semibold text-slate-700 uppercase">Start Date</th>
              <th class="px-4 py-3 text-left text-xs font-semibold text-slate-700 uppercase">Finish Date</th>
              <th class="px-4 py-3 text-left text-xs font-semibold text-slate-700 uppercase">Confidence</th>
              <th class="px-4 py-3 text-left text-xs font-semibold text-slate-700 uppercase">Matched Actual Activity</th>
              <th class="px-4 py-3 text-left text-xs font-semibold text-slate-700 uppercase">Actual Data</th>
              <th class="px-4 py-3 text-left text-xs font-semibold text-slate-700 uppercase">Action</th>
            </tr>
          </thead>
          <tbody id="resultsBody">
          </tbody>
        </table>
      </div>

      <!-- Pagination Controls -->
      <div class="flex justify-between items-center">
        <button 
          id="prevPageBtn"
          class="px-4 py-2 bg-slate-600 text-white rounded-lg hover:bg-slate-700 disabled:bg-slate-300 disabled:cursor-not-allowed">
          Previous
        </button>
        <div class="text-sm text-slate-600">
          Page <span id="currentPage">1</span> of <span id="totalPages">1</span>
        </div>
        <button 
          id="nextPageBtn"
          class="px-4 py-2 bg-slate-600 text-white rounded-lg hover:bg-slate-700 disabled:bg-slate-300 disabled:cursor-not-allowed">
          Next
        </button>
      </div>
    </div>
  </div>

  <script>
    // Global state
    let scheduleData = [];
    let actualData = [];
    let matchedData = [];
    let filteredData = [];
    let currentPage = 1;
    let perPage = 100;
    let actualColumns = [];
    let locationMapping = {}; // Maps IDs to location names from JSON

    // File handlers
    document.getElementById('scheduleInput').addEventListener('change', handleScheduleUpload);
    document.getElementById('actualInput').addEventListener('change', handleActualUpload);
    document.getElementById('matchBtn').addEventListener('click', performMatching);
    document.getElementById('exportScheduleBtn').addEventListener('click', exportScheduleOnly);
    document.getElementById('exportBtn').addEventListener('click', exportMergedCSV);
    document.getElementById('searchInput').addEventListener('input', applyFilters);
    document.getElementById('matchFilter').addEventListener('change', applyFilters);
    document.getElementById('clearFiltersBtn').addEventListener('click', clearFilters);
    document.getElementById('perPageSelect').addEventListener('change', changePerPage);
    document.getElementById('prevPageBtn').addEventListener('click', () => changePage(-1));
    document.getElementById('nextPageBtn').addEventListener('click', () => changePage(1));

    function handleScheduleUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      document.getElementById('scheduleStatus').innerHTML = '<span class="text-blue-600">Processing...</span>';

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const content = e.target.result;
          scheduleData = parseXERData(content);
          
          document.getElementById('scheduleStatus').innerHTML = 
            `<span class="text-green-600 font-semibold">✓ ${scheduleData.length.toLocaleString()} activities loaded</span>`;
          
          // Enable schedule-only export
          document.getElementById('exportScheduleBtn').disabled = false;
          
          checkReadyToMatch();
        } catch (error) {
          document.getElementById('scheduleStatus').innerHTML = 
            `<span class="text-red-600">Error: ${error.message}</span>`;
          console.error(error);
        }
      };
      reader.readAsText(file);
    }

    function handleActualUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      document.getElementById('actualStatus').innerHTML = '<span class="text-blue-600">Processing...</span>';

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const content = e.target.result;
          
          if (file.name.endsWith('.csv')) {
            actualData = parseCSVData(content);
          } else if (file.name.endsWith('.json')) {
            const jsonData = JSON.parse(content);
            
            // Extract location mapping
            if (jsonData.locationKeyToName) {
              locationMapping = jsonData.locationKeyToName;
            }
            
            // Parse table structure
            if (jsonData.table) {
              const parsedData = [];
              for (const [date, locations] of Object.entries(jsonData.table)) {
                for (const [locationId, activities] of Object.entries(locations)) {
                  for (const [activityName, status] of Object.entries(activities)) {
                    parsedData.push({
                      id: locationId,
                      location_id: locationId,
                      location: locationMapping[locationId] || locationId,
                      activity_name: activityName,
                      status: status,
                      date: date
                    });
                  }
                }
              }
              actualData = parsedData;
            } else {
              actualData = Array.isArray(jsonData) ? jsonData : [jsonData];
            }
          } else if (file.name.endsWith('.xlsx') || file.name.endsWith('.xls')) {
            actualData = parseExcelData(content);
          }
          
          // Extract columns for dropdown
          if (actualData.length > 0) {
            actualColumns = Object.keys(actualData[0]);
            populateColumnDropdown();
          }
          
          document.getElementById('actualStatus').innerHTML = 
            `<span class="text-green-600 font-semibold">✓ ${actualData.length.toLocaleString()} records loaded</span>`;
          
          checkReadyToMatch();
        } catch (error) {
          document.getElementById('actualStatus').innerHTML = 
            `<span class="text-red-600">Error: ${error.message}</span>`;
          console.error(error);
        }
      };
      
      if (file.name.endsWith('.csv') || file.name.endsWith('.json')) {
        reader.readAsText(file);
      } else {
        reader.readAsArrayBuffer(file);
      }
    }

    function parseXERData(xerContent) {
      const lines = xerContent.split('\n');
      let section = null;
      let headers = [];
      const taskData = [];
      
      for (const rawLine of lines) {
        const line = rawLine.trim();
        
        if (line.startsWith('%T')) {
          headers = [];
          const upper = line.toUpperCase();
          if (upper.includes('TASK')) {
            section = 'TASK';
          } else {
            section = null;
          }
          continue;
        }
        
        if (!section) continue;
        
        if (line.startsWith('%F')) {
          headers = line.substring(3).split('\t').map(h => h.trim());
          continue;
        }
        
        if (line.startsWith('%R')) {
          const values = line.substring(3).split('\t');
          const rec = {};
          headers.forEach((header, i) => {
            rec[header] = values[i] ? values[i].trim() : '';
          });
          if (section === 'TASK') {
            taskData.push(rec);
          }
        }
      }
      
      if (taskData.length === 0) {
        throw new Error('No TASK records found in the XER file.');
      }
      
      return taskData;
    }

    function parseCSVData(csvContent) {
      const lines = csvContent.split(/\r?\n/).filter(line => line.trim() !== '');
      if (lines.length < 2) throw new Error('CSV file must have headers and data.');
      
      function parseRow(row) {
        const result = [];
        let current = '';
        let inQuotes = false;
        
        for (let i = 0; i < row.length; i++) {
          const char = row[i];
          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            result.push(current);
            current = '';
          } else {
            current += char;
          }
        }
        result.push(current);
        return result.map(v => v.trim().replace(/^"|"$/g, '').replace(/""/g, '"'));
      }
      
      const headers = parseRow(lines[0]);
      const data = [];
      
      for (let i = 1; i < lines.length; i++) {
        const values = parseRow(lines[i]);
        
        // Skip rows where all values are empty
        const hasData = values.some(v => v && v.trim() !== '');
        if (!hasData) continue;
        
        const row = {};
        headers.forEach((header, idx) => {
          row[header] = values[idx] || '';
        });
        data.push(row);
      }
      
      return data;
    }

    function parseExcelData(arrayBuffer) {
      const workbook = XLSX.read(arrayBuffer, { type: 'array' });
      const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
      
      // Try to parse as JSON first (for .json files masquerading as .xlsx)
      try {
        const text = new TextDecoder().decode(arrayBuffer);
        const jsonData = JSON.parse(text);
        
        // If it has the locationKeyToName mapping, extract it
        if (jsonData.locationKeyToName) {
          locationMapping = jsonData.locationKeyToName;
          console.log('Loaded location mapping with', Object.keys(locationMapping).length, 'locations');
        }
        
        // If it has the table structure, parse it
        if (jsonData.table) {
          const parsedData = [];
          for (const [date, locations] of Object.entries(jsonData.table)) {
            for (const [locationId, activities] of Object.entries(locations)) {
              for (const [activityName, status] of Object.entries(activities)) {
                parsedData.push({
                  id: locationId,
                  location_id: locationId,
                  location: locationMapping[locationId] || locationId,
                  activity_name: activityName,
                  status: status,
                  date: date
                });
              }
            }
          }
          return parsedData;
        }
      } catch (e) {
        // Not JSON, continue with Excel parsing
      }
      
      const jsonData = XLSX.utils.sheet_to_json(firstSheet, { raw: false });
      return jsonData;
    }

    function populateColumnDropdown() {
      const select = document.getElementById('actualNameColumn');
      select.innerHTML = '<option value="">Auto-detect</option>';
      
      actualColumns.forEach(col => {
        const option = document.createElement('option');
        option.value = col;
        option.textContent = col;
        select.appendChild(option);
      });
      
      // Auto-select if there's a column with 'name' or 'activity' in it
      const nameCol = actualColumns.find(c => 
        c.toLowerCase().includes('name') || c.toLowerCase().includes('activity')
      );
      if (nameCol) {
        select.value = nameCol;
      }
    }

    function checkReadyToMatch() {
      const ready = scheduleData.length > 0 && actualData.length > 0;
      document.getElementById('matchBtn').disabled = !ready;
    }

    function performMatching() {
      document.getElementById('matchBtn').innerHTML = '<span class="animate-pulse">Matching...</span>';
      document.getElementById('matchBtn').disabled = true;
      
      setTimeout(() => {
        const nameColumn = document.getElementById('actualNameColumn').value || detectNameColumn();
        const threshold = parseInt(document.getElementById('confidenceThreshold').value) / 100;
        
        matchedData = [];
        
        scheduleData.forEach((scheduleItem, index) => {
          const scheduleName = scheduleItem.task_name || scheduleItem.task_code || '';
          
          // Extract location from schedule name (e.g., "HA 13" from "Activity-HA 13")
          const scheduleLocation = extractLocationFromScheduleName(scheduleName);
          
          // Find best match in actual data
          let bestMatch = null;
          let bestScore = 0;
          let bestNameScore = 0;
          let bestLocationScore = 0;
          
          actualData.forEach(actualItem => {
            const actualName = actualItem[nameColumn] || '';
            const actualLocation = actualItem.Location_Name || actualItem.location || '';
            
            // Calculate activity name similarity
            const nameScore = calculateSimilarity(scheduleName, actualName);
            
            // Calculate location alignment score
            const locationScore = calculateLocationMatch(scheduleLocation, actualLocation);
            
            // Combined score: 70% name + 30% location
            // If location doesn't match at all, reduce score significantly
            let combinedScore = nameScore;
            if (locationScore > 0) {
              combinedScore = (nameScore * 0.7) + (locationScore * 0.3);
            } else if (scheduleLocation.numbers.length > 0 && actualLocation) {
              // Location info exists but doesn't match - penalize heavily
              combinedScore = nameScore * 0.3;
            }
            
            if (combinedScore > bestScore) {
              bestScore = combinedScore;
              bestMatch = actualItem;
              bestNameScore = nameScore;
              bestLocationScore = locationScore;
            }
          });
          
          matchedData.push({
            schedule: scheduleItem,
            scheduleLocation: scheduleLocation,
            actual: bestScore >= threshold ? bestMatch : null,
            confidence: bestScore,
            nameScore: bestNameScore,
            locationScore: bestLocationScore,
            scheduleIndex: index
          });
        });
        
        filteredData = [...matchedData];
        updateStats();
        renderResults();
        
        document.getElementById('resultsSection').classList.remove('hidden');
        document.getElementById('exportBtn').disabled = false;
        document.getElementById('matchBtn').innerHTML = 'Match Activities';
        document.getElementById('matchBtn').disabled = false;
      }, 100);
    }

    function extractLocationFromScheduleName(activityName) {
      // Extract location codes like "HA 13", "HA 08", "MDA 1", etc.
      // Patterns: -HA 13, -HA13, (HA 13), -MDA 1, etc.
      const result = {
        text: '',
        numbers: []
      };
      
      const patterns = [
        /[-_]\s*(HA|CA|MDA)\s*(\d+)/i,      // -HA 13, -CA 05
        /[-_]\s*([A-Z]{2,4})\s+(\d+)/i,     // -RACK 13
        /\(\s*(HA|CA|MDA)\s*(\d+)\s*\)/i,  // (HA 13)
      ];
      
      for (const pattern of patterns) {
        const match = activityName.match(pattern);
        if (match) {
          result.text = match[0].replace(/^[-_\s(]+|[)\s]+$/g, '');
          result.numbers = [parseInt(match[2])];
          break;
        }
      }
      
      return result;
    }
    
    function calculateLocationMatch(scheduleLocation, actualLocationText) {
      // Returns 0-1 score for location alignment
      
      if (!scheduleLocation.numbers || scheduleLocation.numbers.length === 0) {
        return 0.5; // No location in schedule, neutral score
      }
      
      if (!actualLocationText || actualLocationText.trim() === '') {
        return 0.5; // No location in actual data, neutral score
      }
      
      // Extract numbers from actual location (e.g., "RACK 13-14" → [13, 14])
      const actualNumbers = extractNumbersFromLocation(actualLocationText);
      
      if (actualNumbers.length === 0) {
        return 0.5; // Can't parse location, neutral score
      }
      
      // Check if schedule location number is in the actual location range
      const scheduleNum = scheduleLocation.numbers[0];
      
      if (actualNumbers.includes(scheduleNum)) {
        return 1.0; // Perfect match!
      }
      
      // Check proximity - close numbers get partial credit
      const minActual = Math.min(...actualNumbers);
      const maxActual = Math.max(...actualNumbers);
      const distance = Math.min(
        Math.abs(scheduleNum - minActual),
        Math.abs(scheduleNum - maxActual)
      );
      
      // Within 2 units: 0.7, within 5: 0.4, within 10: 0.2, else 0
      if (distance <= 2) return 0.7;
      if (distance <= 5) return 0.4;
      if (distance <= 10) return 0.2;
      
      return 0; // Too far, no match
    }
    
    function extractNumbersFromLocation(locationText) {
      // Extract numbers from location strings like:
      // "RACK 13-14" → [13, 14]
      // "RACK 11-12" → [11, 12]
      // "HA 29" → [29]
      
      const numbers = [];
      
      // Check for range pattern like "13-14" or "11-12"
      const rangeMatch = locationText.match(/(\d+)\s*-\s*(\d+)/);
      if (rangeMatch) {
        const start = parseInt(rangeMatch[1]);
        const end = parseInt(rangeMatch[2]);
        for (let i = start; i <= end; i++) {
          numbers.push(i);
        }
        return numbers;
      }
      
      // Extract single numbers
      const singleMatches = locationText.match(/\d+/g);
      if (singleMatches) {
        return singleMatches.map(n => parseInt(n));
      }
      
      return [];
    }

    function detectNameColumn() {
      const candidates = [
        'Actualised_Activity_Name',  // Your new CSV format - exact match
        'actualised_activity_name',   // lowercase version
        'activity_name', 
        'name', 
        'activity', 
        'task_name', 
        'task', 
        'description'
      ];
      
      // Try exact matches first
      for (const candidate of candidates) {
        const col = actualColumns.find(c => c === candidate || c.toLowerCase() === candidate.toLowerCase());
        if (col) return col;
      }
      
      // Fallback to first column with 'activity' or 'name' in it
      return actualColumns.find(c => c.toLowerCase().includes('activity') || c.toLowerCase().includes('name')) || actualColumns[0];
    }

    function calculateSimilarity(str1, str2) {
      const s1 = str1.toLowerCase().trim();
      const s2 = str2.toLowerCase().trim();
      
      if (s1 === s2) return 1.0;
      if (s1.length === 0 || s2.length === 0) return 0;
      
      // Extract core activity name by removing location suffixes
      const cleanStr1 = extractCoreActivityName(s1);
      const cleanStr2 = extractCoreActivityName(s2);
      
      // Check for exact match after cleaning
      if (cleanStr1 === cleanStr2) return 1.0;
      
      // Check if one string contains the other (substring match)
      if (s1.includes(s2) || s2.includes(s1)) {
        const longer = Math.max(s1.length, s2.length);
        const shorter = Math.min(s1.length, s2.length);
        return 0.85 + (0.15 * (shorter / longer)); // 85-100% match
      }
      
      // Check if cleaned versions contain each other
      if (cleanStr1.includes(cleanStr2) || cleanStr2.includes(cleanStr1)) {
        return 0.9; // High confidence for core name match
      }
      
      // Token-based matching (compare individual words)
      const tokens1 = cleanStr1.split(/[\s\-_,]+/).filter(t => t.length > 2);
      const tokens2 = cleanStr2.split(/[\s\-_,]+/).filter(t => t.length > 2);
      
      if (tokens1.length > 0 && tokens2.length > 0) {
        let matchedTokens = 0;
        for (const t1 of tokens1) {
          if (tokens2.some(t2 => t2.includes(t1) || t1.includes(t2))) {
            matchedTokens++;
          }
        }
        const tokenScore = matchedTokens / Math.max(tokens1.length, tokens2.length);
        
        // If token score is good, use it
        if (tokenScore >= 0.7) {
          return 0.75 + (tokenScore * 0.25); // 75-100% for good token matches
        }
      }
      
      // Fall back to Levenshtein distance for dissimilar strings
      const distance = levenshteinDistance(cleanStr1, cleanStr2);
      const maxLength = Math.max(cleanStr1.length, cleanStr2.length);
      return Math.max(0, 1 - (distance / maxLength));
    }
    
    function extractCoreActivityName(str) {
      // Remove common location suffixes like "-HA 29", "-Area A", " - Room 101", etc.
      let core = str;
      
      // Remove patterns like: -HA 29, -Area A, -Zone 1, - L2, etc.
      core = core.replace(/[-_]\s*([A-Z]{1,4}\s*\d+|area\s*[a-z0-9]+|zone\s*[a-z0-9]+|room\s*\d+|level\s*\d+|l\d+|floor\s*\d+|f\d+)/gi, '');
      
      // Remove trailing location codes in parentheses
      core = core.replace(/\s*\([^)]*\)\s*$/g, '');
      
      // Remove leading/trailing punctuation and spaces
      core = core.replace(/^[\s\-_,]+|[\s\-_,]+$/g, '');
      
      return core.trim();
    }
    
    function levenshteinDistance(str1, str2) {
      const matrix = [];
      
      for (let i = 0; i <= str2.length; i++) {
        matrix[i] = [i];
      }
      
      for (let j = 0; j <= str1.length; j++) {
        matrix[0][j] = j;
      }
      
      for (let i = 1; i <= str2.length; i++) {
        for (let j = 1; j <= str1.length; j++) {
          if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(
              matrix[i - 1][j - 1] + 1,
              matrix[i][j - 1] + 1,
              matrix[i - 1][j] + 1
            );
          }
        }
      }
      
      return matrix[str2.length][str1.length];
    }

    function updateStats() {
      document.getElementById('totalSchedule').textContent = scheduleData.length.toLocaleString();
      document.getElementById('totalActual').textContent = actualData.length.toLocaleString();
      
      const matched = filteredData.filter(m => m.confidence >= 0.8).length;
      const suggested = filteredData.filter(m => m.confidence >= 0.6 && m.confidence < 0.8).length;
      const unmatched = filteredData.filter(m => m.confidence < 0.6).length;
      
      document.getElementById('matchedCount').textContent = matched.toLocaleString();
      document.getElementById('suggestedCount').textContent = suggested.toLocaleString();
      document.getElementById('unmatchedCount').textContent = unmatched.toLocaleString();
    }

    function applyFilters() {
      const searchTerm = document.getElementById('searchInput').value.toLowerCase();
      const matchType = document.getElementById('matchFilter').value;
      
      filteredData = matchedData.filter(item => {
        // Search filter
        if (searchTerm) {
          const scheduleName = (item.schedule.task_name || '').toLowerCase();
          const actualName = item.actual ? Object.values(item.actual).join(' ').toLowerCase() : '';
          if (!scheduleName.includes(searchTerm) && !actualName.includes(searchTerm)) {
            return false;
          }
        }
        
        // Match type filter
        if (matchType === 'high' && item.confidence < 0.8) return false;
        if (matchType === 'medium' && (item.confidence < 0.6 || item.confidence >= 0.8)) return false;
        if (matchType === 'low' && (item.confidence < 0.4 || item.confidence >= 0.6)) return false;
        if (matchType === 'unmatched' && item.confidence >= 0.4) return false;
        
        return true;
      });
      
      currentPage = 1;
      renderResults();
    }

    function clearFilters() {
      document.getElementById('searchInput').value = '';
      document.getElementById('matchFilter').value = 'all';
      filteredData = [...matchedData];
      currentPage = 1;
      renderResults();
    }

    function changePerPage() {
      perPage = parseInt(document.getElementById('perPageSelect').value);
      currentPage = 1;
      renderResults();
    }

    function changePage(delta) {
      currentPage += delta;
      renderResults();
    }

    function renderResults() {
      const totalPages = Math.ceil(filteredData.length / perPage);
      const startIndex = (currentPage - 1) * perPage;
      const endIndex = Math.min(startIndex + perPage, filteredData.length);
      const pageData = filteredData.slice(startIndex, endIndex);
      
      document.getElementById('totalFiltered').textContent = filteredData.length.toLocaleString();
      document.getElementById('showingStart').textContent = (startIndex + 1).toLocaleString();
      document.getElementById('showingEnd').textContent = endIndex.toLocaleString();
      document.getElementById('currentPage').textContent = currentPage;
      document.getElementById('totalPages').textContent = totalPages;
      
      document.getElementById('prevPageBtn').disabled = currentPage === 1;
      document.getElementById('nextPageBtn').disabled = currentPage === totalPages;
      
      const tbody = document.getElementById('resultsBody');
      tbody.innerHTML = pageData.map((item, idx) => {
        const confidence = Math.round(item.confidence * 100);
        let confidenceClass = 'confidence-none';
        if (confidence >= 80) confidenceClass = 'confidence-high';
        else if (confidence >= 60) confidenceClass = 'confidence-medium';
        else if (confidence >= 40) confidenceClass = 'confidence-low';
        
        const scheduleName = item.schedule.task_name || 'N/A';
        const activityId = item.schedule.task_code || 'N/A';
        const startDate = item.schedule.early_start_date || item.schedule.act_start_date || 'N/A';
        const finishDate = item.schedule.early_end_date || item.schedule.act_end_date || 'N/A';
        
        const actualName = item.actual ? (item.actual[detectNameColumn()] || 'N/A') : 'No match';
        const actualInfo = item.actual ? 
          Object.entries(item.actual).slice(0, 3).map(([k, v]) => `${k}: ${v}`).join(', ') : 
          'No match found';
        
        return `
          <tr class="border-b border-slate-100 hover:bg-slate-50">
            <td class="px-4 py-3 text-sm text-slate-700">${escapeHtml(scheduleName)}</td>
            <td class="px-4 py-3 text-sm text-slate-700">${escapeHtml(activityId)}</td>
            <td class="px-4 py-3 text-sm text-slate-700 whitespace-nowrap">${escapeHtml(startDate)}</td>
            <td class="px-4 py-3 text-sm text-slate-700 whitespace-nowrap">${escapeHtml(finishDate)}</td>
            <td class="px-4 py-3 text-sm">
              <span class="px-2 py-1 rounded font-semibold ${confidenceClass}">${confidence}%</span>
            </td>
            <td class="px-4 py-3 text-sm text-slate-700">${escapeHtml(actualName)}</td>
            <td class="px-4 py-3 text-sm text-slate-600 max-w-xs truncate">${escapeHtml(actualInfo)}</td>
            <td class="px-4 py-3 text-sm">
              <button 
                class="text-blue-600 hover:text-blue-800 font-medium"
                onclick="viewDetails(${item.scheduleIndex})">
                View
              </button>
            </td>
          </tr>
        `;
      }).join('');
    }

    function viewDetails(scheduleIndex) {
      const item = matchedData.find(m => m.scheduleIndex === scheduleIndex);
      if (!item) return;
      
      const scheduleInfo = JSON.stringify(item.schedule, null, 2);
      const actualInfo = item.actual ? JSON.stringify(item.actual, null, 2) : 'No match';
      
      alert(`SCHEDULE DATA:\n${scheduleInfo}\n\nACTUAL DATA:\n${actualInfo}\n\nConfidence: ${Math.round(item.confidence * 100)}%`);
    }

    function exportScheduleOnly() {
      if (scheduleData.length === 0) return;
      
      // Show info about what's being exported
      const totalCount = scheduleData.length;
      const exportCount = totalCount;
      
      if (confirm(`Export all ${exportCount.toLocaleString()} schedule activities?\n\n(Currently no filters are applied to schedule-only export)`)) {
        // Clean formatted headers
        const headers = ['Schedule_ID', 'Schedule_Activity_Name', 'Schedule_Start_Date', 'Schedule_End_Date'];
        
        // Build rows with clean data
        const rows = scheduleData.map(item => ({
          Schedule_ID: item.task_code || '',
          Schedule_Activity_Name: item.task_name || '',
          Schedule_Start_Date: item.early_start_date || item.act_start_date || '',
          Schedule_End_Date: item.early_end_date || item.act_end_date || ''
        }));
      
      // Create CSV
      const csvHeaders = headers.map(h => `"${h}"`).join(',');
      const csvRows = rows.map(row => 
        headers.map(h => {
          const value = String(row[h] || '').replace(/"/g, '""');
          return `"${value}"`;
        }).join(',')
      );
      
        const csvContent = [csvHeaders, ...csvRows].join('\n');
        
        // Download
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        const url = URL.createObjectURL(blob);
        
        link.setAttribute('href', url);
        link.setAttribute('download', `schedule_${new Date().getTime()}.csv`);
        link.style.visibility = 'hidden';
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    }

    function exportMergedCSV() {
      if (matchedData.length === 0) return;
      
      // Use filtered data instead of all matched data
      const dataToExport = filteredData.length > 0 ? filteredData : matchedData;
      
      // Show confirmation with count
      const totalCount = matchedData.length;
      const exportCount = dataToExport.length;
      const filtersApplied = exportCount < totalCount;
      
      const message = filtersApplied 
        ? `Export ${exportCount.toLocaleString()} filtered activities?\n\n(${(totalCount - exportCount).toLocaleString()} activities will be excluded based on your current filters)`
        : `Export all ${exportCount.toLocaleString()} matched activities?`;
      
      if (!confirm(message)) return;
      
      // Clean formatted headers
      const headers = [
        'Schedule_ID',
        'Schedule_Activity_Name', 
        'Schedule_Start_Date',
        'Schedule_End_Date',
        'Location_ID',
        'Location_Name',
        'Detected_Start_Date',
        'Detected_End_Date',
        'Match_Confidence',
        'Actualised_Activity_Name'
      ];
      
      // Build rows with clean data
      let debugLogged = false;
      const rows = dataToExport.map(item => {
        // Debug: log first item to see structure
        if (!debugLogged && item.actual) {
          console.log('Sample actual data:', item.actual);
          console.log('Available keys:', Object.keys(item.actual));
          debugLogged = true;
        }
        
        // Get actual data fields with fallbacks
        let actualId = '';
        let actualName = '';
        let actualLocation = '';
        let actualStartDate = '';
        let actualEndDate = '';
        
        if (item.actual) {
          // Try to find ID
          actualId = item.actual.ID || item.actual.id || item.actual.location_id || item.actual._id || '';
          
          // Try to find activity name - check exact CSV column names first
          const possibleNameFields = [
            'Actualised_Activity_Name',  // Your new CSV format
            'Location/Activity',  // Old format
            'activity_name', 
            'name', 
            'activity', 
            'task_name', 
            'task'
          ];
          for (const field of possibleNameFields) {
            if (item.actual[field]) {
              actualName = item.actual[field];
              break;
            }
          }
          
          // Try to find location - check exact CSV column name first
          actualLocation = item.actual.Location_Name || item.actual['Location/Activity'] || item.actual.location || item.actual.Location || '';
          if (!actualLocation && actualId) {
            actualLocation = locationMapping[actualId] || '';
          }
          
          // Try to find dates - handle various field name formats
          actualStartDate = item.actual['Detected Start Date'] || item.actual.start_date || item.actual.startDate || item.actual.date || '';
          actualEndDate = item.actual['Detected End Date'] || item.actual.end_date || item.actual.endDate || '';
        }
        
        return {
          Schedule_ID: item.schedule.task_code || '',
          Schedule_Activity_Name: item.schedule.task_name || '',
          Schedule_Start_Date: item.schedule.early_start_date || item.schedule.act_start_date || '',
          Schedule_End_Date: item.schedule.early_end_date || item.schedule.act_end_date || '',
          Location_ID: actualId,
          Location_Name: actualLocation,
          Detected_Start_Date: actualStartDate,
          Detected_End_Date: actualEndDate,
          Match_Confidence: item.actual ? Math.round(item.confidence * 100) + '%' : '',
          Actualised_Activity_Name: actualName
        };
      });
      
      // Create CSV
      const csvHeaders = headers.map(h => `"${h}"`).join(',');
      const csvRows = rows.map(row => 
        headers.map(h => {
          const value = String(row[h] || '').replace(/"/g, '""');
          return `"${value}"`;
        }).join(',')
      );
      
      const csvContent = [csvHeaders, ...csvRows].join('\n');
      
      // Download
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      
      link.setAttribute('href', url);
      link.setAttribute('download', `schedule_actual_merged_${new Date().getTime()}.csv`);
      link.style.visibility = 'hidden';
      
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  </script>
</body>
</html>
