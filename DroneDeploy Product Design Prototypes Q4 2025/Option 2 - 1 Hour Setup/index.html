<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Construction Project Onboarding Accelerator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #f5f7fa;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            background: #1f1f1f;
            padding: 16px 24px;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 600;
            color: white;
        }

        .header-right {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .status-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
        }

        .status-draft {
            background: #fef3c7;
            color: #92400e;
        }

        .btn-primary {
            background: #2563eb;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        .btn-primary:hover {
            background: #1d4ed8;
        }

        .btn-secondary {
            background: #374151;
            color: white;
            border: 1px solid #4b5563;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-secondary:hover {
            background: #4b5563;
            border-color: #6b7280;
        }

        .container {
            display: flex;
            height: calc(100vh - 65px);
        }

        .panel {
            background: white;
            border-right: 1px solid #e1e4e8;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel:nth-child(1) {
            flex: 0 0 20%; /* Input panel - 20% */
        }

        .panel:nth-child(2) {
            flex: 0 0 20%; /* Parsing panel - 20% */
        }

        .panel:nth-child(3) {
            flex: 0 0 60%; /* Output panel - 60% */
        }

        .panel:last-child {
            border-right: none;
        }


        .panel-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        /* Input Panel Styles */
        .drop-zone {
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
            margin-bottom: 20px;
        }

        .drop-zone.dragover {
            border-color: #2563eb;
            background: #eff6ff;
        }

        .drop-zone-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 12px;
            opacity: 0.5;
        }

        .drop-zone-text {
            color: #6b7280;
            font-size: 14px;
        }

        .file-list {
            margin-top: 16px;
        }

        .file-item {
            display: flex;
            align-items: center;
            padding: 12px;
            background: #f9fafb;
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .file-icon {
            width: 20px;
            height: 20px;
            margin-right: 12px;
            opacity: 0.6;
        }

        .file-name {
            flex: 1;
            color: #374151;
        }

        .file-remove {
            color: #ef4444;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            padding: 0 4px;
        }

        /* Step Sections */
        .step-section {
            margin-bottom: 24px;
            padding-bottom: 20px;
            border-bottom: 1px solid #f3f4f6;
        }

        .step-section:last-child {
            border-bottom: none;
        }

        .step-header {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
        }

        .step-number {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background: #3b82f6;
            color: white;
            font-size: 12px;
            font-weight: 600;
            border-radius: 50%;
            margin-right: 12px;
        }

        .step-title {
            font-size: 14px;
            font-weight: 600;
            color: #374151;
        }

        .template-selector {
            margin-top: 0;
        }

        .template-label {
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }

        .template-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .template-btn {
            flex: 1;
            padding: 12px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .template-btn.active {
            border-color: #2563eb;
            background: #eff6ff;
        }

        .template-btn-title {
            font-size: 14px;
            font-weight: 500;
            color: #1f2937;
            margin-bottom: 4px;
        }

        .template-btn-count {
            font-size: 12px;
            color: #6b7280;
        }

        /* Parsing Panel Styles */
        .parsing-item {
            padding: 16px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin-bottom: 12px;
        }

        .parsing-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .parsing-item-title {
            font-size: 14px;
            font-weight: 500;
            color: #1f2937;
        }

        .confidence-badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .confidence-high {
            background: #d1fae5;
            color: #065f46;
        }

        .confidence-medium {
            background: #fed7aa;
            color: #92400e;
        }

        .confidence-low {
            background: #fee2e2;
            color: #991b1b;
        }

        .parsing-mapping {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
            padding: 12px;
            background: #f9fafb;
            border-radius: 6px;
        }

        .mapping-arrow {
            color: #9ca3af;
        }

        .mapping-original {
            font-size: 13px;
            color: #6b7280;
            font-family: monospace;
        }

        .mapping-suggested {
            font-size: 13px;
            color: #1f2937;
            font-weight: 500;
        }

        .parsing-actions {
            display: flex;
            gap: 8px;
        }

        .parsing-btn {
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 500;
            border: 1px solid #e5e7eb;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
        }

        .parsing-btn:hover {
            background: #f9fafb;
        }

        .parsing-btn.accept {
            color: #059669;
            border-color: #10b981;
        }

        .parsing-btn.accept:hover {
            background: #ecfdf5;
        }

        .parsing-btn.reject {
            color: #dc2626;
            border-color: #ef4444;
        }

        .parsing-btn.reject:hover {
            background: #fef2f2;
        }

        .excluded-section {
            margin-top: 32px;
            padding-top: 24px;
        }

        .excluded-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
        }

        .excluded-title {
            font-size: 13px;
            font-weight: 600;
            color: #6b7280;
        }

        .excluded-count {
            background: #f3f4f6;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 12px;
            color: #6b7280;
        }

        .excluded-item {
            padding: 8px 12px;
            background: #f9fafb;
            border-radius: 4px;
            margin-bottom: 6px;
            font-size: 13px;
            color: #6b7280;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .restore-btn {
            color: #2563eb;
            font-size: 12px;
            cursor: pointer;
            font-weight: 500;
        }

        /* Output Panel Styles */

        .gantt-container {
            padding: 20px;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        /* Timeline-style Gantt Chart */
        .timeline-gantt-wrapper {
            background: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .timeline-legend {
            padding: 12px 16px;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            gap: 24px;
            font-size: 14px;
            background: #f8fafc;
            border-radius: 12px 12px 0 0;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-bar {
            width: 40px;
            height: 16px;
            border-radius: 4px;
        }

        .legend-planned {
            border: 2px solid #64748b;
            background: transparent;
        }

        .legend-actual {
            background: #64748b;
        }

        .timeline-grid-wrapper {
            display: grid;
            grid-template-columns: 300px 1fr;
            overflow: auto;
            height: calc(100% - 60px);
            min-height: 300px;
        }

        .timeline-corner {
            padding: 12px 16px;
            border-right: 1px solid #e2e8f0;
            border-bottom: 1px solid #e2e8f0;
            background: #f1f5f9;
            position: sticky;
            top: 0;
            left: 0;
            z-index: 30;
            font-weight: 600;
            color: #475569;
            font-size: 14px;
        }

        .timeline-header {
            border-bottom: 1px solid #e2e8f0;
            background: rgba(248, 250, 252, 0.95);
            backdrop-filter: blur(8px);
            position: sticky;
            top: 0;
            z-index: 30;
            display: flex;
            min-width: max-content;
        }

        .timeline-week {
            width: 120px;
            padding: 12px 8px;
            text-align: center;
            border-right: 1px solid #e2e8f0;
            font-size: 12px;
            font-weight: 500;
            color: #64748b;
        }

        .timeline-activities {
            border-right: 1px solid #e2e8f0;
            background: white;
            position: sticky;
            left: 0;
            z-index: 10;
        }

        .timeline-activity-row {
            padding: 12px 16px;
            border-bottom: 1px solid #f1f5f9;
            font-size: 13px;
            color: #334155;
            height: 48px;
            display: flex;
            align-items: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .timeline-activity-row:hover {
            background-color: #f8fafc;
            border-left-color: #cbd5e1;
        }

        .timeline-activity-row.selected {
            background-color: #dbeafe !important;
            border-left-color: #3b82f6 !important;
        }

        .timeline-activity-row.selected:hover {
            background-color: #bfdbfe;
        }

        .timeline-bars-container {
            overflow: visible;
            position: relative;
        }

        .timeline-bars {
            position: relative;
            display: grid;
            min-width: max-content;
        }

        .timeline-bar-row {
            height: 48px;
            border-bottom: 1px solid #f1f5f9;
            position: relative;
            display: flex;
            align-items: center;
        }

        .timeline-bar {
            height: 20px;
            border-radius: 4px;
            position: absolute;
            display: flex;
            align-items: center;
            padding: 0 8px;
            font-size: 11px;
            font-weight: 500;
            color: white;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 60px;
            border: 2px solid transparent;
            cursor: ew-resize;
            user-select: none;
            transition: box-shadow 0.2s;
        }

        .timeline-bar:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            z-index: 10;
        }

        .timeline-bar.dragging {
            opacity: 0.8;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            z-index: 20;
        }

        .timeline-bar-resize-handle {
            position: absolute;
            right: -2px;
            top: 0;
            width: 8px;
            height: 100%;
            cursor: ew-resize;
            background: rgba(255,255,255,0.3);
            border-radius: 0 4px 4px 0;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .timeline-bar:hover .timeline-bar-resize-handle {
            opacity: 1;
        }

        .timeline-bar.planned {
            background: #64748b;
            color: white;
            border: 2px solid #64748b;
        }

        /* Trade-specific colors for planned bars */
        .timeline-bar.planned.concrete_pour { background: #8b5cf6; border-color: #8b5cf6; }
        .timeline-bar.planned.concrete_formwork { background: #a855f7; border-color: #a855f7; }
        .timeline-bar.planned.concrete_rebar { background: #9333ea; border-color: #9333ea; }
        .timeline-bar.planned.structural_steel { background: #6b7280; border-color: #6b7280; }
        .timeline-bar.planned.structural_piles { background: #52525b; border-color: #52525b; }
        .timeline-bar.planned.electrical { background: #f59e0b; border-color: #f59e0b; }
        .timeline-bar.planned.mechanical { background: #06b6d4; border-color: #06b6d4; }
        .timeline-bar.planned.plumbing { background: #3b82f6; border-color: #3b82f6; }
        .timeline-bar.planned.roofing { background: #dc2626; border-color: #dc2626; }
        .timeline-bar.planned.drywall { background: #ef4444; border-color: #ef4444; }
        .timeline-bar.planned.excavation { background: #92400e; border-color: #92400e; }

        .timeline-grid-lines {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 1;
        }

        .timeline-grid-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            background: #f1f5f9;
        }

        /* Custom scrollbar */
        .timeline-grid-wrapper::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .timeline-grid-wrapper::-webkit-scrollbar-track {
            background: #f1f5f9;
        }

        .timeline-grid-wrapper::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 4px;
        }

        .timeline-grid-wrapper::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        /* Review Modal Styles */
        .review-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .review-modal-content {
            background: white;
            border-radius: 12px;
            padding: 24px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }

        .review-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 1px solid #e5e7eb;
        }

        .review-modal-title {
            font-size: 20px;
            font-weight: 600;
            color: #1f2937;
        }

        .review-modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #6b7280;
            padding: 4px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .review-modal-close:hover {
            background: #f3f4f6;
        }

        .review-modal-body {
            margin-bottom: 24px;
        }

        .review-section {
            margin-bottom: 24px;
        }

        .review-section-title {
            font-size: 16px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 12px;
        }

        .gantt-screenshot {
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 16px;
            background: white;
        }

        .email-field {
            width: 100%;
            padding: 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
        }

        .email-field:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .review-modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            padding-top: 16px;
        }

        .btn-cancel {
            background: #f9fafb;
            color: #374151;
            border: 1px solid #d1d5db;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-cancel:hover {
            background: #f3f4f6;
        }


        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        .stat-card {
            background: #f9fafb;
            padding: 16px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .stat-label {
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 600;
            color: #1f2937;
        }

        .hidden {
            display: none;
        }

        .processing-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 100;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e5e7eb;
            border-top-color: #2563eb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .processing-text {
            margin-top: 16px;
            color: #6b7280;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <!-- Include AI Integration -->
    <script src="../../config.js"></script>
    <script src="../../gemini-api.js"></script>
    <!-- Header -->
    <div class="header">
        <h1>üõ†Ô∏è 1-Hour Project Setup</h1>
        <div class="header-right">
            <span class="status-badge status-draft">Setup In Progress</span>
            <button class="btn-secondary" onclick="window.location.href='../'">Back to Dashboard</button>
            <button class="btn-secondary">Save Draft</button>
            <button id="downloadRejectedBtn" onclick="downloadRejectedList()" 
                    style="background: #dc2626; color: white; border: none; padding: 8px 12px; border-radius: 6px; font-size: 12px; cursor: pointer; display: none;" 
                    title="Download list of rejected items">
                üì• Download Rejected (<span id="rejectionCount">0</span>)
            </button>
            <button class="btn-primary" onclick="openReviewModal1Hour()">Send for Review</button>
        </div>
    </div>

    <!-- Main Container -->
    <div class="container">
        <!-- Input Panel -->
        <div class="panel">
            <div class="panel-content">
                <!-- Step 1: Building Type -->
                <div class="step-section">
                    <div class="step-header">
                        <span class="step-number">1</span>
                        <span class="step-title">Select Building Type</span>
                    </div>
                    <div class="template-selector">
                <div class="template-buttons">
                    <div class="template-btn" id="commercialTemplate" onclick="selectTemplate('commercial')">
                        <div class="template-btn-title">üè¢ Commercial / Mixed Use</div>
                        <div class="template-btn-count">34 Progress AI trades across 5 construction stages</div>
                    </div>
                    <div class="template-btn" id="datacentersTemplate" onclick="selectTemplate('datacenters')">
                        <div class="template-btn-title">üñ•Ô∏è Data Centers</div>
                        <div class="template-btn-count">45 specialized trades for data center construction</div>
                    </div>
                    <div class="template-btn" id="energyTemplate" onclick="selectTemplate('energy')">
                        <div class="template-btn-title">‚ö° Energy / Power / Water Treatment</div>
                        <div class="template-btn-count">35 specialized trades for energy infrastructure</div>
                    </div>
                    <div class="template-btn" id="healthcareTemplate" onclick="selectTemplate('healthcare')">
                        <div class="template-btn-title">üè• Healthcare</div>
                        <div class="template-btn-count">34 Progress AI trades with complex MEP systems</div>
                    </div>
                    <div class="template-btn" id="hospitalityTemplate" onclick="selectTemplate('hospitality')">
                        <div class="template-btn-title">üè® Hospitality</div>
                        <div class="template-btn-count">34 Progress AI trades for hospitality construction</div>
                </div>
                    <div class="template-btn" id="infrastructureTemplate" onclick="selectTemplate('infrastructure')">
                        <div class="template-btn-title">üöß Infrastructure / Heavy Civil</div>
                        <div class="template-btn-count">34 Progress AI trades for heavy civil projects</div>
                    </div>
                    <div class="template-btn" id="institutionalTemplate" onclick="selectTemplate('institutional')">
                        <div class="template-btn-title">üèõÔ∏è Institutional / Education</div>
                        <div class="template-btn-count">34 Progress AI trades for institutional projects</div>
                    </div>
                    <div class="template-btn" id="manufacturingTemplate" onclick="selectTemplate('manufacturing')">
                        <div class="template-btn-title">üè≠ Manufacturing / Industrial</div>
                        <div class="template-btn-count">34 Progress AI trades for industrial construction</div>
                    </div>
                    <div class="template-btn" id="multifamilyTemplate" onclick="selectTemplate('multifamily')">
                        <div class="template-btn-title">üè† Multi Family / Residential</div>
                        <div class="template-btn-count">34 Progress AI trades for residential projects</div>
                    </div>
                </div>
                    </div>
                </div>

                <!-- Step 2: Upload Schedule -->
                <div class="step-section">
                    <div class="step-header">
                        <span class="step-number">2</span>
                        <span class="step-title">Upload Schedule</span>
                    </div>
                    <div class="drop-zone" id="scheduleDropZone" ondrop="handleScheduleDrop(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                        <svg class="drop-zone-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                        <div class="drop-zone-text">
                            Drop schedule file here or click to browse<br>
                            <small style="color: #9ca3af;">XER, CSV, Excel files</small>
                        </div>
                    </div>
                </div>


                <!-- File List -->
                <div class="file-list" id="fileList"></div>

                <!-- AI Enhancement Button -->
                <div class="ai-enhance-section" style="margin-top: 24px; padding-top: 20px;">
                    <div style="text-align: center;">
                        <button class="btn-primary" onclick="enhanceWithAI()" id="aiEnhanceBtn" disabled style="width: 100%; background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%); box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1); opacity: 0.5;">
                            <svg style="width: 20px; height: 20px; margin-right: 8px; display: inline-block;" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
                            </svg>
                            ü§ñ AI Enhance with Progress AI
                        </button>
                        <div style="margin-top: 8px; font-size: 12px; color: #6b7280; text-align: center;">
                            Upload files first, then click to systematically match activities to our 47-trade database
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Parsing Panel -->
        <div class="panel">
            <div class="panel-content" id="parsingPanel" style="position: relative;">
                <div id="parsingContent">
                    <!-- Loading State -->
                    <div id="parsingEmptyState" style="text-align: center; padding: 60px 20px; color: #6b7280;">
                        <div style="font-size: 48px; margin-bottom: 16px;">ü§ñ</div>
                        <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">Ready for AI Analysis</div>
                        <div style="font-size: 14px;">Upload schedule files to begin AI parsing and trade matching</div>
                    </div>

                    <!-- Loading State with Details -->
                    <div id="loadingState" style="display: none; text-align: center; padding: 40px 20px;">
                        <div style="font-size: 48px; margin-bottom: 16px;">ü§ñ</div>
                        <div style="font-size: 18px; font-weight: 600; margin-bottom: 16px;">AI Processing Schedule...</div>
                        <div id="loadingDetails" style="font-size: 14px; color: #6b7280; max-width: 600px; margin: 0 auto; text-align: left;">
                            <!-- Detailed loading messages will appear here -->
                        </div>
                    </div>

                    <!-- Accepted Items Section -->
                    <div id="acceptedSection" style="display: none; margin-bottom: 24px;">
                        <div style="display: flex; align-items: center; margin-bottom: 12px; padding: 12px; background: #f0f9ff; border-left: 4px solid #10b981; border-radius: 6px;">
                            <span style="font-size: 24px; margin-right: 12px;">‚úÖ</span>
                    <div>
                                <div style="font-weight: 600; color: #10b981;">Accepted Mappings</div>
                                <div style="font-size: 14px; color: #6b7280;">Items you've approved for tracking (<span id="acceptedCount">0</span>)</div>
                    </div>
                </div>
                        <div id="acceptedItems" style="max-height: 300px; overflow-y: auto;"></div>
            </div>

                    <!-- Pending Items Section -->
                    <div id="pendingSection" style="display: none; margin-bottom: 24px;">
                        <div style="display: flex; align-items: center; margin-bottom: 12px; padding: 12px; background: #fffbeb; border-left: 4px solid #f59e0b; border-radius: 6px;">
                            <span style="font-size: 24px; margin-right: 12px;">‚è≥</span>
                            <div>
                                <div style="font-weight: 600; color: #f59e0b;">Pending Review</div>
                                <div style="font-size: 14px; color: #6b7280;">AI suggestions waiting for your approval (<span id="pendingCount">0</span>)</div>
                    </div>
                        </div>
                        <div id="pendingItems"></div>
                    </div>

                    <!-- Rejected Items Section -->
                    <div id="rejectedSection" style="display: none; margin-bottom: 24px;">
                        <div style="display: flex; align-items: center; margin-bottom: 12px; padding: 12px; background: #fef2f2; border-left: 4px solid #dc2626; border-radius: 6px;">
                            <span style="font-size: 24px; margin-right: 12px;">‚ùå</span>
                            <div>
                                <div style="font-weight: 600; color: #dc2626;">Rejected Items</div>
                                <div style="font-size: 14px; color: #6b7280;">Items you've declined for tracking (<span id="rejectedItemsCount">0</span>)</div>
                            </div>
                        </div>
                        <div id="rejectedItems" style="max-height: 300px; overflow-y: auto;"></div>
                </div>
                
                <!-- Excluded Items Section -->
                    <div id="excludedSection" style="display: none;">
                        <div style="display: flex; align-items: center; margin-bottom: 12px; padding: 12px; background: #f9fafb; border-left: 4px solid #6b7280; border-radius: 6px;">
                            <span style="font-size: 24px; margin-right: 12px;">üö´</span>
                            <div>
                                <div style="font-weight: 600; color: #6b7280;">Excluded Items</div>
                                <div style="font-size: 14px; color: #6b7280;">Items automatically filtered out (<span id="excludedCount">0</span>)</div>
                    </div>
                </div>
                        <div id="excludedItems" style="max-height: 200px; overflow-y: auto;"></div>
            </div>
        </div>

            </div>
            </div>
            
        <!-- Output Panel -->
        <div class="panel">
            <div class="panel-content">
                <!-- Zone/Level Filter -->
                <div id="zoneFilter" style="display: none; margin-bottom: 16px; padding: 12px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
                    <div style="font-weight: 600; margin-bottom: 8px; color: #1e293b;">üèóÔ∏è Filter by Zone/Level</div>
                    <div id="zoneFilterButtons" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
                </div>

                <!-- Gantt Chart View -->
                <div id="ganttView" class="gantt-container">
                    <!-- Empty State -->
                    <div id="outputEmptyState" style="text-align: center; padding: 60px 20px; color: #6b7280;">
                        <div style="font-size: 48px; margin-bottom: 16px;">üìä</div>
                        <div style="font-size: 18px; font-weight: 600; margin-bottom: 8px;">Ready to Generate Timeline</div>
                        <div style="font-size: 14px;">Upload and process your schedule to see the project timeline</div>
                    </div>
                    
                    <div class="stats-grid" id="statsGrid" style="display: none;">
                        <div class="stat-card">
                            <div class="stat-label">Total Activities</div>
                            <div class="stat-value" id="totalActivities">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Mapped Trades</div>
                            <div class="stat-value" id="mappedTrades">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Project Duration</div>
                            <div class="stat-value" id="projectDuration">0 weeks</div>
                        </div>
                    </div>
                    
                    <!-- Bulk Actions Toolbar -->
                    <div id="bulkActionsToolbar" style="display: none; background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px; margin-bottom: 16px; justify-content: space-between; align-items: center;">
                        <div style="font-size: 14px; color: #374151; font-weight: 500;">
                            <span id="selectedCount">0</span> items selected
                            <span style="font-size: 11px; color: #6b7280; margin-left: 8px;" title="Click to select single item, Ctrl+click (Cmd+click on Mac) to select multiple items">‚ÑπÔ∏è</span>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button onclick="bulkAcceptSelected()" style="background: #16a34a; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 12px; cursor: pointer;">
                                ‚úÖ Accept Selected
                            </button>
                            <button onclick="bulkRejectSelected()" style="background: #dc2626; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 12px; cursor: pointer;">
                                ‚ùå Reject Selected
                            </button>
                            <button onclick="selectAllGanttItems()" style="background: #0ea5e9; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 12px; cursor: pointer;">
                                Select All
                            </button>
                            <button onclick="clearGanttSelection()" style="background: #6b7280; color: white; border: none; padding: 6px 12px; border-radius: 4px; font-size: 12px; cursor: pointer;">
                                Clear Selection
                            </button>
                        </div>
                    </div>
                    
                    <div id="ganttChart" style="display: none;">
                        <!-- Gantt chart will be dynamically generated -->
                    </div>
                </div>
                
            </div>
        </div>
    </div>

    <script type="text/javascript">
        // Constants
        const CONFIG = {
            AI: {
                BATCH_SIZE: 10,
                TIMEOUT_MS: 30000,
                BATCH_DELAY_MS: 100,
                MAX_OUTPUT_TOKENS: 1024,
                TEMPERATURE: 0.1
            },
            CONFIDENCE: {
                MINIMUM_MATCH: 50,
                HIGH_THRESHOLD: 90,
                MEDIUM_THRESHOLD: 70,
                FALLBACK_CAP: 70,
                ERROR_FALLBACK_CAP: 50
            },
            UI: {
                PARSING_TIMEOUT_MS: 30000,
                PROGRESS_STEPS: 8
            }
        };

        // Global state object
        const AppState = {
            files: {
                uploaded: [],
                selected: null
            },
            parsing: {
                items: [],
                excluded: [],
                currentlyDisplayed: []
            },
            user: {
                accepted: [],
                rejected: [],
                selectedGanttItems: new Set()
            },
            config: {
                selectedBuildingType: null
            },
            learning: {
                database: []
            }
        };

        // Error handling utilities
        const ErrorHandler = {
            logError: (context, error, details = {}) => {
                console.error('‚ùå ' + context + ':', error.message, details);
            },
            
            logWarning: (context, message, details = {}) => {
                console.warn('‚ö†Ô∏è ' + context + ': ' + message, details);
            },
            
            createFallbackItem: (activity, reason, confidence = 0) => {
                return {
                    original: activity.original || 'Unknown Activity',
                    suggested: reason,
                    confidence: confidence,
                    trade: 'error',
                    tradeId: null,
                    category: 'Error',
                    accuracy: 0,
                    status: 'Error',
                    aiEnhanced: false,
                    aiReasoning: reason,
                    aiAlternatives: ''
                };
            }
        };

        // UI Feedback utilities
        const UIFeedback = {
            showSyncNotification: (message) => {
                const notification = document.createElement('div');
                notification.style.cssText = 
                    'position: fixed; top: 20px; right: 20px; z-index: 1000;' +
                    'background: #059669; color: white; padding: 12px 20px; border-radius: 8px;' +
                    'box-shadow: 0 4px 12px rgba(0,0,0,0.15); font-size: 14px; font-weight: 500;' +
                    'transform: translateX(400px); transition: transform 0.3s ease;';
                notification.textContent = '‚úì ' + message;
                
                document.body.appendChild(notification);
                
                // Animate in
                setTimeout(() => notification.style.transform = 'translateX(0)', 10);
                
                // Auto remove
                setTimeout(() => {
                    notification.style.transform = 'translateX(400px)';
                    setTimeout(() => notification.remove(), 300);
                }, 3000);
            }
        };

        // Create global reference for convenience
        window.showSyncNotification = UIFeedback.showSyncNotification;
        
        // Global variables for backwards compatibility (should eventually migrate to AppState)
        let parsedItems = [];
        let excludedItems = [];
        let acceptedMappings = [];
        let rejectedMappings = [];
        let learningDatabase = [];
        let currentlyDisplayedItems = [];
        
        // Data Center Zone Definitions
        const dataCenterZones = {
            'EYD 1 Gen Yard': {
                keywords: ['eyd1 gen', 'eyd 1 gen', 'eyd1-gen', 'eyd1 generator', 'generator yard 1', 'gen yard 1'],
                primaryTrades: ['Generator Placement', 'Electrical Yard Equipment Conduit', 'Electrical Yard Equipment Placement']
            },
            'EYD 2 Gen Yard': {
                keywords: ['eyd2 gen', 'eyd 2 gen', 'eyd2-gen', 'eyd2 generator', 'generator yard 2', 'gen yard 2'],
                primaryTrades: ['Generator Placement', 'Electrical Yard Equipment Conduit', 'Electrical Yard Equipment Placement']
            },
            'EYD 1 USS Yard': {
                keywords: ['eyd1 uss', 'eyd 1 uss', 'eyd1-uss', 'uss yard 1', 'uss 1'],
                primaryTrades: ['Electrical Yard Equipment Placement', 'Electrical Yard Equipment Conduit']
            },
            'EYD 2 USS Yard': {
                keywords: ['eyd2 uss', 'eyd 2 uss', 'eyd2-uss', 'uss yard 2', 'uss 2'],
                primaryTrades: ['Electrical Yard Equipment Placement', 'Electrical Yard Equipment Conduit']
            },
            'FSA': {
                keywords: ['fsa', 'facility support', 'support area'],
                primaryTrades: ['Structural Steel', 'Roofing Metal Deck', 'Roofing Insulation', 'Roofing Membrane']
            },
            'DCH 1': {
                keywords: ['dch1', 'dch 1', 'dch-1', 'data center hall 1', 'datacenter 1'],
                primaryTrades: ['Structural Steel', 'Roofing Metal Deck', 'Roofing Insulation', 'Roofing Membrane']
            },
            'DCH 2': {
                keywords: ['dch2', 'dch 2', 'dch-2', 'data center hall 2', 'datacenter 2'],
                primaryTrades: ['Structural Steel', 'Roofing Metal Deck', 'Roofing Insulation', 'Roofing Membrane']
            },
            'MCP 1': {
                keywords: ['mcp1', 'mcp 1', 'mcp-1', 'mechanical cooling plant 1', 'cooling plant 1', 'myd1'],
                primaryTrades: ['Mechanical Yard Equipment Placement']
            },
            'MCP 2': {
                keywords: ['mcp2', 'mcp 2', 'mcp-2', 'mechanical cooling plant 2', 'cooling plant 2', 'myd2'],
                primaryTrades: ['Mechanical Yard Equipment Placement']
            }
        };
        
        // Comprehensive exclusion keywords - from uploaded list + additional suggestions
        const excludeKeywords = [
            // User uploaded keywords
            'rfp', 'rfi', 'approval', 'submittal', 'review', 'meeting', 'mobilization', 'demobilization', 
            'permit', 'inspection', 'testing', 'close out', 'closeout', 'procurement', 'ordering', 
            'delivery', 'schedule', 'planning', 'coordination', 'procure', 'po', 'design', 'lead time', 
            'inventory', 'offsite', 'deliver',
            
            // Additional administrative/non-construction keywords
            'training', 'safety briefing', 'orientation', 'kickoff', 'startup', 'shutdown', 'commissioning',
            'documentation', 'reporting', 'invoice', 'billing', 'payment', 'contract', 'legal',
            'warranty', 'punch list', 'walkthrough', 'final inspection', 'handover', 'turnover',
            'as-built', 'as built', 'record drawing', 'operations manual', 'maintenance manual',
            'shop drawing', 'fabrication drawing', 'engineering', 'architect', 'consultant',
            'survey', 'surveying', 'layout', 'stakeout', 'quality control', 'quality assurance',
            'project management', 'supervision', 'oversight', 'administration', 'office',
            'temporary facility', 'temporary power', 'temporary water', 'cleanup', 'clean up',
            'waste disposal', 'storage', 'staging', 'laydown', 'crane setup', 'crane mobilization',
            'equipment rental', 'tool rental', 'scaffold rental', 'lift rental',
            'weather delay', 'holiday', 'vacation', 'break', 'lunch', 'maintenance window',
            'outage', 'energization', 'de-energization', 'lockout', 'tagout', 'loto',
            'permit to work', 'hot work permit', 'confined space', 'fall protection'
        ];

        // Sample data for different file types
        const sampleScheduleItems = {
            'schedule.p6': [
                { original: 'SOG', suggested: 'Concrete Pour', confidence: 87, trade: 'concrete' },
                { original: 'Form & Pour Foundation', suggested: 'Foundation', confidence: 92, trade: 'concrete' },
                { original: 'Steel Erection', suggested: 'Structural Steel', confidence: 95, trade: 'framing' },
                { original: 'MEP Rough', suggested: 'MEP Rough-in', confidence: 88, trade: 'electrical' },
                { original: 'Hang Board', suggested: 'Drywall Installation', confidence: 85, trade: 'drywall' }
            ],
            'project_schedule.xlsx': [
                { original: 'Site Prep', suggested: 'Site Preparation', confidence: 94, trade: 'excavation' },
                { original: 'Underground Utilities', suggested: 'Plumbing Rough-in', confidence: 82, trade: 'plumbing' },
                { original: 'Framing - Level 1', suggested: 'Framing', confidence: 96, trade: 'framing' },
                { original: 'Electric Rough', suggested: 'Electrical Rough-in', confidence: 91, trade: 'electrical' }
            ]
        };

        const nonTrackableItems = [
            'Submit RFP',
            'Order Materials',
            'Client Sign-off',
            'Permit Application',
            'Manufacturing - Windows',
            'Procurement - HVAC Units'
        ];

        // File handling
        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            
            const files = Array.from(e.dataTransfer.files);
            processFiles(files);
        }

        function handleScheduleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('dragover');
            
            const files = Array.from(e.dataTransfer.files);
            const scheduleFiles = files.filter(file => 
                file.name.toLowerCase().match(/\.(xer|csv|xlsx|xls)$/));
            
            if (scheduleFiles.length > 0) {
                processFiles(scheduleFiles);
            }
        }


        function handleDragOver(e) {
            e.preventDefault();
            e.currentTarget.classList.add('dragover');
        }

        function handleDragLeave(e) {
            e.currentTarget.classList.remove('dragover');
        }

        function processFiles(files) {
            files.forEach(file => {
                AppState.files.uploaded.push(file);
                addFileToList(file);
                
                console.log('File "' + file.name + '" stored. Click "ü§ñ AI Enhance" to begin processing.');
            });
            
            // Enable AI Enhance button if we have files
            const aiBtn = document.getElementById('aiEnhanceBtn');
            if (AppState.files.uploaded.length > 0 && aiBtn) {
                aiBtn.disabled = false;
                aiBtn.style.opacity = '1';
            }
        }

        function addFileToList(file) {
            const fileList = document.getElementById('fileList');
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            fileItem.innerHTML = 
                '<svg class="file-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">' +
                    '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>' +
                '</svg>' +
                '<span class="file-name">' + file.name + '</span>' +
                '<span class="file-remove" onclick="removeFile(' + JSON.stringify(file.name) + ')">&times;</span>';
            fileList.appendChild(fileItem);
        }

        function removeFile(fileName) {
            AppState.files.uploaded = AppState.files.uploaded.filter(f => f.name !== fileName);
            // Update UI
            const fileList = document.getElementById('fileList');
            fileList.innerHTML = '';
            AppState.files.uploaded.forEach(file => addFileToList(file));
        }

        // Template selection
        function selectTemplate(type) {
            AppState.files.selected = type;
            AppState.config.selectedBuildingType = type;
            
            document.querySelectorAll('.template-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(type + 'Template').classList.add('active');
            
            // Map UI selections to CSV project types
            const buildingTypeMapping = {
                'commercial': 'Commercial / Mixed Use',
                'datacenters': 'Data Center',
                'energy': 'Energy / Power / Water Treatment',
                'healthcare': 'Healthcare',
                'hospitality': 'Hospitality',
                'infrastructure': 'Infrastructure / Heavy Civil',
                'institutional': 'Institutional / Education',
                'manufacturing': 'Manufacturing / Industrial',
                'multifamily': 'Multi Family / Residential'
            };
            
            const csvProjectType = buildingTypeMapping[type];
            console.log('Selected building type:', type, '‚Üí CSV filter:', csvProjectType);
        }

        // Filter trades by selected building type for more accurate matching
        function getRelevantTrades() {
            if (!AppState.config.selectedBuildingType) {
                return progressAITrades; // Return all trades if no building type selected
            }
            
            const buildingTypeMapping = {
                'commercial': 'Commercial / Mixed Use',
                'datacenters': 'Data Center',
                'energy': 'Energy / Power / Water Treatment',
                'healthcare': 'Healthcare',
                'hospitality': 'Hospitality',
                'infrastructure': 'Infrastructure / Heavy Civil',
                'institutional': 'Institutional / Education',
                'manufacturing': 'Manufacturing / Industrial',
                'multifamily': 'Multi Family / Residential'
            };
            
            const targetProjectType = buildingTypeMapping[AppState.config.selectedBuildingType];
            
            // Filter trades that are applicable to the selected building type
            const relevantTrades = progressAITrades.filter(trade => {
                // For Data Centers, include any trade that mentions "Data Center" in project types
                if (AppState.config.selectedBuildingType === 'datacenters') {
                    return trade.projectTypes && trade.projectTypes.some(projectType => 
                        projectType.includes('Data Center')
                    );
                }
                
                // For other building types, include trades with no specific project types (universal trades)
                if (!trade.projectTypes || trade.projectTypes.length === 0) {
                    return true;
                }
                
                // Include trades that specifically mention this project type
                return trade.projectTypes.some(projectType => 
                    projectType.includes(targetProjectType)
                );
            });
            
            console.log('Filtered trades for ' + AppState.config.selectedBuildingType + ': ' + relevantTrades.length + ' of ' + progressAITrades.length + ' trades');
            return relevantTrades;
        }

        // Parsing real file content
        async function parseSchedule(file) {
            return new Promise((resolve, reject) => {
                const parsingContent = document.getElementById('parsingContent');
                
                // Show processing overlay
                parsingContent.innerHTML = 
                    '<div class="processing-overlay">' +
                        '<div class="spinner"></div>' +
                        '<div class="processing-text">Reading ' + file.name + '...</div>' +
                    '</div>';
            
                // Add timeout protection
                const timeout = setTimeout(() => {
                    parsingContent.innerHTML = 
                        '<div style="padding: 20px; background: #fee2e2; border-radius: 8px; color: #991b1b; margin-bottom: 16px;">' +
                            '‚è±Ô∏è File parsing timed out. File may be too large or in an unexpected format.<br>' +
                            '<small>Try a smaller file or different format.</small>' +
                        '</div>';
                    reject(new Error('Parsing timeout'));
                }, 30000); // 30 second timeout
            
            // Read the actual file content
            const reader = new FileReader();
            
            reader.onload = function(e) {
                clearTimeout(timeout); // Clear timeout on success
                
                try {
                    const content = e.target.result;
                    console.log('File size: ' + content.length + ' characters');
                    
                    // Parse based on file type
                    let extractedActivities = [];
                    
                    if (file.name.toLowerCase().endsWith('.xer')) {
                        console.log('Parsing XER file...');
                        extractedActivities = parseXERContent(content);
                    } else if (file.name.toLowerCase().endsWith('.csv') || file.name.toLowerCase().endsWith('.xlsx')) {
                        console.log('Parsing CSV file...');
                        extractedActivities = parseCSVContent(content);
                    } else {
                        console.log('Parsing generic text file...');
                        extractedActivities = parseGenericContent(content);
                    }
                    
                    console.log('Extracted ' + extractedActivities.length + ' activities');
                    
                    // Store the parsed activities but don't display yet
                    // We'll display them after AI enhancement in enhanceWithAI()
                    parsedItems = parsedItems.concat(extractedActivities.map(activity => mapActivityToTrade(activity)));
                    console.log('Parsed and stored ' + extractedActivities.length + ' activities for AI processing');
                    resolve(); // Resolve the promise when parsing is complete
                    
                } catch (error) {
                    console.error('Parsing error:', error);
                    parsingContent.innerHTML = 
                        '<div style="padding: 20px; background: #fee2e2; border-radius: 8px; color: #991b1b; margin-bottom: 16px;">' +
                            '‚ùå Error parsing file: ' + error.message + '<br>' +
                            '<small>Please check the file format and try again.</small>' +
                        '</div>';
                    reject(error); // Reject the promise on error
                }
            };
            
            reader.onerror = function() {
                clearTimeout(timeout);
                parsingContent.innerHTML = 
                    '<div style="padding: 20px; background: #fee2e2; border-radius: 8px; color: #991b1b; margin-bottom: 16px;">' +
                        '‚ùå Error reading file. Please try again.' +
                    '</div>';
                reject(new Error('File reading failed')); // Reject on file read error
            };
            
            // Read as text for schedule files
            reader.readAsText(file);
            });
        }
        
        // Parse XER file content (Enhanced from scheduleconverter)
        function parseXERContent(content) {
            console.log('Starting XER parsing...');
            const lines = content.split('\n');
            let isTaskSection = false, headers = [], taskData = [];
            let lineCount = 0;
            
            for (const line of lines) {
                lineCount++;
                if (lineCount % 1000 === 0) {
                    console.log('Processed ' + lineCount + ' lines...');
                }
                
                const trimmed = line.trim();
                if (trimmed.startsWith('%T') && trimmed.includes('TASK')) { 
                    console.log('Found TASK section at line', lineCount);
                    isTaskSection = true; 
                    continue; 
                }
                if (isTaskSection && trimmed.startsWith('%F')) { 
                    headers = trimmed.substring(3).split('\t').map(h => h.trim()); 
                    console.log('Found headers:', headers.length, 'columns');
                    continue; 
                }
                if (isTaskSection && trimmed.startsWith('%R')) {
                    const values = trimmed.substring(3).split('\t');
                    const activity = {};
                    headers.forEach((header, i) => activity[header] = values[i] ? values[i].trim() : '');
                    taskData.push(activity);
                }
                if (isTaskSection && trimmed.startsWith('%T') && !trimmed.includes('TASK')) break;
            }
            
            console.log('Found ' + taskData.length + ' task records');
            
            if (taskData.length === 0) {
                // Fallback to simpler parsing if no proper XER structure found
                console.log('No XER structure found, falling back to generic parsing');
                return parseGenericContent(content);
            }
            
            // Count tasks with > 0 duration before filtering
            const tasksWithDuration = taskData.filter(task => {
                const duration = parseFloat(task.target_drtn_hr_cnt || task.TARGET_DRTN_HR_CNT || 
                                          task.duration || task.DURATION || 
                                          task.orig_dur || task.ORIG_DUR || 0);
                return duration > 0;
            });
            const zeroFilteredCount = taskData.length - tasksWithDuration.length;
            console.log('‚ö° Smart Filtering: Filtered out ' + zeroFilteredCount + ' zero-duration tasks (milestones/admin)');
            console.log('‚ö° Smart Filtering: Processing ' + tasksWithDuration.length + ' tasks with actual work duration');
            
            // Count construction activities after WBS filtering
            const beforeWBSCount = tasksWithDuration.length;
            const constructionTasks = tasksWithDuration.filter(task => {
                const wbsCode = task.wbs_id || task.WBS_ID || task.wbs || task.WBS || 
                               task.wbs_name || task.WBS_NAME || '';
                return isConstructionActivity(wbsCode, task.task_name || task.TASK_NAME || '');
            });
            const wbsFilteredCount = beforeWBSCount - constructionTasks.length;
            
            // Fallback: if WBS filtering removes > 95% of activities, disable it
            if (constructionTasks.length < (beforeWBSCount * 0.05)) {
                console.log('üèóÔ∏è WBS Filtering: Too restrictive (' + constructionTasks.length + ' of ' + beforeWBSCount + '), using all duration-filtered tasks');
                console.log('üèóÔ∏è WBS Filtering: Processing ' + beforeWBSCount + ' activities without WBS filtering');
            } else {
                console.log('üèóÔ∏è WBS Filtering: Filtered out ' + wbsFilteredCount + ' non-construction tasks (admin/management)');
                console.log('üèóÔ∏è WBS Filtering: ' + constructionTasks.length + ' construction activities identified for AI analysis');
            }
            
            // Extract activity names from proper XER data with smart WBS filtering
            const activities = taskData
                .filter(task => {
                    // Exclude tasks with 0 duration (milestones, administrative tasks)
                    const duration = parseFloat(task.target_drtn_hr_cnt || task.TARGET_DRTN_HR_CNT || 
                                              task.duration || task.DURATION || 
                                              task.orig_dur || task.ORIG_DUR || 0);
                    
                    if (duration <= 0) return false;
                    
                    // If WBS filtering was too restrictive, skip WBS filtering
                    if (constructionTasks.length < (beforeWBSCount * 0.05)) {
                        return true; // Only duration filter
                    }
                    
                    // Otherwise apply WBS construction activity filtering
                    const wbsCode = task.wbs_id || task.WBS_ID || task.wbs || task.WBS || 
                                   task.wbs_name || task.WBS_NAME || '';
                    
                    // Check if WBS suggests construction activity (exclude admin/management codes)
                    const isConstructionWBS = isConstructionActivity(wbsCode, task.task_name || task.TASK_NAME || '');
                    
                    return isConstructionWBS;
                })
                .map(task => {
                    // Extract activity name and date information
                    const activityName = task.task_name || task.TASK_NAME || task.name || task.NAME || 
                                        task.activity_name || task.ACTIVITY_NAME || task.task_id || task.TASK_ID || '';
                    
                    // Extract start date (try multiple field names)
                    const startDate = task.act_start_date || task.ACT_START_DATE || 
                                     task.start_date || task.START_DATE ||
                                     task.early_start_date || task.EARLY_START_DATE ||
                                     task.target_start_date || task.TARGET_START_DATE ||
                                     task.early_start || task.EARLY_START ||
                                     task.plan_start || task.PLAN_START;
                    
                    // Extract end date (try multiple field names)
                    const endDate = task.act_end_date || task.ACT_END_DATE ||
                                   task.end_date || task.END_DATE ||
                                   task.early_end_date || task.EARLY_END_DATE ||
                                   task.target_end_date || task.TARGET_END_DATE ||
                                   task.early_end || task.EARLY_END ||
                                   task.plan_end || task.PLAN_END;
                    
                    // Extract duration
                    const duration = parseFloat(task.target_drtn_hr_cnt || task.TARGET_DRTN_HR_CNT || 
                                              task.duration || task.DURATION || 
                                              task.orig_dur || task.ORIG_DUR || 0);
                    
                    // Extract WBS for reference
                    const wbsCode = task.wbs_id || task.WBS_ID || task.wbs || task.WBS || 
                                   task.wbs_name || task.WBS_NAME || '';
                    
                    return {
                        original: activityName,
                        startDate: startDate,
                        endDate: endDate,
                        duration: duration,
                        wbs: wbsCode,
                        taskId: task.task_id || task.TASK_ID || '',
                        taskCode: task.task_code || task.TASK_CODE || ''
                    };
                })
                .filter(item => item.original && item.original.trim() && item.original !== 'Unnamed Activity' && item.original.length > 2);
            
            console.log('Extracted ' + activities.length + ' named activities');
            return activities;
        }
        
        // Parse CSV content
        function parseCSVContent(content) {
            const activities = [];
            const lines = content.split('\n');
            
            lines.forEach((line, index) => {
                if (index === 0) return; // Skip header
                const trimmed = line.trim();
                if (trimmed) {
                    // Get first column as activity name
                    const firstColumn = trimmed.split(',')[0].replace(/"/g, '');
                    if (firstColumn) {
                        activities.push(firstColumn);
                    }
                }
            });
            
            return activities;
        }
        
        // Parse generic text content
        function parseGenericContent(content) {
            const activities = [];
            const lines = content.split('\n');
            
            lines.forEach(line => {
                const trimmed = line.trim();
                if (trimmed && trimmed.length > 3 && trimmed.length < 200) {
                    activities.push(trimmed);
                }
            });
            
            return activities;
        }
        
        // Display parsed results with AI suggestions
        function displayParsedResults(extractedActivities, fileName) {
            const parsingContent = document.getElementById('parsingContent');
            
            if (extractedActivities.length === 0) {
                parsingContent.innerHTML = 
                    '<div style="padding: 20px; background: #fef3c7; border-radius: 8px; color: #92400e; margin-bottom: 16px;">' +
                        '‚ö†Ô∏è No activities found in ' + fileName + '. File may be in an unexpected format. Showing sample data instead.' +
                    '</div>';
                // Fall back to realistic sample data based on actual construction schedules
                extractedActivities = [
                    'Excavation and Site Preparation',
                    'Foundation Formwork',
                    'Foundation Rebar Installation', 
                    'Foundation Concrete Pour',
                    'Backfill and Compaction',
                    'Structural Steel Erection',
                    'Metal Deck Installation',
                    'Concrete Slab Pour - Level 1',
                    'Masonry Work',
                    'Roofing Installation',
                    'Electrical Rough-In',
                    'Plumbing Rough-In', 
                    'HVAC Ductwork Installation',
                    'Drywall Installation',
                    'Electrical Finish Work',
                    'Plumbing Fixture Installation',
                    'Flooring Installation',
                    'Painting',
                    'Final Electrical Testing',
                    'Submit Material Procurement Orders',
                    'Permit Application Review',
                    'Final Project Documentation'
                ];
            }
            
            // Use global excludeKeywords array
            
            // Filter out non-trackable activities before processing
            const trackableActivities = extractedActivities.filter(activity => {
                const activityText = activity.toLowerCase();
                return !excludeKeywords.some(keyword => activityText.includes(keyword));
            });
            
            // The excluded items are the difference
            const nonTrackable = extractedActivities.filter(activity => {
                const activityText = activity.toLowerCase();
                return excludeKeywords.some(keyword => activityText.includes(keyword));
            });
            
            excludedItems = [...excludedItems, ...nonTrackable];
            
            // Only map trackable activities to trades (not all extracted activities)
            parsedItems = trackableActivities.map(activity => {
                return mapActivityToTrade(activity);
            });
            
            // Show success message with actual count (after variables are defined)
            if (extractedActivities.length > 0) {
                const successMsg = document.createElement('div');
                successMsg.style.cssText = 'background: #10b981; color: white; padding: 12px; border-radius: 6px; margin-bottom: 16px; font-size: 14px;';
                successMsg.innerHTML = '‚úì Successfully extracted ' + extractedActivities.length + ' activities from ' + fileName + '<br>' +
                                       '<small style="opacity: 0.9;">‚Üí ' + trackableActivities.length + ' trackable activities, ' + nonTrackable.length + ' excluded</small>';
                parsingContent.innerHTML = '';
                parsingContent.appendChild(successMsg);
            }
            
            // Render the actual parsed items
            renderParsedItems();
            updateExcludedSection();
            updateGanttChart();
        }
        
        // Smart WBS and Activity Filtering Function
        function isConstructionActivity(wbsCode, activityName) {
            const wbs = (wbsCode || '').toLowerCase();
            const name = (activityName || '').toLowerCase();
            
            // Definitely exclude these WBS codes (administrative/management)
            const excludeWBS = [
                'admin', 'mgmt', 'management', 'overhead', 'project', 'planning', 'design',
                'procurement', 'approval', 'review', 'meeting', 'coordination', 'schedule',
                'submittal', 'rfi', 'rfp', 'permit', 'inspection', 'testing', 'closeout',
                'mobilization', 'demobilization', 'office', 'supervision', 'quality',
                'safety', 'training', 'temporary', 'laydown', 'storage'
            ];
            
            // Check if WBS contains excluded terms
            if (excludeWBS.some(exclude => wbs.includes(exclude) || name.includes(exclude))) {
                return false;
            }
            
            // Definitely include these WBS construction indicators
            const constructionWBS = [
                'concrete', 'steel', 'framing', 'electrical', 'mechanical', 'plumbing',
                'hvac', 'fire', 'insulation', 'drywall', 'painting', 'flooring', 'roofing',
                'excavation', 'foundation', 'structure', 'envelope', 'finishes', 'equipment',
                'piping', 'ductwork', 'conduit', 'rebar', 'formwork', 'masonry', 'cladding',
                'sitework', 'earthwork', 'utilities', 'install', 'placement', 'rough',
                'finish', 'prime', 'pour', 'erect', 'frame', 'deck', 'slab', 'wall',
                'ceiling', 'overhead', 'underground', 'vapor', 'barrier', 'membrane'
            ];
            
            // Check if WBS or activity name contains construction terms
            const hasConstructionTerms = constructionWBS.some(term => 
                wbs.includes(term) || name.includes(term)
            );
            
            // Check against our known trade keywords from Progress AI database
            const progressAIKeywords = [
                'tank', 'mechanical', 'yard', 'equipment', 'generator', 'concrete', 'foundation',
                'vapor', 'barrier', 'fire', 'protection', 'sprinkler', 'electrical', 'rough',
                'excavation', 'plumbing', 'batterboard', 'rebar', 'pour', 'wall', 'painting',
                'framing', 'insulation', 'roofing', 'structural', 'steel', 'duct', 'formwork',
                'metal', 'deck', 'membrane', 'pile', 'conduit', 'tilt-up', 'panel', 'ceiling'
            ];
            
            const hasProgressAITerms = progressAIKeywords.some(keyword => 
                name.includes(keyword) || wbs.includes(keyword)
            );
            
            // If no WBS code, rely on activity name analysis
            if (!wbs || wbs.length < 3) {
                return hasConstructionTerms || hasProgressAITerms;
            }
            
            // Include if it has construction or Progress AI terms
            // Remove WBS depth check as it might be too restrictive
            return hasConstructionTerms || hasProgressAITerms;
        }
        
        // Test function to demonstrate universal grouping patterns
        function testUniversalGrouping() {
            const testActivities = [
                "ASP Install - Rows, HA 14",
                "ASP Install - Rows, HA 18", 
                "Cable Tray Install - Level 1",
                "Cable Tray Install - Level 2",
                "Cable Tray Install - Level 3",
                "Conduit Install Room 101",
                "Conduit Install Room 205",
                "Concrete Pour Phase 1",
                "Concrete Pour Phase 2", 
                "Electrical Panel Type A",
                "Electrical Panel Type B",
                "Roofing Install Building A",
                "Roofing Install Building B",
                "HVAC Duct Zone 1",
                "HVAC Duct Zone 2",
                "Plumbing Rough El. 100.0",
                "Plumbing Rough El. 110.5"
            ];
            
            console.log("üß™ Universal Grouping Test Results:");
            testActivities.forEach(activity => {
                const normalized = normalizeActivityName(activity);
                                console.log('  "' + activity + '" ‚Üí "' + normalized + '"');
            });
        }
        
        // Call test in dev mode
        if (window.location.hostname === 'localhost') {
            setTimeout(() => testUniversalGrouping(), 1000);
        }

        // Enhanced Activity Normalization Functions - Universal for ALL activity types
        // Zone Detection Function
        function detectZone(activityName) {
            if (!activityName) return null;
            
            const searchText = activityName.toLowerCase();
            let bestMatch = null;
            let bestScore = 0;
            
            // Check each zone for keyword matches
            for (const [zoneName, zoneData] of Object.entries(dataCenterZones)) {
                for (const keyword of zoneData.keywords) {
                    if (searchText.includes(keyword)) {
                        const score = keyword.length; // Longer keyword = more specific = higher score
                        if (score > bestScore) {
                            bestMatch = zoneName;
                            bestScore = score;
                        }
                    }
                }
            }
            
            return bestMatch;
        }

        function normalizeActivityName(activityName) {
            if (!activityName) return '';
            
            // Remove location codes, numbers, and normalize patterns - COMPREHENSIVE approach
            let normalized = activityName
                // Location codes: "HA 14", "HA 18", "Room 101", "Space A", "Unit 5", etc.
                .replace(/\b(HA|ROOM|RM|ZONE|AREA|FLOOR|FL|LEVEL|LVL|SPACE|UNIT|BAY|SUITE)\s+[A-Z0-9]+\w*\b/gi, '[LOCATION]')
                // Building codes: "Building A", "Wing B", "Tower 1", "Block C"
                .replace(/\b(BUILDING|BLDG|WING|TOWER|BLOCK|STRUCTURE|BLDG)\s+[A-Z0-9]+\b/gi, '[BUILDING]')
                // Grid references: "Grid A1", "A-1", "1-A", "A1", "B2", etc.
                .replace(/\b(GRID\s+)?[A-Z]\d+\b/gi, '[GRID]')
                .replace(/\b\d+-[A-Z]\b/gi, '[GRID]')
                .replace(/\b[A-Z]-\d+\b/gi, '[GRID]')
                // Row/column references: "Row 1", "Column 5", "Col A"
                .replace(/\b(ROW|COLUMN|COL|LINE)\s+[A-Z0-9]+\b/gi, '[ROW]')
                // Elevation/height references: "El. 100", "Elevation 50", "+25.0", "-10.5"
                .replace(/\b(EL|ELEVATION|ELEV)\.?\s*[+-]?\d+\.?\d*\b/gi, '[ELEVATION]')
                .replace(/\b[+-]\d+\.?\d*['"]?\s*(FT|FEET|M|METER)?\b/gi, '[ELEVATION]')
                // Phase/sequence numbers: "Phase 1", "Stage 2", "Seq 3"
                .replace(/\b(PHASE|STAGE|SEQUENCE|SEQ|STEP)\s+\d+\b/gi, '[PHASE]')
                // Generic numbered items: "Item 1", "Type A", "Model 5"
                .replace(/\b(ITEM|TYPE|MODEL|VERSION|VER|REV)\s+[A-Z0-9]+\b/gi, '[TYPE]')
                // Specific instance numbers at end: "Install - 1", "Remove - 2"
                .replace(/\s+-\s*\d+\s*$/gi, '')
                // Dates and times: "Jan 15", "2024", "8:00 AM"
                .replace(/\b(JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)\s+\d{1,2}\b/gi, '[DATE]')
                .replace(/\b20\d{2}\b/gi, '[YEAR]')
                .replace(/\b\d{1,2}:\d{2}\s*(AM|PM)?\b/gi, '[TIME]')
                // Standalone numbers and codes: "Cable Tray 001", "Conduit 123"
                .replace(/\s+\d{3,}/g, ' [NUMBER]')
                .replace(/\s+[A-Z]\d{2,}/g, ' [CODE]')
                // Quantity indicators: "2x", "3 EA", "5 EACH"
                .replace(/\b\d+x\b/gi, '[QTY]')
                .replace(/\b\d+\s*(EA|EACH|PCS|PIECES|NOS|NUMBER)\b/gi, '[QTY]')
                // Direction/orientation: "North", "East", "Left", "Right"
                .replace(/\b(NORTH|SOUTH|EAST|WEST|LEFT|RIGHT|TOP|BOTTOM|UPPER|LOWER)\b/gi, '[DIRECTION]')
                // Size/dimension: "4", "6", "12", when isolated
                .replace(/\b\d{1,2}"\b/gi, '[SIZE]')
                .replace(/\b\d{1,2}\s*x\s*\d{1,2}\b/gi, '[DIMENSION]')
                // Clean up multiple spaces, punctuation, and normalize
                .replace(/[,.\-_#]+/g, ' ')
                .replace(/\s+/g, ' ')
                .trim()
                .toLowerCase();
                
            return normalized;
        }

        function findSimilarActivities(activities) {
            const groups = new Map();
            
            activities.forEach((activity, index) => {
                const normalized = normalizeActivityName(activity.original);
                
                if (!groups.has(normalized)) {
                    groups.set(normalized, []);
                }
                groups.get(normalized).push({
                    ...activity,
                    originalIndex: index,
                    normalizedName: normalized
                });
            });
            
            // Find groups with multiple items
            const similarGroups = [];
            for (const [normalized, items] of groups) {
                if (items.length > 1) {
                    similarGroups.push({
                        pattern: normalized,
                        activities: items,
                        count: items.length
                    });
                }
            }
            
            return similarGroups;
        }

        function applyConsistentMapping(activities) {
            const similarGroups = findSimilarActivities(activities);
            console.log('üîç Consistency Check: Found ' + similarGroups.length + ' groups of similar activities');
            
            // Apply consistent mapping within each group
            similarGroups.forEach((group, groupIndex) => {
                if (group.count > 1) {
                    console.log('üîÑ Group ' + (groupIndex + 1) + ': Normalizing ' + group.count + ' similar activities ‚Üí "' + group.pattern + '"');
                    
                    // Log the actual activities in this group
                    group.activities.forEach((activity, activityIndex) => {
                        if (activityIndex < 3) console.log('    ‚Ä¢ "' + activity.original + '" (confidence: ' + (activity.confidence || 0) + '%)');
                        else if (activityIndex === 3 && group.activities.length > 3) console.log('    ‚Ä¢ ... and ' + (group.activities.length - 3) + ' more similar activities');
                    });
                    
                    // Find the best match among the group (highest confidence)
                    const bestMatch = group.activities.reduce((best, current) => 
                        (current.confidence || 0) > (best.confidence || 0) ? current : best
                    );
                    
                    // Apply the best match to all items in the group
                    group.activities.forEach(activity => {
                        if (activity.originalIndex !== bestMatch.originalIndex && bestMatch.confidence > 0) {
                            const originalActivity = activities[activity.originalIndex];
                            activities[activity.originalIndex] = {
                                ...originalActivity,
                                suggested: bestMatch.suggested,
                                confidence: Math.max(bestMatch.confidence - 5, 70), // Slightly lower confidence for consistency
                                trade: bestMatch.trade,
                                tradeId: bestMatch.tradeId,
                                category: bestMatch.category,
                                accuracy: bestMatch.accuracy,
                                status: bestMatch.status,
                                aiReasoning: 'Applied consistent mapping based on similar activity: "' + bestMatch.original + '". ' + bestMatch.aiReasoning,
                                aiAlternatives: bestMatch.aiAlternatives,
                                consistentMapping: true
                            };
                            console.log('  ‚úì Applied "' + bestMatch.suggested + '" to "' + originalActivity.original + '"');
                        }
                    });
                }
            });
            
            return activities;
        }

        // Smart Keyword-Based Batching System
        function createKeywordBasedBatches(activities) {
            const batchGroups = new Map();
            
            // Group activities by normalized patterns + zone (NO SIZE LIMITS!)
            activities.forEach(activity => {
                const normalized = normalizeActivityName(activity.original);
                const detectedZone = detectZone(activity.original);
                const groupKey = detectedZone ? (normalized + '|' + detectedZone) : normalized;
                
                if (!batchGroups.has(groupKey)) {
                    batchGroups.set(groupKey, []);
                }
                batchGroups.get(groupKey).push({
                    ...activity,
                    pattern: normalized,
                    detectedZone: detectedZone,
                    groupKey: groupKey
                });
            });
            
            const batches = [];
            
            // Create consistent batches with AI-safe size limits
            const maxSafeSize = CONFIG.AI.BATCH_SIZE;
            
            for (const [pattern, items] of batchGroups) {
                if (items.length > 1) {
                    // Split large groups into manageable chunks while maintaining consistency
                    if (items.length <= maxSafeSize) {
                        // Small group - process all together
                        items.batchType = 'similar_activities';
                        items.pattern = pattern;
                        batches.push(items);
                    } else {
                        // Large group - split but mark for consistency processing
                        for (let i = 0; i < items.length; i += maxSafeSize) {
                            const batch = items.slice(i, i + maxSafeSize);
                            batch.batchType = 'similar_activities_large_group';
                            batch.pattern = pattern;
                            batch.groupSize = items.length; // Track original group size
                            batch.batchNumber = Math.floor(i / maxSafeSize) + 1;
                            batch.totalBatches = Math.ceil(items.length / maxSafeSize);
                            batches.push(batch);
                        }
                    }
                } else {
                    // Single items will be combined into one mixed batch
                    items[0].batchType = 'mixed';
                    batches.push(items);
                }
            }
            
            // Combine ALL single items into ONE mixed batch
            const singleItems = batches.filter(batch => batch.length === 1).flat();
            const groupedBatches = batches.filter(batch => batch.length > 1);
            
            if (singleItems.length > 0) {
                singleItems.batchType = 'mixed';
                singleItems.pattern = 'mixed_activities';
                groupedBatches.push(singleItems);
            }
            
            return groupedBatches;
        }

        // Learning System Functions
        async function loadLearningDatabase() {
            try {
                const response = await fetch('ai_learning_database.csv');
                if (response.ok) {
                    const csvContent = await response.text();
                    learningDatabase = parseCSVLearningData(csvContent);
                    console.log('üìö Learning Database: Loaded ' + learningDatabase.length + ' rejected mappings');
                } else {
                    console.log('üìö Learning Database: No existing database found, starting fresh');
                    learningDatabase = [];
                }
            } catch (error) {
                console.log('üìö Learning Database: Starting with empty database');
                learningDatabase = [];
            }
        }

        function parseCSVLearningData(csvContent) {
            const lines = csvContent.trim().split('\n');
            if (lines.length <= 1) return []; // No data or just headers
            
            const data = [];
            for (let i = 1; i < lines.length; i++) { // Skip header
                const values = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
                if (values.length >= 6) {
                    data.push({
                        activityName: values[0],
                        rejectedTrade: values[1],
                        rejectedTradeId: values[2],
                        buildingType: values[3],
                        rejectionReason: values[4],
                        timestamp: values[5]
                    });
                }
            }
            return data;
        }

        function saveLearningDatabase() {
            const csvHeader = 'Activity Name,Rejected Trade,Rejected Trade ID,Building Type,Rejection Reason,Timestamp\n';
            const csvRows = learningDatabase.map(entry => 
                '"' + entry.activityName + '","' + entry.rejectedTrade + '","' + entry.rejectedTradeId + '","' + entry.buildingType + '","' + entry.rejectionReason + '","' + entry.timestamp + '"'
            ).join('\n');
            
            const csvContent = csvHeader + csvRows;
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ai_learning_database.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log('üìö Learning Database: Saved ' + learningDatabase.length + ' rejected mappings to CSV');
        }

        function addRejectionToLearning(activityName, rejectedTrade, rejectedTradeId, rejectionReason = 'User rejection') {
            const entry = {
                activityName: activityName,
                rejectedTrade: rejectedTrade,
                rejectedTradeId: rejectedTradeId,
                buildingType: AppState.config.selectedBuildingType || 'Unknown',
                rejectionReason: rejectionReason,
                timestamp: new Date().toISOString()
            };
            
            // Check if this rejection already exists
            const exists = learningDatabase.some(existing => 
                existing.activityName.toLowerCase() === activityName.toLowerCase() &&
                existing.rejectedTrade === rejectedTrade &&
                existing.buildingType === entry.buildingType
            );
            
            if (!exists) {
                learningDatabase.push(entry);
                console.log('üìö Learning: Added rejection for "' + activityName + '" ‚Üí "' + rejectedTrade + '"');
                saveLearningDatabase(); // Auto-save after each rejection
            }
        }

        function checkLearningDatabase(activityName, suggestedTrade, suggestedTradeId) {
            // Check if this mapping was previously rejected
            const rejection = learningDatabase.find(entry => 
                entry.activityName.toLowerCase() === activityName.toLowerCase() &&
                entry.rejectedTrade === suggestedTrade &&
                entry.buildingType === (AppState.config.selectedBuildingType || 'Unknown')
            );
            
            if (rejection) {
                console.log('üìö Learning: Blocking previously rejected mapping "' + activityName + '" ‚Üí "' + suggestedTrade + '"');
                return {
                    blocked: true,
                    reason: 'Previously rejected: ' + rejection.rejectionReason
                };
            }
            
            return { blocked: false };
        }
        
        // Progress AI Standard Trades List - Updated from latest CSV with accurate project types
        const progressAITrades = [
            // Data Center Specific Trades (ID 69, 47, 99, 109, 87, 112, 39, 114, 113, 48, 56, 108)
            { id: 69, category: 'Specialty Equipment / Misc.', trade: 'Tank Installation', accuracy: 100, status: 'GA', type: 'Interior', stages: ['1 - Site Preparation'], projectTypes: ['Energy / Power / Water Treatment'], keywords: ['tank', 'installation', 'steel', 'shell', 'cylindrical', 'roof', 'welds'] },
            { id: 47, category: 'Equipment Placement', trade: 'Mechanical Yard - Equipment Placement', accuracy: 100, status: 'GA', type: 'Exterior', stages: [], projectTypes: ['Data Center'], keywords: ['mechanical', 'yard', 'equipment', 'placement', 'cooling', 'units', 'cable', 'trays', 'conduit', 'fans', 'cables', 'piping', 'wiring'] },
            { id: 99, category: 'Equipment Placement', trade: 'Generator Placement', accuracy: 97, status: 'GA', type: 'Interior', stages: [], projectTypes: ['Data Center'], keywords: ['generator', 'placement', 'units', 'pads', 'staged', 'installed', 'seated'] },
            { id: 109, category: 'Masonry / Roofing / Cladding', trade: 'Roofing', accuracy: 88, status: 'Beta', type: 'Exterior', stages: ['4 - Building Envelope'], projectTypes: ['Data Center'], keywords: ['roof', 'roofing', 'framing', 'decking', 'underlayment', 'material', 'flashings', 'penetrations', 'sealed'] },
            { id: 87, category: 'Concrete', trade: 'Concrete Formwork', accuracy: 83, status: 'Beta', type: 'Exterior', stages: ['1 - Site Preparation', '2 - Superstructure'], projectTypes: ['Data Center'], keywords: ['concrete', 'formwork', 'panels', 'framing', 'molds', 'rebar', 'enclosed'] },
            { id: 112, category: 'Masonry / Roofing / Cladding', trade: 'Roofing Metal Deck', accuracy: 81, status: 'Beta', type: 'Interior', stages: ['4 - Building Envelope'], projectTypes: ['Data Center'], keywords: ['roofing', 'metal', 'deck', 'installation', 'decking', 'panels', 'steel', 'framing'] },
            { id: 39, category: 'Masonry / Exterior', trade: 'Structural Steel', accuracy: 77, status: 'Alpha', type: 'Interior', stages: [], projectTypes: ['Data Center'], keywords: ['structural', 'steel', 'installation', 'framing', 'frame', 'vertical', 'horizontal', 'exterior', 'walls'] },
            { id: 114, category: 'Masonry / Roofing / Cladding', trade: 'Roofing Membrane', accuracy: 76, status: 'Alpha', type: 'Interior', stages: [], projectTypes: ['Data Center'], keywords: ['roofing', 'membrane', 'waterproofing', 'installation', 'sections', 'covered', 'continuous', 'coverage', 'sealed'] },
            { id: 113, category: 'Masonry / Roofing / Cladding', trade: 'Roofing Insulation', accuracy: 75, status: 'Alpha', type: 'Interior', stages: [], projectTypes: ['Data Center'], keywords: ['roofing', 'insulation', 'installation', 'partially', 'installed', 'visible', 'roof'] },
            { id: 48, category: 'Equipment Placement', trade: 'Electrical Yard ‚Äì Equipment Placement', accuracy: 75, status: 'Alpha', type: 'Exterior', stages: [], projectTypes: ['Data Center'], keywords: ['electrical', 'yard', 'equipment', 'placement', 'transformers', 'pads', 'conduit', 'cabling', 'units', 'cables', 'conduits', 'steel', 'framing'] },
            { id: 56, category: 'Sitework / Earthwork', trade: 'Structural Piles', accuracy: 72, status: 'Alpha', type: 'Interior', stages: [], projectTypes: ['Data Center'], keywords: ['structural', 'pile', 'installation', 'ground', 'excavation', 'drilled', 'holes', 'beams', 'concrete', 'pad'] },
            { id: 108, category: 'Electrical', trade: 'Electrical Yard Equipment Conduit', accuracy: 0, status: 'Alpha', type: 'Exterior', stages: [], projectTypes: ['Data Center'], keywords: ['electrical', 'yard', 'equipment', 'conduit', 'installation', 'pads', 'undeveloped', 'runs', 'staged', 'secured', 'incomplete', 'aligned', 'finished', 'gaps'] },
            
            // Commercial / Mixed Use + Data Center + Others (Multi-project trades)
            { id: 93, category: 'Concrete', trade: 'Concrete Foundation Pour', accuracy: 96, status: 'GA', type: 'Exterior', stages: ['2 - Superstructure'], projectTypes: ['Commercial / Mixed Use', 'Data Center', 'Energy / Power / Water Treatment', 'Healthcare', 'Hospitality', 'Infrastructure / Heavy Civil', 'Institutional / Education', 'Manufacturing / Industrial', 'Multi Family / Residential', 'Other'], keywords: ['concrete', 'foundation', 'pour', 'earth', 'rebar', 'formwork', 'visible', 'partial', 'exposed', 'finished', 'uniform', 'forms', 'removed', 'joints', 'cut'] },
            { id: 33, category: 'Sitework / Earthwork', trade: 'Vapor Barrier', accuracy: 96, status: 'GA', type: 'Interior', stages: ['1 - Site Preparation'], projectTypes: ['Commercial / Mixed Use', 'Data Center', 'Energy / Power / Water Treatment', 'Healthcare', 'Hospitality', 'Infrastructure / Heavy Civil', 'Institutional / Education', 'Manufacturing / Industrial', 'Multi Family / Residential', 'Other'], keywords: ['vapor', 'barrier', 'installation', 'exposed', 'ground', 'visible', 'place', 'installed', 'secured', 'covered', 'formwork', 'grids', 'concrete'] },
            { id: 21, category: 'Fire Protection', trade: 'Overhead Fire Protection', accuracy: 96, status: 'GA', type: 'Interior', stages: ['3 - Interior Fit-Out'], projectTypes: ['Commercial / Mixed Use', 'Data Center', 'Energy / Power / Water Treatment', 'Healthcare', 'Hospitality', 'Infrastructure / Heavy Civil', 'Institutional / Education', 'Manufacturing / Industrial', 'Multi Family / Residential', 'Other'], keywords: ['overhead', 'fire', 'protection', 'ceiling', 'space', 'clear', 'sprinkler', 'pipes', 'heads', 'brackets', 'hangers', 'visible', 'piping', 'fittings', 'partially', 'installed', 'suspended', 'supports', 'evenly', 'distributed', 'finished'] },
            { id: 90, category: 'Electrical', trade: 'Overhead Electrical Rough In', accuracy: 96, status: 'GA', type: 'Interior', stages: ['3 - Interior Fit-Out'], projectTypes: ['Commercial / Mixed Use', 'Data Center', 'Energy / Power / Water Treatment', 'Healthcare', 'Hospitality', 'Infrastructure / Heavy Civil', 'Institutional / Education', 'Manufacturing / Industrial', 'Multi Family / Residential', 'Other'], keywords: ['overhead', 'electrical', 'rough', 'conduit', 'wiring', 'junction', 'boxes', 'visible', 'installed', 'connected', 'components', 'exposed', 'fixture', 'holes'] },
            { id: 30, category: 'Sitework / Earthwork', trade: 'Excavation', accuracy: 95, status: 'GA', type: 'Exterior', stages: ['1 - Site Preparation'], projectTypes: ['Commercial / Mixed Use', 'Data Center', 'Energy / Power / Water Treatment', 'Healthcare', 'Hospitality', 'Infrastructure / Heavy Civil', 'Institutional / Education', 'Manufacturing / Industrial', 'Multi Family / Residential', 'Other'], keywords: ['excavation', 'ground', 'completely', 'undisturbed', 'natural', 'vegetation', 'existing', 'surface', 'intact', 'disturbed', 'visible', 'grading', 'soil', 'piles', 'active', 'digging', 'areas', 'finished', 'design', 'grade', 'machinery', 'layout', 'markers', 'foundations', 'slabs', 'place'] },
            { id: 94, category: 'Mechanical (HVAC / Plumbing)', trade: 'Overhead Plumbing', accuracy: 95, status: 'GA', type: 'Interior', stages: ['3 - Interior Fit-Out'], projectTypes: ['Commercial / Mixed Use', 'Data Center', 'Energy / Power / Water Treatment', 'Healthcare', 'Hospitality', 'Infrastructure / Heavy Civil', 'Institutional / Education', 'Manufacturing / Industrial', 'Multi Family / Residential', 'Other'], keywords: ['overhead', 'plumbing', 'ceiling', 'clear', 'pipes', 'fittings', 'visible', 'partial', 'systems', 'installed', 'incomplete', 'piping', 'fixtures', 'connected', 'finished'] },
            { id: 31, category: 'Sitework / Earthwork', trade: 'Batterboards', accuracy: 91, status: 'Beta', type: 'Exterior', stages: ['1 - Site Preparation', '2 - Superstructure'], projectTypes: ['Commercial / Mixed Use', 'Data Center', 'Energy / Power / Water Treatment', 'Healthcare', 'Hospitality', 'Infrastructure / Heavy Civil', 'Institutional / Education', 'Manufacturing / Industrial', 'Multi Family / Residential', 'Other'], keywords: ['batterboard', 'installation', 'site', 'shows', 'bare', 'ground', 'materials', 'workers', 'machinery', 'actively', 'placing', 'long', 'sticks', 'completed', 'formwork', 'rebar', 'vapor', 'barriers', 'utility', 'pipes', 'place'] },
            { id: 88, category: 'Concrete', trade: 'Concrete Rebar', accuracy: 91, status: 'Beta', type: 'Exterior', stages: ['2 - Superstructure', '1 - Site Preparation'], projectTypes: ['Commercial / Mixed Use', 'Data Center', 'Energy / Power / Water Treatment', 'Healthcare', 'Hospitality', 'Infrastructure / Heavy Civil', 'Institutional / Education', 'Manufacturing / Industrial', 'Multi Family / Residential', 'Other'], keywords: ['concrete', 'rebar', 'installation', 'site', 'shows', 'reinforcement', 'open', 'ground', 'partially', 'placed', 'gaps', 'visible', 'fully', 'tied', 'ready', 'formwork'] },
            { id: 63, category: 'Concrete', trade: 'Concrete Pour', accuracy: 91, status: 'Beta', type: 'Exterior', stages: ['2 - Superstructure'], projectTypes: ['Commercial / Mixed Use', 'Data Center', 'Energy / Power / Water Treatment', 'Healthcare', 'Hospitality', 'Infrastructure / Heavy Civil', 'Institutional / Education', 'Manufacturing / Industrial', 'Multi Family / Residential', 'Other'], keywords: ['concrete', 'pour', 'bare', 'ground', 'rebar', 'preparation', 'visible', 'partial', 'placement', 'showing', 'areas', 'poured', 'formwork'] },
            { id: 20, category: 'Electrical', trade: 'In Wall Electrical', accuracy: 91, status: 'Beta', type: 'Interior', stages: ['3 - Interior Fit-Out'], projectTypes: ['Commercial / Mixed Use', 'Data Center', 'Energy / Power / Water Treatment', 'Healthcare', 'Hospitality', 'Infrastructure / Heavy Civil', 'Institutional / Education', 'Manufacturing / Industrial', 'Multi Family / Residential', 'Other'], keywords: ['wall', 'electrical', 'wall', 'cavities', 'empty', 'conduit', 'outlet', 'boxes', 'wiring', 'visible', 'partial', 'installation', 'incomplete', 'studs', 'conduits', 'fully', 'installed', 'drywall', 'insulation', 'enclosing', 'walls', 'components', 'missing'] },
            { id: 85, category: 'Finishes', trade: 'Wall Painting', accuracy: 91, status: 'Beta', type: 'Interior', stages: ['5 - Finishes'], projectTypes: ['Commercial / Mixed Use', 'Data Center', 'Energy / Power / Water Treatment', 'Healthcare', 'Hospitality', 'Infrastructure / Heavy Civil', 'Institutional / Education', 'Manufacturing / Industrial', 'Multi Family / Residential', 'Other'], keywords: ['wall', 'painting', 'primer', 'paint', 'applied', 'partial', 'coats', 'unfinished', 'areas', 'designated', 'surfaces', 'final', 'coat'] },
            { id: 1, category: 'Fire Protection', trade: 'Wall Framing', accuracy: 90, status: 'Beta', type: 'Interior', stages: ['3 - Interior Fit-Out'], projectTypes: ['Commercial / Mixed Use', 'Data Center', 'Energy / Power / Water Treatment', 'Healthcare', 'Hospitality', 'Infrastructure / Heavy Civil', 'Institutional / Education', 'Manufacturing / Industrial', 'Multi Family / Residential', 'Other'], keywords: ['wall', 'framing', 'installation', 'top', 'bottom', 'tracks', 'vertical', 'studs', 'installed', 'area', 'fully', 'open', 'partial', 'place', 'walls', 'incomplete', 'full', 'framing'] },
            { id: 2, category: 'Insulation', trade: 'In Wall Insulation', accuracy: 89, status: 'Beta', type: 'Interior', stages: ['3 - Interior Fit-Out'], projectTypes: ['Commercial / Mixed Use', 'Data Center', 'Energy / Power / Water Treatment', 'Healthcare', 'Hospitality', 'Infrastructure / Heavy Civil', 'Institutional / Education', 'Manufacturing / Industrial', 'Multi Family / Residential', 'Other'], keywords: ['wall', 'insulation', 'wall', 'cavities', 'fully', 'bare', 'insulation', 'present', 'partially', 'filled', 'installed', 'exposed', 'framing', 'visible'] },
            { id: 15, category: 'Mechanical (HVAC / Plumbing)', trade: 'In Wall Plumbing', accuracy: 84, status: 'Beta', type: 'Interior', stages: [], projectTypes: ['Commercial / Mixed Use', 'Data Center', 'Energy / Power / Water Treatment', 'Healthcare', 'Hospitality', 'Infrastructure / Heavy Civil', 'Institutional / Education', 'Manufacturing / Industrial', 'Multi Family / Residential', 'Other'], keywords: ['wall', 'plumbing', 'wall', 'cavities', 'empty', 'visible', 'pipes', 'valves', 'brackets', 'partial', 'installed', 'connected', 'connections', 'fully', 'secured', 'enclosed', 'drywall'] }
        ];

        // Enhanced trade mapping with Progress AI data
        function mapActivityToTrade(activityInput) {
            // Handle both string inputs (legacy) and object inputs (new)
            const activityName = typeof activityInput === 'string' ? activityInput : activityInput.original;
            const activityData = typeof activityInput === 'object' ? activityInput : { original: activityInput };
            
            if (!activityName) return { 
                trade: 'general', 
                confidence: 0, 
                suggested: activityName,
                ...activityData
            };
            
            const searchText = activityName.toLowerCase();
            
            // Detect zone for this activity
            const detectedZone = detectZone(activityName);
            
            let bestMatch = { 
                original: activityName,
                suggested: activityName,
                confidence: 0, 
                trade: 'general',
                tradeId: null, 
                category: 'General',
                accuracy: 0,
                status: 'Unknown',
                aiEnhanced: false,
                detectedZone: detectedZone,
                // Preserve date and metadata from parsing
                ...activityData
            };
            
            // Score against building-type filtered Progress AI trades list
            const relevantTrades = getRelevantTrades();
            for (const tradeData of relevantTrades) {
                let score = 0;
                
                // Check against keywords
                for (const keyword of tradeData.keywords) {
                    if (searchText.includes(keyword.toLowerCase())) {
                        score += keyword.length * 2; // Weight by keyword length
                    }
                }
                
                // Check against trade name
                const tradeName = tradeData.trade.toLowerCase();
                if (searchText.includes(tradeName)) {
                    score += tradeName.length * 3; // Higher weight for direct trade name match
                }
                
                // Zone-based confidence boost
                if (detectedZone && dataCenterZones[detectedZone]) {
                    const zonePrimaryTrades = dataCenterZones[detectedZone].primaryTrades;
                    if (zonePrimaryTrades.includes(tradeData.trade)) {
                        score += 50; // Significant boost for zone-appropriate trades
                        console.log('üéØ Zone Match: "' + tradeData.trade + '" boosted for zone "' + detectedZone + '"');
                    }
                }
                
                // Boost score based on AI accuracy
                if (score > 0) {
                    score = score * (tradeData.accuracy / 100);
                }
                
                if (score > bestMatch.confidence) {
                    const suggestedName = detectedZone ? 
                        (tradeData.trade + ' [' + detectedZone + ']') : 
                        tradeData.trade;
                        
                    bestMatch = {
                        original: activityName,
                        suggested: suggestedName,
                        confidence: Math.min(95, Math.round(score * 2)), // Scale to percentage
                        trade: tradeData.trade.toLowerCase().replace(/[^a-z0-9]/g, '_'),
                        tradeId: tradeData.id,
                        category: tradeData.category,
                        accuracy: tradeData.accuracy,
                        status: tradeData.status,
                        aiEnhanced: false,
                        detectedZone: detectedZone,
                        // Preserve date and metadata from parsing
                        ...activityData
                    };
                }
            }
            
            return bestMatch;
        }

        // AI-Enhanced activity mapping using Gemini
        // FAST: Enhanced AI processing for activity chunks (10x faster!)
        async function enhanceActivitiesChunk(activities) {
            if (!window.GeminiAPI) {
                console.warn('Gemini API not available');
                return activities;
            }

            try {
                // Get building-type specific trades for more accurate matching
                const relevantTrades = getRelevantTrades();
                const topTrades = relevantTrades.map(t => 
                    '"' + t.trade + '" (ID: ' + t.id + ', Accuracy: ' + t.accuracy + '%)'
                ).join(', ');

                // Create activities list for batch processing with zone detection
                const activitiesList = activities.map((activity, index) => {
                    const detectedZone = detectZone(activity.original);
                    const zoneInfo = detectedZone ? (' [Zone: ' + detectedZone + ']') : '';
                    return (index + 1) + '. "' + activity.original + '"' + zoneInfo;
                }).join('\n');

                const buildingContext = AppState.config.selectedBuildingType ? (' for ' + AppState.config.selectedBuildingType) : '';
                const prompt = `Match construction activities to trades. Return ONLY valid JSON array.

Activities:
${activitiesList}

Available trades: ${topTrades}

Return format - NO other text:
[{"activity_index":1,"matched_trade":"Trade name","trade_id":94,"confidence":85,"reasoning":"Brief reason"}]`;

                // Add timeout to prevent hanging
                const aiCall = window.GeminiAPI.generateContent(prompt, { 
                    temperature: CONFIG.AI.TEMPERATURE,
                    maxOutputTokens: CONFIG.AI.MAX_OUTPUT_TOKENS
                });
                
                const timeout = new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('AI call timeout after ' + CONFIG.AI.TIMEOUT_MS + 'ms')), CONFIG.AI.TIMEOUT_MS)
                );
                
                const response = await Promise.race([aiCall, timeout]);

                // Simplified JSON parsing with immediate fallback
                let aiResults = null;
                
                try {
                    // Try to extract and parse JSON with minimal processing
                    console.log('ü§ñ AI Response length: ' + response.length + ' characters');
                    
                    // Look for JSON array in response
                    const jsonMatch = response.match(/\[[\s\S]*?\]/);
                    
                    if (jsonMatch) {
                        const jsonText = jsonMatch[0]
                            .replace(/,\s*\]/g, ']')     // Remove trailing commas
                            .replace(/,\s*\}/g, '}')     // Remove trailing commas in objects
                            .trim();
                        
                        aiResults = JSON.parse(jsonText);
                        
                        // Basic validation
                        if (Array.isArray(aiResults) && aiResults.length > 0) {
                            console.log('‚úÖ Parsed ' + aiResults.length + ' AI results successfully');
                        } else {
                            console.warn(`‚ö†Ô∏è JSON array is empty or invalid, using fallback`);
                            aiResults = null;
                        }
                    } else {
                        console.warn(`‚ö†Ô∏è No JSON array found in response, using fallback`);
                    }
                } catch (parseError) {
                    console.warn(`‚ö†Ô∏è JSON parse failed: ${parseError.message}, using fallback`);
                    aiResults = null;
                }
                
                if (aiResults) {
                    
                    return activities.map((activity, index) => {
                        const aiResult = aiResults.find(r => r.activity_index === index + 1);
                        if (!aiResult) return activity;
                        
                        const relevantTrades = getRelevantTrades();
                        const matchedTrade = aiResult.trade_id ? 
                            relevantTrades.find(t => t.id === aiResult.trade_id) : null;
                        
                        if (matchedTrade && aiResult.confidence >= CONFIG.CONFIDENCE.MINIMUM_MATCH) {
                            // Check learning database before applying the match
                            const learningCheck = checkLearningDatabase(activity.original, matchedTrade.trade, matchedTrade.id);
                            
                            if (learningCheck.blocked) {
                                // This mapping was previously rejected, block it
                                return {
                                    original: activity.original,
                                    suggested: 'No Match',
                                    confidence: 0,
                                    trade: 'general',
                                    tradeId: null,
                                    category: 'Learning Blocked',
                                    accuracy: 0,
                                    status: 'Previously Rejected',
                                    aiEnhanced: true,
                                    aiReasoning: aiResult.reasoning || 'AI analysis complete',
                                    aiAlternatives: '',
                                    learningBlocked: true,
                                    learningReason: learningCheck.reason
                                };
                            }
                            
                            return {
                                original: activity.original,
                                suggested: matchedTrade.trade,
                                confidence: Math.min(99, aiResult.confidence),
                                trade: matchedTrade.trade.toLowerCase().replace(/[^a-z0-9]/g, '_'),
                                tradeId: matchedTrade.id,
                                category: matchedTrade.category,
                                accuracy: matchedTrade.accuracy,
                                status: matchedTrade.status,
                                aiEnhanced: true,
                                aiReasoning: aiResult.reasoning || 'AI analysis complete',
                                aiAlternatives: '',
                                learningBlocked: false
                            };
                        } else {
                            return {
                                original: activity.original,
                                suggested: 'No Match',
                                confidence: 0,
                                trade: 'general',
                                tradeId: null,
                                category: 'Unmatched',
                                accuracy: 0,
                                status: 'No Match',
                                aiEnhanced: true,
                                aiReasoning: aiResult.reasoning || 'No suitable match found',
                                aiAlternatives: '',
                                learningBlocked: false
                            };
                        }
                    });
                } else {
                    // Fallback: If JSON parsing completely failed, return activities with basic analysis
                    console.warn('‚ö†Ô∏è AI JSON parsing failed, using keyword matching fallback');
                    return activities.map(activity => {
                        // Use our existing keyword matching as fallback
                        const fallbackResult = mapActivityToTrade(activity);
                        return {
                            ...fallbackResult,
                            aiEnhanced: false,
                            aiReasoning: 'Fallback: AI response parsing failed, used keyword matching',
                            aiAlternatives: '',
                            confidence: Math.min(fallbackResult.confidence, CONFIG.CONFIDENCE.FALLBACK_CAP)
                        };
                    });
                }
            } catch (error) {
                console.error('‚ùå AI enhancement failed:', error.message);
                
                // Complete fallback: return activities with basic keyword matching
                return activities.map(activity => {
                    try {
                        const fallbackResult = mapActivityToTrade(activity);
                        return {
                            ...fallbackResult,
                            aiEnhanced: false,
                            aiReasoning: `Error fallback: ${error.message.substring(0, 50)}`,
                            aiAlternatives: '',
                            confidence: Math.min(fallbackResult.confidence, CONFIG.CONFIDENCE.ERROR_FALLBACK_CAP)
                        };
                    } catch (fallbackError) {
                        // Ultimate fallback if even keyword matching fails
                        console.error('‚ùå Even fallback failed:', fallbackError.message);
                        return {
                            original: activity.original || 'Unknown Activity',
                            suggested: 'Processing Error',
                            confidence: 0,
                            trade: 'error',
                            tradeId: null,
                            category: 'Error',
                            accuracy: 0,
                            status: 'Error',
                            aiEnhanced: false,
                            aiReasoning: 'Complete processing failure',
                            aiAlternatives: ''
                        };
                    }
                });
            }
            
            return activities; // Fallback
        }

        // Legacy: Individual activity processing (kept for fallback)
        async function enhanceActivityWithAI(activity) {
            if (!window.GeminiAPI) {
                console.warn('Gemini API not available');
                return activity;
            }

            try {
                // Create comprehensive trades list for AI to match against (filtered by building type)
                const relevantTrades = getRelevantTrades();
                const tradesList = relevantTrades.map(t => {
                    const stages = t.stages && t.stages.length > 0 ? t.stages.join(', ') : 'Various stages';
                    const projectTypes = t.projectTypes && t.projectTypes.length > 0 ? 
                        (t.projectTypes.length > 3 ? 'All project types' : t.projectTypes.join(', ')) : 'All project types';
                    return `"${t.trade}" (ID: ${t.id}, Category: ${t.category}, Accuracy: ${t.accuracy}%, Stages: ${stages}, Projects: ${projectTypes})`;
                }).join('\n');

                const prompt = `You are a construction expert analyzing schedule activities. Match this activity to the most appropriate trade from the Progress AI Standard Trades List using enhanced project context.

ACTIVITY TO ANALYZE: "${activity.original}"

ENHANCED PROGRESS AI TRADES DATABASE:
${tradesList}

INTELLIGENT MATCHING INSTRUCTIONS:
1. Systematically compare the activity against each trade considering:
   - Keywords and terminology
   - Trade categories and subcategories  
   - Construction stages (Site Preparation ‚Üí Superstructure ‚Üí Interior Fit-Out ‚Üí Building Envelope ‚Üí Finishes)
   - Project type applicability
   - Visual trackability on construction sites
2. Higher accuracy trades (GA > Beta > Alpha) are more reliable
3. If no good match exists (confidence <50%), return "No Match" for trade
4. Do NOT force a match if it's not appropriate
5. Consider construction sequencing and dependencies
6. Focus on work that can be visually tracked and measured

Please respond with JSON format:
{
  "matched_trade": "Exact trade name from list OR 'No Match'",
  "trade_id": numeric_id_or_null,
  "suggested_name": "Clean, professional activity name",
  "confidence": numeric_score_0_to_100,
  "explanation": "Brief reason for match including stage/category context"
}`;

                const response = await window.GeminiAPI.generateContent(prompt, { 
                    temperature: 0.2, // Lower temperature for more consistent matching
                    maxOutputTokens: 512 
                });
                
                // Parse JSON response
                const jsonMatch = response.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const aiResult = JSON.parse(jsonMatch[0]);
                    
                    // Validate the trade match against our list
                    let matchedTrade = null;
                    if (aiResult.trade_id) {
                        matchedTrade = relevantTrades.find(t => t.id === aiResult.trade_id);
                    }
                    
                    if (matchedTrade && aiResult.confidence >= 50) {
                        return {
                            original: activity.original,
                            suggested: aiResult.suggested_name || matchedTrade.trade,
                            confidence: Math.min(99, aiResult.confidence),
                            trade: matchedTrade.trade.toLowerCase().replace(/[^a-z0-9]/g, '_'),
                            tradeId: matchedTrade.id,
                            category: matchedTrade.category,
                            accuracy: matchedTrade.accuracy,
                            status: matchedTrade.status,
                            aiEnhanced: true,
                            aiExplanation: aiResult.explanation
                        };
                    } else {
                        // No suitable match found
                        return {
                            original: activity.original,
                            suggested: aiResult.suggested_name || activity.original,
                            confidence: 0,
                            trade: 'general',
                            tradeId: null,
                            category: 'Unmatched',
                            accuracy: 0,
                            status: 'No Match',
                            aiEnhanced: true,
                            aiExplanation: aiResult.explanation || 'No suitable trade match found'
                        };
                    }
                }
            } catch (error) {
                console.error('AI enhancement failed:', error);
            }
            
            return activity; // Return original if AI fails
        }
        
        // Enhanced trade detection (adapted from scheduleconverter)
        function detectTradeFromActivity(activityName, activityId = '', wbsCode = '') {
            const combinedText = `${activityId || ''} ${activityName || ''} ${wbsCode || ''}`.toLowerCase();
            
            // Enhanced trade keywords with scoring system
            const enhancedTradeKeywords = {
                structural_piles: {
                    keywords: ['pile', 'piling', 'caisson', 'foundation', 'deep foundation', 'driven pile', 'bored pile', 'pier'],
                    patterns: ['pile', 'found', 'caisson']
                },
                structural_steel: {
                    keywords: ['steel', 'beam', 'column', 'frame', 'erection', 'welding', 'structural steel', 'steel frame'],
                    patterns: ['steel', 'beam', 'column', 'frame', 'erect']
                },
                concrete_formwork: {
                    keywords: ['formwork', 'form', 'shoring', 'falsework', 'scaffolding', 'concrete formwork'],
                    patterns: ['form', 'shore', 'scaffold']
                },
                concrete_rebar: {
                    keywords: ['rebar', 'reinforc', 'steel reinforc', 'reinforcing', 'bar', 'concrete rebar'],
                    patterns: ['rebar', 'reinf', 'bar']
                },
                concrete_pour: {
                    keywords: ['pour', 'concrete pour', 'placement', 'slab', 'footing', 'concrete slab', 'sog'],
                    patterns: ['pour', 'slab', 'concrete', 'sog']
                },
                electrical: {
                    keywords: ['electrical', 'electric', 'power', 'lighting', 'wire', 'panel', 'conduit'],
                    patterns: ['elec', 'power', 'light', 'wire']
                },
                mechanical: {
                    keywords: ['hvac', 'mechanical', 'duct', 'air', 'heating', 'cooling', 'ventilation'],
                    patterns: ['hvac', 'mech', 'duct', 'air']
                },
                plumbing: {
                    keywords: ['plumb', 'pipe', 'water', 'sewer', 'drain', 'fixture', 'plumbing'],
                    patterns: ['plumb', 'pipe', 'water']
                },
                roofing: {
                    keywords: ['roof', 'roofing', 'shingle', 'membrane', 'flashing', 'deck'],
                    patterns: ['roof', 'membrane', 'deck']
                },
                drywall: {
                    keywords: ['drywall', 'board', 'hang', 'tape', 'mud', 'sheetrock', 'gypsum'],
                    patterns: ['drywall', 'board', 'gyp']
                }
            };
            
            let bestTrade = null;
            let highestScore = 0;
            
            for (const [tradeKey, tradeData] of Object.entries(enhancedTradeKeywords)) {
                let score = 0;
                
                // Check keywords
                for (const keyword of tradeData.keywords) {
                    if (combinedText.includes(keyword)) {
                        score += 3;
                        break;
                    }
                }
                
                // Check patterns
                for (const pattern of tradeData.patterns) {
                    if (combinedText.includes(pattern)) {
                        score += 2;
                        break;
                    }
                }
                
                if (score > highestScore) {
                    highestScore = score;
                    bestTrade = tradeKey;
                }
            }
            
            return bestTrade;
        }
        
        // Translate trade codes to readable names
        function getTradeName(tradeCode) {
            const tradeNameMap = {
                'concrete_formwork': 'Concrete Formwork',
                'concrete_rebar': 'Concrete Rebar', 
                'concrete_pour': 'Concrete Pour',
                'structural_piles': 'Structural Piles',
                'structural_steel': 'Structural Steel',
                'electrical': 'Electrical Installation',
                'mechanical': 'Mechanical Systems',
                'plumbing': 'Plumbing Installation',
                'roofing': 'Roofing',
                'drywall': 'Drywall Installation'
            };
            
            return tradeNameMap[tradeCode] || tradeCode;
        }
        
        // Clean up activity names
        function cleanupActivityName(original, trade) {
            // Remove common prefixes/suffixes
            let cleaned = original
                .replace(/^\d+\.?\d*\s*/, '') // Remove leading numbers
                .replace(/^[A-Z]\d+\s*/, '') // Remove codes like A1, B2
                .replace(/\s*-\s*Level\s*\d+/gi, '') // Remove level indicators
                .trim();
            
            // If too short or unclear, enhance it
            if (cleaned.length < 10 || cleaned.toUpperCase() === cleaned) {
                const tradeNames = {
                    'concrete': 'Concrete Work',
                    'framing': 'Framing',
                    'electrical': 'Electrical Installation',
                    'plumbing': 'Plumbing Installation',
                    'drywall': 'Drywall Installation',
                    'mechanical': 'Mechanical Systems',
                    'roofing': 'Roofing',
                    'flooring': 'Flooring Installation',
                    'excavation': 'Site Preparation'
                };
                
                if (cleaned.length < 5) {
                    return tradeNames[trade] || cleaned;
                }
            }
            
            // Capitalize properly
            return cleaned.charAt(0).toUpperCase() + cleaned.slice(1);
        }

        function renderParsedItems() {
            // Hide empty state
            document.getElementById('parsingEmptyState').style.display = 'none';
            document.getElementById('loadingState').style.display = 'none';
            
            // Separate items by status
            const acceptedItems = parsedItems.filter(item => item.userAction === 'accepted');
            const rejectedItems = parsedItems.filter(item => item.userAction === 'rejected');
            const pendingItems = parsedItems.filter(item => !item.userAction && item.confidence > 0);
            const excludedItems = parsedItems.filter(item => item.confidence === 0);
            
            // Sort pending items by confidence (highest first)
            pendingItems.sort((a, b) => b.confidence - a.confidence);
            
            // Update section visibility and counts
            updateSection('acceptedSection', 'acceptedItems', 'acceptedCount', acceptedItems);
            updateSection('rejectedSection', 'rejectedItems', 'rejectedItemsCount', rejectedItems);
            updateSection('pendingSection', 'pendingItems', 'pendingCount', pendingItems);
            updateSection('excludedSection', 'excludedItems', 'excludedCount', excludedItems);
        }
        
        function updateSection(sectionId, containerId, countId, items) {
            const section = document.getElementById(sectionId);
            const container = document.getElementById(containerId);
            const countSpan = document.getElementById(countId);
            
            if (items.length > 0) {
                section.style.display = 'block';
                countSpan.textContent = items.length;
                container.innerHTML = '';
                
                items.forEach((item, index) => {
                    const originalIndex = parsedItems.indexOf(item);
                    const itemDiv = createParsingItemElement(item, originalIndex, index);
                    container.appendChild(itemDiv);
                });
            } else {
                section.style.display = 'none';
            }
        }
        
        function createParsingItemElement(item, originalIndex, displayIndex) {
            const confidenceClass = item.confidence >= 90 ? 'confidence-high' : 
                                   item.confidence >= 70 ? 'confidence-medium' : 'confidence-low';
            
            const itemDiv = document.createElement('div');
            itemDiv.className = 'parsing-item';
            
            // Different styling based on status
            let statusStyle = '';
            let actionButtons = '';
            
            if (item.userAction === 'accepted') {
                statusStyle = 'background: #f0f9ff; border-left: 4px solid #10b981;';
                actionButtons = `<span style="color: #10b981; font-weight: 600;">‚úÖ Accepted</span>`;
            } else if (item.userAction === 'rejected') {
                statusStyle = 'background: #fef2f2; border-left: 4px solid #dc2626;';
                actionButtons = `<span style="color: #dc2626; font-weight: 600;">‚ùå Rejected</span>`;
            } else if (item.confidence === 0) {
                statusStyle = 'background: #f9fafb; border-left: 4px solid #6b7280;';
                actionButtons = `<span style="color: #6b7280; font-weight: 600;">üö´ Excluded</span>`;
            } else {
                // Pending items
                statusStyle = 'background: #fffbeb; border-left: 4px solid #f59e0b;';
                actionButtons = `
                    <button onclick="acceptMapping(${originalIndex})" style="background: #10b981; color: white; border: none; padding: 6px 12px; border-radius: 4px; margin-right: 8px; cursor: pointer;">Accept</button>
                    <button onclick="rejectMapping(${originalIndex})" style="background: #dc2626; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer;">Reject</button>
                `;
            }
            
            // AI Reasoning Display
            const aiReasoning = item.aiReasoning ? `
                <div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 6px; padding: 8px; margin-top: 8px;">
                    <div style="font-size: 11px; font-weight: 600; color: #1e293b; margin-bottom: 4px;">üß† AI Reasoning:</div>
                    <div style="font-size: 11px; color: #475569; line-height: 1.4;">${item.aiReasoning}</div>
                    ${item.aiAlternatives ? `<div style="font-size: 10px; color: #64748b; margin-top: 4px;"><strong>Alternatives considered:</strong> ${item.aiAlternatives}</div>` : ''}
                </div>
            ` : '';
            
            // Rank badge for pending items
            const rankBadge = item.userAction ? '' : `<span style="background: #3b82f6; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-right: 8px;">#${displayIndex + 1}</span>`;
            
            itemDiv.innerHTML = `
                <div style="padding: 12px; border-radius: 8px; ${statusStyle}">
                    <div style="display: flex; justify-content: between; align-items: start; margin-bottom: 8px;">
                        <div style="flex: 1;">
                            <div style="font-weight: 600; margin-bottom: 4px;">
                                ${rankBadge}${item.original}
                            </div>
                            <div style="color: #6b7280; font-size: 14px; margin-bottom: 8px;">
                                ‚Üí <span style="color: #059669; font-weight: 500;">${item.suggested}</span>
                                ${item.confidence > 0 ? `<span class="${confidenceClass}" style="margin-left: 12px; padding: 2px 6px; border-radius: 3px; font-size: 11px; font-weight: 600;">${item.confidence}% confidence</span>` : ''}
                            </div>
                        </div>
                        <div style="margin-left: 12px;">
                            ${actionButtons}
                        </div>
                    </div>
                    ${aiReasoning}
                </div>
            `;
            
            return itemDiv;
        }
                    <div style="background: #f0fdf4; border: 1px solid #22c55e; border-radius: 8px; padding: 12px; margin-bottom: 16px;">
                        <h3 style="margin: 0; color: #15803d; font-size: 14px; font-weight: 600;">
                            üìã Trackable Activities (${includedItems.length}) - Ranked by Confidence
                        </h3>
                        <p style="margin: 4px 0 0 0; color: #16a34a; font-size: 12px;">These activities will appear in your Gantt chart</p>
                    </div>
                `;
                parsingContent.appendChild(includedHeader);
                
                // Render included items
                includedItems.forEach((item, index) => {
                    const originalIndex = parsedItems.indexOf(item);
                    const confidenceClass = item.confidence >= 90 ? 'confidence-high' : 
                                           item.confidence >= 70 ? 'confidence-medium' : 'confidence-low';
                    
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'parsing-item';
                    
                    // AI Reasoning Display
                    const aiReasoning = item.aiReasoning ? 
                        '<div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 6px; padding: 8px; margin-top: 8px;">' +
                            '<div style="font-size: 11px; font-weight: 600; color: #1e293b; margin-bottom: 4px;">' + (item.consistentMapping ? 'üîÑ' : 'üß†') + ' ' + (item.consistentMapping ? 'Consistency Applied:' : 'AI Reasoning:') + '</div>' +
                            '<div style="font-size: 11px; color: #475569; line-height: 1.4;">' + item.aiReasoning + '</div>' +
                            (item.aiAlternatives ? '<div style="font-size: 10px; color: #64748b; margin-top: 4px;"><strong>Alternatives considered:</strong> ' + item.aiAlternatives + '</div>' : '') +
                            (item.learningBlocked ? '<div style="font-size: 10px; color: #dc2626; margin-top: 4px; background: #fef2f2; padding: 4px; border-radius: 3px;"><strong>‚ö†Ô∏è Learning System:</strong> ' + item.learningReason + '</div>' : '') +
                            (item.consistentMapping ? '<div style="font-size: 10px; color: #059669; margin-top: 4px; background: #f0fdf4; padding: 4px; border-radius: 3px;"><strong>üîÑ Consistency Check:</strong> Applied same mapping as similar activity to ensure consistency</div>' : '') +
                        '</div>' : '';
                    const aiIndicator = '';
                    
                    // Add rank indicator
                    const rankBadge = `<span style="background: #3b82f6; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-right: 8px;">#${index + 1}</span>`;
                    
                    itemDiv.innerHTML = `
                        <div class="parsing-item-header">
                            <div class="parsing-item-title">${rankBadge}${item.suggested}${aiIndicator}</div>
                            <div class="confidence-badge ${confidenceClass}">${item.confidence}% confidence</div>
                        </div>
                        <div class="parsing-mapping">
                            <span class="mapping-original">"${item.original}"</span>
                            <span class="mapping-arrow">‚Üí</span>
                            <span class="mapping-suggested">${item.suggested}</span>
                        </div>
                        ${aiReasoning}
                        <div class="parsing-actions">
                            <button class="parsing-btn accept" onclick="acceptMapping(${originalIndex})">‚úì Accept</button>
                            <button class="parsing-btn reject" onclick="rejectMapping(${originalIndex})">‚úó Reject</button>
                            <button class="parsing-btn">Edit</button>
                        </div>
                    `;
                    
                    parsingContent.appendChild(itemDiv);
                });
            }
            
            // Add section for excluded items (0% confidence)
            if (excludedItems.length > 0) {
                const excludedHeader = document.createElement('div');
                excludedHeader.innerHTML = `
                    <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 8px; padding: 12px; margin: 20px 0 16px 0;">
                        <h3 style="margin: 0; color: #92400e; font-size: 14px; font-weight: 600;">
                            üö´ Auto-Excluded Activities (${excludedItems.length})
                        </h3>
                        <p style="margin: 4px 0 0 0; color: #a16207; font-size: 12px;">These activities have 0% confidence and won't appear in your Gantt chart</p>
                    </div>
                `;
                parsingContent.appendChild(excludedHeader);
                
                // Render excluded items (simplified view)
                excludedItems.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'parsing-item excluded';
                    itemDiv.style.opacity = '0.6';
                    
                    const aiExplanation = item.aiExplanation ? `<div style="font-size: 11px; color: #6b7280; margin-top: 2px; font-style: italic;">AI: ${item.aiExplanation}</div>` : '';
                    
                    itemDiv.innerHTML = `
                        <div style="padding: 8px 12px; background: #fefce8; border-radius: 6px; border-left: 3px solid #f59e0b;">
                            <div style="font-size: 13px; color: #92400e;">"${item.original}"</div>
                            ${aiExplanation}
                            <div style="font-size: 11px; color: #a16207; margin-top: 4px;">Reason: ${item.status || 'No suitable trade match found'}</div>
                        </div>
                    `;
                    
                    parsingContent.appendChild(itemDiv);
                });
            }
        }

        function acceptMapping(index) {
            const acceptedItem = parsedItems[index];
            
            // Mark item as accepted
            acceptedItem.acceptedByUser = true;
            acceptedItem.userAction = 'accepted';
            
            acceptedMappings.push(acceptedItem);
            
            // Check for similar activities and offer bulk action
            checkForSimilarItemsAction(index, 'accept');
            
            // Update UI immediately to show accepted state
            renderParsedItems();
            updateGanttChart();
            
            // Show brief notification of synchronization
            showSyncNotification(`Accepted "${acceptedItem.original}" - updated in both panels`);
            
            console.log(`‚úÖ User accepted: "${acceptedItem.original}" ‚Üí "${acceptedItem.suggested}"`);
        }

        // Group activities for validation by normalized patterns
        function groupActivitiesForValidation(activities) {
            const groups = new Map();
            
            activities.forEach(activity => {
                const normalized = normalizeActivityName(activity.original);
                
                if (!groups.has(normalized)) {
                    groups.set(normalized, {
                        pattern: normalized,
                        items: [],
                        suggested: activity.suggested
                    });
                }
                groups.get(normalized).items.push(activity);
            });
            
            // Convert to array and sort by group size (largest first)
            return Array.from(groups.values()).sort((a, b) => b.items.length - a.items.length);
        }

        // Accept group of similar activities
        function acceptGroup(groupIndex, type) {
            const groups = window.validationGroups[type];
            if (!groups || !groups[groupIndex]) return;
            
            const group = groups[groupIndex];
            console.log(`‚úÖ User accepted group: ${group.items.length} activities ‚Üí "${group.suggested}"`);
            
            // Just refresh the UI (items are already accepted)
            renderParsedItems();
            updateGanttChart();
        }

        // Reject group of similar activities
        function rejectGroup(groupIndex, type) {
            const groups = window.validationGroups[type];
            if (!groups || !groups[groupIndex]) return;
            
            const group = groups[groupIndex];
            console.log(`‚ùå User rejected group: ${group.items.length} activities ‚Üí "${group.suggested}"`);
            
            // Add all items to learning database and mark as rejected
            group.items.forEach(item => {
                const itemIndex = parsedItems.indexOf(item);
                if (itemIndex !== -1) {
                    // Add to learning database if it was a valid trade match
                    if (item.tradeId && item.suggested !== 'No Match') {
                        addRejectionToLearning(
                            item.original, 
                            item.suggested, 
                            item.tradeId, 
                            `User rejected group of ${group.items.length} similar activities`
                        );
                    }
                    
                    // Update the item to rejected state
                    parsedItems[itemIndex] = { 
                        ...item, 
                        confidence: 0, 
                        suggested: 'Rejected (Group)', 
                        status: 'User Rejected Group',
                        rejectedByUser: true
                    };
                }
            });
            
            // Update UI
            renderParsedItems();
            updateGanttChart();
        }

        function rejectMapping(index) {
            // Get the rejected item
            const rejectedItem = parsedItems[index];
            
            // Add to rejection draft list for download
            rejectedMappings.push({
                original: rejectedItem.original,
                suggested: rejectedItem.suggested,
                trade: rejectedItem.trade,
                confidence: rejectedItem.confidence,
                reason: 'User manually rejected',
                timestamp: new Date().toISOString(),
                buildingType: AppState.config.selectedBuildingType || 'Unknown'
            });
            
            // Add to learning database if it was a valid trade match
            if (rejectedItem.tradeId && rejectedItem.suggested !== 'No Match') {
                addRejectionToLearning(
                    rejectedItem.original, 
                    rejectedItem.suggested, 
                    rejectedItem.tradeId, 
                    'User manually rejected'
                );
            }
            
            // Update the item to rejected state
            parsedItems[index] = { 
                ...rejectedItem, 
                confidence: 0, 
                suggested: 'Rejected', 
                status: 'User Rejected',
                rejectedByUser: true,
                userAction: 'rejected'
            };
            
            // Check for similar activities and offer bulk action
            checkForSimilarItemsAction(index, 'reject');
            
            // Update UI with animation to show synchronization
            renderParsedItems();
            updateGanttChart();
            
            // Show brief notification of synchronization
            showSyncNotification(`Rejected "${rejectedItem.original}" - removed from both panels`);
            
            console.log(`‚ùå User rejected: "${rejectedItem.original}" ‚Üí "${rejectedItem.suggested}"`);
            
            // Update rejection count in button
            updateRejectionCount();
        }
        
        // Download rejected items as CSV
        function downloadRejectedList() {
            if (rejectedMappings.length === 0) {
                alert('No rejected items to download.');
                return;
            }
            
            const headers = ['Original Activity', 'Suggested Trade', 'Trade Category', 'Confidence %', 'Rejection Reason', 'Building Type', 'Timestamp'];
            const csvContent = [
                headers.join(','),
                ...rejectedMappings.map(item => [
                    `"${item.original}"`,
                    `"${item.suggested}"`, 
                    `"${item.trade}"`,
                    item.confidence,
                    `"${item.reason}"`,
                    `"${item.buildingType}"`,
                    `"${new Date(item.timestamp).toLocaleString()}"`
                ].join(','))
            ].join('\n');
            
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `rejected_activities_${new Date().toISOString().slice(0, 10)}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            
            console.log(`üì• Downloaded ${rejectedMappings.length} rejected items`);
        }
        
        // Update rejection count display
        function updateRejectionCount() {
            const countSpan = document.getElementById('rejectionCount');
            const downloadBtn = document.getElementById('downloadRejectedBtn');
            
            if (countSpan) {
                countSpan.textContent = rejectedMappings.length;
            }
            
            if (downloadBtn) {
                if (rejectedMappings.length > 0) {
                    downloadBtn.style.display = 'inline-block';
                    downloadBtn.disabled = false;
                } else {
                    downloadBtn.style.display = 'none';
                    downloadBtn.disabled = true;
                }
            }
        }

        function updateExcludedSection() {
            const section = document.getElementById('excludedSection');
            const itemsContainer = document.getElementById('excludedItems');
            const count = document.getElementById('excludedCount');
            
            if (excludedItems.length > 0) {
                section.classList.remove('hidden');
                count.textContent = excludedItems.length;
                
                itemsContainer.innerHTML = '';
                excludedItems.forEach((item, index) => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'excluded-item';
                    itemDiv.innerHTML = `
                        <span>${item}</span>
                        <span class="restore-btn" onclick="restoreItem(${index})">Restore</span>
                    `;
                    itemsContainer.appendChild(itemDiv);
                });
            }
        }

        function restoreItem(index) {
            // Logic to restore item from excluded
            excludedItems.splice(index, 1);
            updateExcludedSection();
        }

        // Output panel

        // Date parsing and formatting functions
        function parseScheduleDate(dateString) {
            if (!dateString || dateString === '' || dateString === 'null' || dateString === 'undefined') return null;
            
            // Clean the input string
            const cleaned = String(dateString).trim();
            
            // Skip if it's just a number that looks like a week (like "1", "2", "Week 1")
            if (/^(week\s*)?\d{1,2}$/i.test(cleaned)) return null;
            
            // Try different date formats commonly found in XER files
            const formats = [
                // Standard formats
                /(\d{4})-(\d{2})-(\d{2})/, // YYYY-MM-DD
                /(\d{2})\/(\d{2})\/(\d{4})/, // MM/DD/YYYY
                /(\d{2})-(\w{3})-(\d{4})/, // DD-MMM-YYYY (15-Jan-2024)
                /(\d{1,2})\/(\d{1,2})\/(\d{2,4})/, // M/D/YY or MM/DD/YYYY
                /(\d{4})(\d{2})(\d{2})/, // YYYYMMDD
                /(\w{3})\s+(\d{1,2}),?\s+(\d{4})/, // Jan 10, 2024 or Jan 10 2024
                /(\d{1,2})\s+(\w{3})\s+(\d{4})/, // 10 Jan 2024
            ];
            
            for (const format of formats) {
                const match = cleaned.match(format);
                if (match) {
                    try {
                        let date;
                        
                        // Month name mappings
                        const months = {
                            'jan': 0, 'feb': 1, 'mar': 2, 'apr': 3, 'may': 4, 'jun': 5,
                            'jul': 6, 'aug': 7, 'sep': 8, 'oct': 9, 'nov': 10, 'dec': 11
                        };
                        
                        if (format.source.includes('(\\w{3})\\s+(\\d{1,2})')) {
                            // Jan 10, 2024 format
                            const monthNum = months[match[1].toLowerCase()];
                            date = new Date(parseInt(match[3]), monthNum, parseInt(match[2]));
                        } else if (format.source.includes('(\\d{1,2})\\s+(\\w{3})')) {
                            // 10 Jan 2024 format
                            const monthNum = months[match[2].toLowerCase()];
                            date = new Date(parseInt(match[3]), monthNum, parseInt(match[1]));
                        } else if (format.source.includes('MMM')) {
                            // DD-MMM-YYYY format
                            const monthNum = months[match[2].toLowerCase()];
                            date = new Date(parseInt(match[3]), monthNum, parseInt(match[1]));
                        } else if (format.source.includes('(\\d{4})-(\\d{2})-(\\d{2})')) {
                            // YYYY-MM-DD format
                            date = new Date(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]));
                        } else if (format.source.includes('(\\d{2})\\/(\\d{2})\\/(\\d{4})')) {
                            // MM/DD/YYYY format
                            date = new Date(parseInt(match[3]), parseInt(match[1]) - 1, parseInt(match[2]));
                        } else if (format.source.includes('(\\d{4})(\\d{2})(\\d{2})')) {
                            // YYYYMMDD format
                            date = new Date(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]));
                        } else {
                            // Try generic parsing as fallback
                            date = new Date(cleaned);
                        }
                        
                        if (date && !isNaN(date.getTime())) {
                            return date;
                        }
                    } catch (e) {
                        console.log('Date parsing error:', e);
                    }
                }
            }
            
            // Fallback: try built-in Date parsing
            try {
                const date = new Date(dateString);
                if (!isNaN(date.getTime())) {
                    return date;
                }
            } catch (e) {
                console.log('Fallback date parsing failed:', e);
            }
            
            return null;
        }

        function calculateProjectTimespan(items) {
            const dates = [];
            
            for (const item of items) {
                const startDate = parseScheduleDate(item.startDate);
                const endDate = parseScheduleDate(item.endDate);
                
                if (startDate) dates.push(startDate);
                if (endDate) dates.push(endDate);
            }
            
            if (dates.length === 0) {
                // Fallback to generic timespan
                return {
                    start: new Date(),
                    end: new Date(Date.now() + 120 * 24 * 60 * 60 * 1000), // 120 days from now
                    totalDays: 120,
                    totalWeeks: 17
                };
            }
            
            const minDate = new Date(Math.min(...dates));
            const maxDate = new Date(Math.max(...dates));
            const totalDays = Math.ceil((maxDate - minDate) / (1000 * 60 * 60 * 24));
            const totalWeeks = Math.ceil(totalDays / 7);
            
            return {
                start: minDate,
                end: maxDate,
                totalDays: totalDays,
                totalWeeks: Math.max(totalWeeks, 4) // Minimum 4 weeks
            };
        }

        function updateGanttChart() {
            const ganttChart = document.getElementById('ganttChart');
            const totalActivities = document.getElementById('totalActivities');
            const mappedTrades = document.getElementById('mappedTrades');
            const projectDuration = document.getElementById('projectDuration');
            const emptyState = document.getElementById('outputEmptyState');
            const statsGrid = document.getElementById('statsGrid');
            const zoneFilter = document.getElementById('zoneFilter');
            
            // Filter to only include accepted items for Gantt chart
            const trackableItems = parsedItems.filter(item => item.userAction === 'accepted' || (item.confidence > 0 && !item.userAction));
            
            // Extract zones/levels for filtering
            const zones = new Set();
            trackableItems.forEach(item => {
                if (item.zone) zones.add(item.zone);
                if (item.level) zones.add(item.level);
                // Extract from activity name
                const activityName = (item.original || '').toLowerCase();
                const zoneMatches = activityName.match(/(?:zone|level|floor|bldg|building|area)\s*([a-zA-Z0-9-]+)/gi);
                if (zoneMatches) {
                    zoneMatches.forEach(match => zones.add(match.trim()));
                }
            });
            
            // Show zone filter if zones found
            if (zones.size > 1) {
                zoneFilter.style.display = 'block';
                updateZoneFilter(Array.from(zones));
            } else {
                zoneFilter.style.display = 'none';
            }
            
            // Show/hide empty state based on whether we have data
            if (trackableItems.length === 0) {
                emptyState.style.display = 'block';
                statsGrid.style.display = 'none';
                if (ganttChart) ganttChart.style.display = 'none';
                return;
            } else {
                emptyState.style.display = 'none';
                statsGrid.style.display = 'grid';
                if (ganttChart) ganttChart.style.display = 'block';
            }
            
            // Create simplified Gantt chart matching 5-minute setup style
            createSimplifiedGanttChart(trackableItems);
        }
        
        function updateZoneFilter(zones) {
            const container = document.getElementById('zoneFilterButtons');
            container.innerHTML = '';
            
            // Add "All" button
            const allBtn = document.createElement('button');
            allBtn.textContent = 'All Zones';
            allBtn.className = 'zone-filter-btn active';
            allBtn.style.cssText = 'padding: 6px 12px; border: 1px solid #d1d5db; border-radius: 6px; background: #3b82f6; color: white; cursor: pointer; font-size: 12px;';
            allBtn.onclick = () => filterByZone(null);
            container.appendChild(allBtn);
            
            // Add individual zone buttons
            zones.forEach(zone => {
                const btn = document.createElement('button');
                btn.textContent = zone;
                btn.className = 'zone-filter-btn';
                btn.style.cssText = 'padding: 6px 12px; border: 1px solid #d1d5db; border-radius: 6px; background: white; color: #374151; cursor: pointer; font-size: 12px;';
                btn.onclick = () => filterByZone(zone);
                container.appendChild(btn);
            });
        }
        
        function filterByZone(selectedZone) {
            // Update button states
            document.querySelectorAll('.zone-filter-btn').forEach(btn => {
                if ((!selectedZone && btn.textContent === 'All Zones') || 
                    (selectedZone && btn.textContent === selectedZone)) {
                    btn.style.background = '#3b82f6';
                    btn.style.color = 'white';
                } else {
                    btn.style.background = 'white';
                    btn.style.color = '#374151';
                }
            });
            
            // Re-render Gantt chart with filter applied
            window.selectedZoneFilter = selectedZone;
            updateGanttChart();
        }
        
        function createSimplifiedGanttChart(items) {
            const ganttContainer = document.getElementById('ganttChart');
            if (!ganttContainer) return;
            
            // Apply zone filter if active
            let filteredItems = items;
            if (window.selectedZoneFilter) {
                filteredItems = items.filter(item => {
                    const activityName = (item.original || '').toLowerCase();
                    return activityName.includes(window.selectedZoneFilter.toLowerCase());
                });
            }
            
            // Update stats with filtered data
            const totalActivities = document.getElementById('totalActivities');
            const mappedTrades = document.getElementById('mappedTrades');
            const projectDuration = document.getElementById('projectDuration');
            
            if (totalActivities) totalActivities.textContent = filteredItems.length;
            if (mappedTrades) mappedTrades.textContent = new Set(filteredItems.map(i => i.trade)).size;
            
            // Calculate project duration (simplified)
            const totalWeeks = Math.max(12, Math.ceil(filteredItems.length / 3)); // Estimate weeks
            if (projectDuration) projectDuration.textContent = `${totalWeeks} weeks estimated`;
            
            // Create timeline-style Gantt chart matching 5-minute setup
            ganttContainer.innerHTML = generateGanttHTML(filteredItems, totalWeeks);
        }
        
        function generateGanttHTML(items, totalWeeks) {
            const weekWidth = Math.max(60, Math.min(100, 1000 / totalWeeks));
            
            // Sort items by trade category for better organization
            const sortedItems = [...items].sort((a, b) => {
                const categoryA = (a.category || a.trade || '').toLowerCase();
                const categoryB = (b.category || b.trade || '').toLowerCase();
                return categoryA.localeCompare(categoryB);
            });
            
            let html = `
                <div class="timeline-gantt-wrapper" style="background: white; border-radius: 8px; overflow: hidden;">
                    <div class="timeline-grid-wrapper" style="position: relative; overflow-x: auto;">
                        <div class="timeline-corner" style="position: sticky; left: 0; top: 0; z-index: 3; background: #f8fafc; border-right: 1px solid #e2e8f0; width: 300px; height: 40px; display: flex; align-items: center; padding: 0 12px; font-weight: 600; font-size: 12px; color: #64748b; border-bottom: 1px solid #e2e8f0;">
                            Trade Activity
                        </div>
                        <div class="timeline-header" style="position: sticky; top: 0; z-index: 2; background: #f8fafc; border-bottom: 1px solid #e2e8f0; display: flex; padding-left: 300px;">
            `;
            
            // Generate week headers
            for (let week = 1; week <= totalWeeks; week++) {
                html += `<div class="timeline-week" style="width: ${weekWidth}px; padding: 8px 4px; text-align: center; font-size: 11px; font-weight: 500; color: #64748b; border-right: 1px solid #e5e7eb;">Week ${week}</div>`;
            }
            
            html += `
                        </div>
                        <div class="timeline-activities" style="position: relative;">
            `;
            
            // Generate activity rows
            sortedItems.forEach((item, index) => {
                const tradeColor = getTradeColor(item.category || item.trade);
                const acceptedStatus = item.userAction === 'accepted' ? 'trade-status-accepted' : '';
                
                // Calculate position and duration (simplified estimation)
                const estimatedStartWeek = Math.floor(index * 0.8) + 1;
                const estimatedDuration = Math.max(1, Math.ceil((item.duration || 7) / 7));
                const leftPos = (estimatedStartWeek - 1) * weekWidth;
                const barWidth = estimatedDuration * weekWidth - 4;
                
                html += `
                    <div class="timeline-activity-row ${acceptedStatus}" data-index="${index}" style="display: flex; border-bottom: 1px solid #f1f5f9; min-height: 40px; cursor: pointer;" 
                         onclick="toggleGanttSelection1Hour(${index}, event)">
                        <div style="position: sticky; left: 0; background: white; z-index: 1; width: 300px; padding: 8px 12px; border-right: 1px solid #e2e8f0; display: flex; align-items: center;">
                            <div style="flex: 1; min-width: 0;">
                                <div style="font-size: 12px; font-weight: 500; color: #1e293b; margin-bottom: 2px; word-break: break-word;">${item.suggested || item.original}</div>
                                <div style="font-size: 10px; color: #64748b;">${item.category || item.trade}</div>
                            </div>
                        </div>
                        <div class="timeline-bars-container" style="position: relative; width: ${totalWeeks * weekWidth}px; height: 40px;">
                            <div class="timeline-grid-lines" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;">
                `;
                
                // Grid lines
                for (let week = 1; week <= totalWeeks; week++) {
                    html += `<div class="timeline-grid-line" style="position: absolute; left: ${week * weekWidth}px; top: 0; height: 100%; width: 1px; background: #f1f5f9;"></div>`;
                }
                
                html += `
                            </div>
                            <div class="timeline-bar" data-trade-index="${index}" 
                                 style="position: absolute; left: ${leftPos}px; top: 8px; width: ${barWidth}px; height: 24px; background: ${tradeColor}; border-radius: 4px; z-index: 2; cursor: ew-resize; box-shadow: 0 1px 3px rgba(0,0,0,0.1);"
                                 onmousedown="startDrag1Hour(event, ${index})" ontouchstart="startDrag1Hour(event, ${index})">
                                <div class="timeline-bar-resize-handle" 
                                     style="position: absolute; right: 0; top: 0; width: 8px; height: 100%; cursor: ew-resize; background: rgba(255,255,255,0.3);"
                                     onmousedown="startResize1Hour(event, ${index})" ontouchstart="startResize1Hour(event, ${index})"></div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += `
                        </div>
                    </div>
                </div>
            `;
            
            return html;
        }
        
        function toggleGanttSelection1Hour(index, event) {
            event.stopPropagation();
            event.preventDefault();
            
            // For 1-hour setup, we'll implement selection if needed
            console.log('Selected Gantt item:', index);
        }
        
        function getTradeColor(trade) {
            const tradeColors = {
                'Concrete': '#8b5cf6',
                'Sitework': '#84cc16',
                'Electrical': '#f59e0b',
                'Mechanical': '#06b6d4',
                'Fire Protection': '#ef4444',
                'Finishes': '#ec4899',
                'Equipment': '#10b981',
                'Insulation': '#6366f1',
                'Masonry': '#f97316',
                'Ceilings': '#14b8a6'
            };
            
            const category = (trade || '').toLowerCase();
            for (const [key, color] of Object.entries(tradeColors)) {
                if (category.includes(key.toLowerCase())) {
                    return color;
                }
            }
            return '#6b7280'; // Default gray
        }

        // Drag and drop functionality for 1-hour setup
            
            // Update stats
            totalActivities.textContent = trackableItems.length;
            mappedTrades.textContent = new Set(trackableItems.map(i => i.trade)).size;
            
            const formatDate = (date) => date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            projectDuration.textContent = `${Math.round(timespan.totalDays)} days (${formatDate(timespan.start)} - ${formatDate(timespan.end)})`;
            
            // Create timeline-style Gantt chart with real schedule dates
            if (trackableItems.length > 0) {
                // Process items with real dates
                const sortedItems = [...trackableItems].map((item, index) => {
                    const startDate = parseScheduleDate(item.startDate);
                    const endDate = parseScheduleDate(item.endDate);
                    
                    let startWeek, duration;
                    
                    if (startDate && endDate) {
                        // Use real dates
                        const daysSinceProjectStart = Math.floor((startDate - timespan.start) / (1000 * 60 * 60 * 24));
                        const durationDays = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24));
                        
                        startWeek = Math.floor(daysSinceProjectStart / 7) + 1;
                        duration = Math.max(1, Math.ceil(durationDays / 7)); // At least 1 week
                    } else {
                        // Fallback to estimated dates based on trade sequence if no real dates
                        const tradeStartWeeks = {
                            'excavation': 1, 'structural_piles': 2, 'concrete_formwork': 3,
                            'concrete_rebar': 4, 'concrete_pour': 5, 'structural_steel': 6,
                            'roofing': 8, 'mechanical': 9, 'electrical': 10, 'plumbing': 11,
                            'drywall': 12, 'general': Math.floor(totalWeeks / 2)
                        };
                        
                        const baseStartWeek = tradeStartWeeks[item.trade] || Math.floor(totalWeeks / 2);
                        const variation = Math.floor(index * 0.1) % 2;
                        startWeek = Math.min(baseStartWeek + variation, totalWeeks - 1);
                        duration = Math.max(1, Math.floor(item.duration / 7) || 2); // Convert hours to weeks or default
                    }
                    
                    return {
                        ...item,
                        startWeek: Math.max(1, startWeek),
                        duration: Math.min(duration, totalWeeks - startWeek + 1),
                        realDates: !!(startDate && endDate),
                        parsedStartDate: startDate,
                        parsedEndDate: endDate,
                        originalIndex: parsedItems.indexOf(item) // Store original index for selection
                    };
                }).sort((a, b) => a.startWeek - b.startWeek); // Sort chronologically
                
                console.log(`üìÖ Schedule Analysis: ${sortedItems.filter(i => i.realDates).length} of ${sortedItems.length} activities have real dates`);
                
                ganttChart.innerHTML = `
                    <div class="timeline-gantt-wrapper">
                        <!-- Legend -->
                        <div class="timeline-legend">
                            <div class="legend-item">
                                <div class="legend-bar legend-planned"></div>
                                <span style="color: #475569; font-weight: 500;">Planned Schedule</span>
                            </div>
                        </div>
                        
                        <!-- Timeline Grid -->
                        <div class="timeline-grid-wrapper">
                            <!-- Corner block -->
                            <div class="timeline-corner">
                                Activity Name
                            </div>
                            
                            <!-- Week headers -->
                            <div class="timeline-header">
                                ${Array.from({length: totalWeeks}, (_, i) => {
                                    const weekStart = new Date(timespan.start.getTime() + i * 7 * 24 * 60 * 60 * 1000);
                                    const monthDay = weekStart.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                                    return `<div class="timeline-week" title="Week starting ${weekStart.toLocaleDateString()}">
                                        <div style="font-weight: 600; font-size: 11px;">Week ${i + 1}</div>
                                        <div style="font-size: 9px; color: #64748b;">${monthDay}</div>
                                    </div>`;
                                }).join('')}
                            </div>
                            
                            <!-- Activity names column -->
                            <div class="timeline-activities" id="timelineActivities">
                            </div>
                            
                            <!-- Timeline bars -->
                            <div class="timeline-bars-container">
                                <div class="timeline-bars" id="timelineBars">
                                    <!-- Grid lines -->
                                    <div class="timeline-grid-lines" id="timelineGridLines">
                                    </div>
                                    
                                    <!-- Activity bars -->
                                    <div id="timelineActivityBars">
                                                </div>
                                            </div>
                                </div>
                            </div>
                    </div>';
                
                // Generate content using clean DOM creation
                generateGanttContent(sortedItems, totalWeeks, weekWidth);
            }
        }


        function generateGanttContent(sortedItems, totalWeeks, weekWidth) {
            // Clean DOM creation approach - no template literals!
            const activitiesContainer = document.getElementById('timelineActivities');
            const barsContainer = document.getElementById('timelineBars');
            const gridLinesContainer = document.getElementById('timelineGridLines');
            const activityBarsContainer = document.getElementById('timelineActivityBars');
            
            // Clear existing content
            if (activitiesContainer) activitiesContainer.innerHTML = '';
            if (gridLinesContainer) gridLinesContainer.innerHTML = '';
            if (activityBarsContainer) activityBarsContainer.innerHTML = '';
            
            // Set timeline bars width
            if (barsContainer) {
                barsContainer.style.width = (totalWeeks * weekWidth) + 'px';
            }
            
            // Generate grid lines
            if (gridLinesContainer) {
                for (let i = 0; i <= totalWeeks; i++) {
                    const gridLine = document.createElement('div');
                    gridLine.className = 'timeline-grid-line';
                    gridLine.style.left = (i * weekWidth) + 'px';
                    gridLinesContainer.appendChild(gridLine);
                }
            }
            
            // Generate activity rows and bars
            if (activitiesContainer && activityBarsContainer) {
                sortedItems.forEach((item, index) => {
                    // Create activity row
                    const activityRow = document.createElement('div');
                    activityRow.className = 'timeline-activity-row gantt-item';
                    activityRow.setAttribute('data-item-index', item.originalIndex);
                    activityRow.style.cursor = 'pointer';
                    
                    // Add selection state
                    if (AppState.user.selectedGanttItems.has(item.originalIndex)) {
                        activityRow.classList.add('selected');
                    }
                    
                    // Create date info
                    const dateInfo = item.realDates ? 
                        item.parsedStartDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) : 
                        'Week ' + item.startWeek;
                    
                    // Create tooltip
                    const tooltip = item.realDates ? 
                        item.original + '\nTrade: ' + item.suggested + '\nStart: ' + item.parsedStartDate.toLocaleDateString() + '\nEnd: ' + item.parsedEndDate.toLocaleDateString() : 
                        item.original + '\nTrade: ' + item.suggested + '\nEstimated timing: Week ' + item.startWeek;
                    
                    activityRow.title = tooltip;
                    
                    // User action indicator
                    if (item.acceptedByUser) {
                        const acceptedSpan = document.createElement('span');
                        acceptedSpan.style.cssText = 'color: #16a34a; font-size: 12px; margin-right: 6px;';
                        acceptedSpan.title = 'Accepted by user';
                        acceptedSpan.textContent = '‚úÖ';
                        activityRow.appendChild(acceptedSpan);
                    } else if (item.rejectedByUser) {
                        const rejectedSpan = document.createElement('span');
                        rejectedSpan.style.cssText = 'color: #dc2626; font-size: 12px; margin-right: 6px;';
                        rejectedSpan.title = 'Rejected by user';
                        rejectedSpan.textContent = '‚ùå';
                        activityRow.appendChild(rejectedSpan);
                    }
                    
                    // Task ID
                    const taskId = item.taskId || item.taskCode || 'T' + String(index + 1).padStart(3, '0');
                    const taskIdSpan = document.createElement('span');
                    taskIdSpan.style.cssText = 'color: #64748b; font-size: 11px; margin-right: 8px; font-weight: 600;';
                    taskIdSpan.textContent = taskId;
                    activityRow.appendChild(taskIdSpan);
                    
                    // Date indicator
                    const dateIndicator = item.realDates ? 'üìÖ' : 'üìä';
                    const dateIndicatorSpan = document.createElement('span');
                    dateIndicatorSpan.style.cssText = 'color: ' + (item.realDates ? '#059669' : '#64748b') + '; font-size: 10px; margin-right: 6px;';
                    dateIndicatorSpan.textContent = dateIndicator;
                    activityRow.appendChild(dateIndicatorSpan);
                    
                    // Date info
                    const dateInfoSpan = document.createElement('span');
                    dateInfoSpan.style.cssText = 'color: #64748b; font-size: 11px; margin-right: 8px;';
                    dateInfoSpan.textContent = dateInfo;
                    activityRow.appendChild(dateInfoSpan);
                    
                    // Original activity name
                    const originalSpan = document.createElement('span');
                    originalSpan.style.cssText = 'color: #1f2937; font-size: 12px; font-weight: 500;';
                    originalSpan.textContent = item.original;
                    activityRow.appendChild(originalSpan);
                    
                    // Suggested trade
                    const suggestedSpan = document.createElement('span');
                    suggestedSpan.style.cssText = 'color: #6366f1; font-size: 11px; margin-left: 8px; background: #eef2ff; padding: 2px 6px; border-radius: 3px;';
                    suggestedSpan.textContent = item.suggested;
                    activityRow.appendChild(suggestedSpan);
                    
                    // Add click handler
                    activityRow.addEventListener('click', function(event) {
                        toggleGanttSelection1Hour(item.originalIndex, event);
                    });
                    
                    activitiesContainer.appendChild(activityRow);
                    
                    // Create timeline bar
                    const leftPos = (item.startWeek - 1) * weekWidth + 10;
                    const width = item.duration * weekWidth - 20;
                    
                    const barRow = document.createElement('div');
                    barRow.className = 'timeline-bar-row';
                    
                    const timelineBar = document.createElement('div');
                    timelineBar.className = 'timeline-bar planned ' + (item.trade || 'general');
                    timelineBar.setAttribute('data-trade-index', item.originalIndex);
                    timelineBar.style.cssText = 'left: ' + leftPos + 'px; width: ' + width + 'px; top: 14px;';
                    timelineBar.title = item.suggested + ' (Week ' + item.startWeek + '-' + (item.startWeek + item.duration - 1) + ')';
                    timelineBar.textContent = item.suggested.substring(0, 20);
                    
                    // Add drag handlers
                    timelineBar.addEventListener('mousedown', function(event) {
                        startDrag1Hour(event, item.originalIndex);
                    });
                    timelineBar.addEventListener('touchstart', function(event) {
                        startDrag1Hour(event, item.originalIndex);
                    });
                    
                    // Create resize handle
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'timeline-bar-resize-handle';
                    resizeHandle.addEventListener('mousedown', function(event) {
                        startResize1Hour(event, item.originalIndex);
                    });
                    resizeHandle.addEventListener('touchstart', function(event) {
                        startResize1Hour(event, item.originalIndex);
                    });
                    
                    timelineBar.appendChild(resizeHandle);
                    barRow.appendChild(timelineBar);
                    activityBarsContainer.appendChild(barRow);
                });
            }
        }

        function handleCustomerReview() {
            alert('Project setup sent for customer review. They will receive a link to review and approve the configuration.');
        }

        // AI Enhancement functionality
        async function enhanceWithAI() {
            console.log('üöÄ AI Enhancement started!');
            console.log('Uploaded files:', AppState.files.uploaded);
            console.log('Selected building type:', AppState.config.selectedBuildingType);
            
            if (AppState.files.uploaded.length === 0) {
                alert('Please upload a schedule file first.');
                return;
            }

            if (!window.AppConfig?.isConfigured()) {
                alert('Please configure your Gemini API key first using the AI configuration dialog.');
                return;
            }

            // First, process all uploaded files
            const scheduleFiles = AppState.files.uploaded.filter(file => {
                const ext = file.name.toLowerCase().split('.').pop();
                return ['xer', 'csv', 'xlsx', 'xls'].includes(ext);
            });

            if (scheduleFiles.length === 0) {
                alert('Please upload a schedule file (.xer, .csv, .xlsx, .xls) first.');
                return;
            }

            const aiBtn = document.getElementById('aiEnhanceBtn');
            const originalText = aiBtn.textContent;
            aiBtn.textContent = 'ü§ñ Parsing & AI Processing...';
            aiBtn.disabled = true;

            try {
                const parsingContent = document.getElementById('parsingContent');
                
            // Step 1: File Parsing & Raw Extraction
            updateProgressStep(parsingContent, "üìÑ", "Reading Schedule Files", "Extracting all activities from uploaded schedules...", 1, 8);
                
                console.log('üìÑ Step 1: Raw extraction from uploaded files...');
                
                // Process schedule files first - get ALL activities initially  
                for (const file of scheduleFiles) {
                    try {
                        await parseSchedule(file);
                    } catch (error) {
                        console.error('Error parsing file:', file.name, error);
                    }
                }

                if (parsedItems.length === 0) {
                    parsingContent.innerHTML = `
                        <div style="text-align: center; padding: 40px;">
                            <div style="color: #ef4444; font-size: 48px; margin-bottom: 16px;">‚ö†Ô∏è</div>
                            <div style="font-size: 18px; font-weight: 600; color: #1f2937; margin-bottom: 8px;">No Schedule Activities Found</div>
                            <div style="font-size: 14px; color: #6b7280; margin-bottom: 20px; max-width: 400px; margin-left: auto; margin-right: auto;">
                                Unable to extract activities from the uploaded schedule. Please check the file format or try a different schedule file.
                            </div>
                        </div>
                    `;
                    console.log('‚ùå No activities found in schedule file. Check file parsing.');
                    aiBtn.textContent = originalText;
                    aiBtn.disabled = false;
                    return;
                }

                const initialCount = parsedItems.length;
                console.log(`üìÑ Raw Extraction: Found ${initialCount} total schedule activities`);
                await new Promise(resolve => setTimeout(resolve, 400));

                // Create a copy for comprehensive filtering (parseSchedule already applies some filtering)
                let currentItems = [...parsedItems];

                // Step 2: Keyword Filtering  
                updateProgressStep(parsingContent, "üö´", "Keyword Filtering", `Filtering out administrative tasks using ${excludeKeywords.length} exclusion keywords...`, 2, 8);
                
                // Apply comprehensive keyword filtering
                const beforeKeywordCount = currentItems.length;
                currentItems = currentItems.filter(item => {
                    const activityText = item.original.toLowerCase();
                    const hasExcludedKeyword = excludeKeywords.some(keyword => activityText.includes(keyword.toLowerCase()));
                    return !hasExcludedKeyword;
                });
                
                const keywordFilteredCount = beforeKeywordCount - currentItems.length;
                console.log(`üö´ Keyword Filtering: Removed ${keywordFilteredCount} administrative/non-construction tasks`);
                console.log(`üö´ Keyword Filtering: ${currentItems.length} activities remain`);
                await new Promise(resolve => setTimeout(resolve, 400));

                // Step 3: Duration Filtering (0-day tasks) - additional check
                updateProgressStep(parsingContent, "‚è±Ô∏è", "Duration Filtering", "Removing 0-day milestones and administrative markers...", 3, 8);
                
                const beforeDurationCount = currentItems.length;
                currentItems = currentItems.filter(item => {
                    // Additional duration check if we have duration data
                    if (item.duration !== undefined) {
                        return item.duration > 0;
                    }
                    return true; // Keep if no duration info available
                });
                
                const durationFilteredCount = beforeDurationCount - currentItems.length;
                console.log(`‚è±Ô∏è Duration Filtering: Removed ${durationFilteredCount} zero-duration milestones`);
                console.log(`‚è±Ô∏è Duration Filtering: ${currentItems.length} activities remain`);
                await new Promise(resolve => setTimeout(resolve, 400));

                // Step 4: WBS Code Filtering
                updateProgressStep(parsingContent, "üèóÔ∏è", "WBS Construction Filtering", "Identifying construction activities using WBS codes and activity names...", 4, 8);
                
                const beforeWBSCount = currentItems.length;
                let wbsFiltered = currentItems.filter(item => {
                    const wbsCode = item.wbs || item.wbsCode || '';
                    return isConstructionActivity(wbsCode, item.original);
                });
                
                // Implement fallback logic if WBS filtering is too restrictive
                if (wbsFiltered.length < (beforeWBSCount * 0.05)) {
                    console.log(`üèóÔ∏è WBS Filtering: Too restrictive (${wbsFiltered.length} of ${beforeWBSCount}), disabling WBS filter`);
                    wbsFiltered = currentItems;
                } else {
                    const wbsFilteredCount = beforeWBSCount - wbsFiltered.length;
                    console.log(`üèóÔ∏è WBS Filtering: Removed ${wbsFilteredCount} non-construction activities`);
                }
                console.log(`üèóÔ∏è WBS Filtering: ${wbsFiltered.length} construction activities identified`);
                currentItems = wbsFiltered;
                await new Promise(resolve => setTimeout(resolve, 400));

                // Update parsedItems with filtered results
                parsedItems = currentItems;

                // Check if we have any activities left after comprehensive filtering
                if (parsedItems.length === 0) {
                    parsingContent.innerHTML = `
                        <div style="text-align: center; padding: 40px;">
                            <div style="color: #ef4444; font-size: 48px; margin-bottom: 16px;">‚ö†Ô∏è</div>
                            <div style="font-size: 18px; font-weight: 600; color: #1f2937; margin-bottom: 8px;">No Construction Activities Found</div>
                            <div style="font-size: 14px; color: #6b7280; margin-bottom: 20px; max-width: 400px; margin-left: auto; margin-right: auto;">
                                All activities were filtered out during the 4-stage filtering process.
                                <br><br>Filtered: ${keywordFilteredCount} admin tasks, ${durationFilteredCount} milestones, ${beforeWBSCount - wbsFiltered.length} non-construction
                            </div>
                        </div>
                    `;
                    console.log('‚ùå No construction activities remain after comprehensive filtering.');
                    aiBtn.textContent = originalText;
                    aiBtn.disabled = false;
                    return;
                }

                // Step 5: Building Type Analysis & Pre-filtering
                const relevantTrades = getRelevantTrades();
                updateProgressStep(parsingContent, "üè≠", "Building Type Analysis", `Using ${relevantTrades.length} Data Center trades for keyword pre-matching...`, 5, 8);
                
                // Pre-filter with keyword matching to reduce AI workload
                const preFilteredItems = parsedItems.map(item => {
                    const keywordMatch = mapActivityToTrade(item.original);
                    if (keywordMatch.confidence >= 70) {
                        // High confidence keyword match - skip AI for this item
                        return { ...keywordMatch, preFiltered: true };
                    }
                    return { ...item, preFiltered: false };
                });
                
                const aiNeededCount = preFilteredItems.filter(item => !item.preFiltered).length;
                let preMatchedCount = preFilteredItems.filter(item => item.preFiltered).length;
                console.log(`üè≠ Building Type: ${preMatchedCount} high-confidence keyword matches, ${aiNeededCount} need AI analysis`);
                console.log(`üè≠ Filtering Summary: ${initialCount} ‚Üí ${parsedItems.length} ‚Üí ${aiNeededCount} for AI (${Math.round((1 - aiNeededCount/initialCount) * 100)}% reduction)`);
                
                // Update parsedItems with pre-filtered results
                parsedItems = preFilteredItems;
                await new Promise(resolve => setTimeout(resolve, 400));
                
                // Step 6: AI Matching Setup
                updateProgressStep(parsingContent, "ü§ñ", "AI Trade Matching", `Analyzing ${parsedItems.length} trackable activities...`, 6, 8);
                console.log(`ü§ñ Step 6: Starting AI enhancement of ${parsedItems.length} activities...`);

                // Only process items that need AI analysis
                const aiNeededItems = parsedItems.filter(item => !item.preFiltered);
                preMatchedCount = parsedItems.length - aiNeededItems.length;

                // Smart Keyword-Based Batching instead of sequential chunks
                console.log(`üß† Smart Batching: Grouping ${aiNeededItems.length} activities by keywords...`);
                
                const keywordBatches = createKeywordBasedBatches(aiNeededItems);
                const totalAIChunks = keywordBatches.length;
                let aiProcessed = 0;
                
                console.log(`üß† Smart Batching: Created ${totalAIChunks} keyword-based batches`);
                keywordBatches.forEach((batch, index) => {
                    if (batch.batchType === 'similar_activities') {
                        console.log(`  üìã Batch ${index + 1}: ${batch.length} SIMILAR activities ‚Üí "${batch.pattern}"`);
                        batch.forEach((item, itemIndex) => {
                            if (itemIndex < 3) console.log(`    ‚Ä¢ "${item.original}"`);
                            else if (itemIndex === 3 && batch.length > 3) console.log(`    ‚Ä¢ ... and ${batch.length - 3} more`);
                        });
                    } else {
                        console.log(`  üîÄ Batch ${index + 1}: ${batch.length} mixed activities`);
                    }
                });
                
                for (let chunkIndex = 0; chunkIndex < keywordBatches.length; chunkIndex++) {
                    const chunk = keywordBatches[chunkIndex];
                    const progressPercent = ((chunkIndex + 1) / totalAIChunks) * 100;
                    
                    // Update AI progress with detailed info
                    const batchTypeLabel = chunk.batchType === 'similar_activities' ? 'Similar' : 
                                          chunk.batchType === 'similar_activities_large_group' ? `Similar (${chunk.batchNumber} of ${chunk.totalBatches})` : 'Mixed';
                    updateProgressStepWithBar(parsingContent, "üß†", "AI Processing", 
                        `AI analyzing ${batchTypeLabel} batch ${chunkIndex + 1} of ${totalAIChunks} ‚Ä¢ ${preMatchedCount} pre-matched, ${aiProcessed} of ${aiNeededItems.length} AI processed`, 
                        6, 8, progressPercent);
                    
                    try {
                        // Process entire chunk in one AI call for major speed improvement
                        const enhancedChunk = await enhanceActivitiesChunk(chunk);
                        
                        // Update the original items with enhanced data
                        enhancedChunk.forEach((enhancedItem, index) => {
                            const originalIndex = parsedItems.findIndex(item => 
                                item.original === chunk[index].original && !item.preFiltered
                            );
                            if (originalIndex !== -1) {
                                parsedItems[originalIndex] = { ...enhancedItem, aiEnhanced: true };
                            }
                        });
                        
                        aiProcessed += chunk.length;
                        console.log(`‚úÖ AI Enhanced ${aiProcessed} of ${aiNeededItems.length} activities (${Math.round(progressPercent)}%)`);
                        
                        // Reduced delay for faster processing
                        if (chunkIndex + 1 < keywordBatches.length) {
                            await new Promise(resolve => setTimeout(resolve, 100)); // Reduced from 300ms
                        }
                    } catch (error) {
                        console.error(`Error processing AI chunk ${chunkIndex + 1} of ${totalAIChunks}:`, error);
                        aiProcessed += chunk.length;
                    }
                }

                // Step 7: Large Group Consistency & Final Check
                updateProgressStep(parsingContent, "üîç", "Consistency Check", "Ensuring similar activities have consistent mappings...", 7, 8);
                
                // Post-process large groups to ensure consistency
                const largeGroupPatterns = new Map();
                
                // Collect all results from large group batches
                parsedItems.forEach(item => {
                    if (item.pattern && item.confidence > 0) {
                        if (!largeGroupPatterns.has(item.pattern)) {
                            largeGroupPatterns.set(item.pattern, []);
                        }
                        largeGroupPatterns.get(item.pattern).push(item);
                    }
                });
                
                // For each pattern with multiple items, find the best decision and apply to all
                for (const [pattern, items] of largeGroupPatterns) {
                    if (items.length > 1) {
                        // Find the highest confidence decision for this pattern
                        const bestDecision = items.reduce((best, current) => 
                            current.confidence > best.confidence ? current : best
                        );
                        
                        // Apply the best decision to all items with this pattern
                        items.forEach(item => {
                            if (item.original !== bestDecision.original) {
                                item.suggested = bestDecision.suggested;
                                item.confidence = Math.max(item.confidence, bestDecision.confidence - 5); // Slight confidence reduction for consistency-applied items
                                item.trade = bestDecision.trade;
                                item.tradeId = bestDecision.tradeId;
                                item.category = bestDecision.category;
                                item.aiReasoning = `Consistency Applied: Same as "${bestDecision.original}" (${bestDecision.confidence}% confidence)`;
                                item.consistencyApplied = true;
                            }
                        });
                        
                        console.log(`üîÑ Consistency: Applied "${bestDecision.suggested}" to ${items.length} "${pattern}" activities`);
                    }
                }
                
                // Apply consistency mapping to fix issues like ASP Install - Rows inconsistencies
                parsedItems = applyConsistentMapping(parsedItems);
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Step 8: Final Ranking & Completion
                updateProgressStep(parsingContent, "üìä", "Ranking Results", "Sorting activities by AI confidence scores...", 8, 8);
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Final: Completion
                const trackableCount = parsedItems.filter(item => item.confidence > 0).length;
                const excludedCount = parsedItems.filter(item => item.confidence === 0).length;
                updateProgressStep(parsingContent, "‚úÖ", "Analysis Complete", 
                    `Successfully processed ${trackableCount} trackable activities ‚Ä¢ ${excludedCount} auto-excluded`, 8, 8);
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Clear and show final results
                parsingContent.innerHTML = '';

                // Display all results at once after processing is complete
                renderParsedItems();
                updateExcludedSection();
                updateGanttChart();

            } catch (error) {
                alert(`AI Enhancement failed: ${error.message}`);
                console.error('AI Enhancement error:', error);
            } finally {
                aiBtn.textContent = originalText;
                aiBtn.disabled = false;
            }
        }

        // Generate AI insights about the parsed activities
        async function generateProjectInsights() {
            if (!window.GeminiAPI || parsedItems.length === 0) return;

            try {
                const activitySummary = parsedItems.map(item => `${item.suggested} (${item.trade})`).join(', ');
                
                const prompt = `Analyze this construction project based on the parsed activities and provide insights:

Activities: ${activitySummary}

Provide insights on:
1. Project type and complexity
2. Estimated duration and critical path
3. Resource requirements
4. Potential risks and bottlenecks
5. Recommended tracking approach

Keep response concise and actionable for project managers.`;

                const insights = await window.GeminiAPI.generateContent(prompt, { temperature: 0.4 });
                
                // Display insights in summary tab
                const summaryContent = document.getElementById('summaryContent');
                if (summaryContent) {
                    summaryContent.innerHTML += `
                        <div style="padding: 16px; background: #f0f9ff; border-radius: 8px; margin-top: 16px;">
                            <h4 style="font-size: 14px; font-weight: 600; margin-bottom: 8px; color: #0369a1;">ü§ñ AI Project Insights</h4>
                            <div style="color: #0c4a6e; font-size: 13px; line-height: 1.5; white-space: pre-wrap;">${insights}</div>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Failed to generate AI insights:', error);
            }
        }

        // Initialize click handlers for drop zones
        document.getElementById('scheduleDropZone').addEventListener('click', () => {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.xer,.csv,.xlsx,.xls';
            input.onchange = (e) => processFiles(Array.from(e.target.files));
            input.click();
        });

        
        // Helper function to update progress steps
        function updateProgressStep(container, icon, title, description, currentStep, totalSteps) {
            container.innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <div style="font-size: 48px; margin-bottom: 16px;">${icon}</div>
                    <div style="font-size: 18px; font-weight: 600; color: #1f2937; margin-bottom: 8px;">${title}</div>
                    <div style="font-size: 14px; color: #6b7280; margin-bottom: 20px; max-width: 400px; margin-left: auto; margin-right: auto;">${description}</div>
                    <div style="display: flex; justify-content: center; gap: 8px; margin-bottom: 16px;">
                        ${Array.from({length: totalSteps}, (_, i) => `
                            <div style="width: 12px; height: 12px; border-radius: 50%; background: ${i < currentStep ? '#10b981' : i === currentStep - 1 ? '#3b82f6' : '#e5e7eb'}; transition: background 0.3s ease;"></div>
                        `).join('')}
                    </div>
                    <div style="font-size: 12px; color: #9ca3af;">Step ${currentStep} of ${totalSteps}</div>
                </div>
            `;
        }
        
        // Helper function to update progress steps with progress bar
        function updateProgressStepWithBar(container, icon, title, description, currentStep, totalSteps, percentage) {
            container.innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <div style="font-size: 48px; margin-bottom: 16px;">${icon}</div>
                    <div style="font-size: 18px; font-weight: 600; color: #1f2937; margin-bottom: 8px;">${title}</div>
                    <div style="font-size: 14px; color: #6b7280; margin-bottom: 20px; max-width: 400px; margin-left: auto; margin-right: auto;">${description}</div>
                    <div style="display: flex; justify-content: center; gap: 8px; margin-bottom: 16px;">
                        ${Array.from({length: totalSteps}, (_, i) => `
                            <div style="width: 12px; height: 12px; border-radius: 50%; background: ${i < currentStep ? '#10b981' : i === currentStep - 1 ? '#3b82f6' : '#e5e7eb'}; transition: background 0.3s ease;"></div>
                        `).join('')}
                    </div>
                    <div style="width: 100%; max-width: 300px; margin: 16px auto; background: #f3f4f6; border-radius: 8px; overflow: hidden;">
                        <div style="width: ${percentage}%; height: 6px; background: linear-gradient(90deg, #3b82f6, #8b5cf6); transition: width 0.3s ease;"></div>
                    </div>
                    <div style="font-size: 12px; color: #9ca3af;">Step ${currentStep} of ${totalSteps} ‚Ä¢ ${Math.round(percentage)}% complete</div>
                </div>
            `;
        }
        
        // Initialize learning system on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadLearningDatabase();
            console.log('üß† AI Learning System initialized');
        });
        
        // Gantt chart multi-selection functions
        function toggleGanttSelection(itemIndex, event) {
            console.log('üîç toggleGanttSelection called:', { itemIndex, hasEvent: !!event });
            
            // Prevent event bubbling to parent containers
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            
            console.log('üìä Current selections before:', Array.from(AppState.user.selectedGanttItems));
            
            // Allow Ctrl+click for multi-selection, regular click for single selection
            if (!event || !event.ctrlKey && !event.metaKey) {
                // Single selection mode - clear other selections first
                if (!AppState.user.selectedGanttItems.has(itemIndex)) {
                    AppState.user.selectedGanttItems.clear();
                    console.log('üßπ Cleared existing selections for single selection');
                }
            }
            
            if (AppState.user.selectedGanttItems.has(itemIndex)) {
                AppState.user.selectedGanttItems.delete(itemIndex);
                console.log('‚ùå Removed item from selection:', itemIndex);
            } else {
                AppState.user.selectedGanttItems.add(itemIndex);
                console.log('‚úÖ Added item to selection:', itemIndex);
            }
            
            console.log('üìä Final selections:', Array.from(AppState.user.selectedGanttItems));
            
            updateGanttChart();
            updateBulkActionsToolbar();
        }
        
        function updateBulkActionsToolbar() {
            const toolbar = document.getElementById('bulkActionsToolbar');
            const selectedCount = document.getElementById('selectedCount');
            
            if (AppState.user.selectedGanttItems.size > 0) {
                toolbar.style.display = 'flex';
                selectedCount.textContent = AppState.user.selectedGanttItems.size;
            } else {
                toolbar.style.display = 'none';
            }
        }
        
        function bulkAcceptSelected() {
            if (AppState.user.selectedGanttItems.size === 0) {
                alert('No items selected.');
                return;
            }
            
            const selectedCount = AppState.user.selectedGanttItems.size;
            AppState.user.selectedGanttItems.forEach(itemIndex => {
                acceptMapping(itemIndex);
            });
            
            clearGanttSelection();
            console.log(`‚úÖ Bulk accepted ${selectedCount} items`);
        }
        
        function bulkRejectSelected() {
            if (AppState.user.selectedGanttItems.size === 0) {
                alert('No items selected.');
                return;
            }
            
            const selectedCount = AppState.user.selectedGanttItems.size;
            AppState.user.selectedGanttItems.forEach(itemIndex => {
                rejectMapping(itemIndex);
            });
            
            clearGanttSelection();
            console.log(`‚ùå Bulk rejected ${selectedCount} items`);
        }
        
        function selectAllGanttItems() {
            // Get all trackable items (confidence > 0) from parsedItems
            const trackableItems = parsedItems.filter(item => item.confidence > 0);
            trackableItems.forEach((item) => {
                const itemIndex = parsedItems.indexOf(item);
                AppState.user.selectedGanttItems.add(itemIndex);
            });
            
            updateGanttChart();
            updateBulkActionsToolbar();
        }

        function clearGanttSelection() {
            AppState.user.selectedGanttItems.clear();
            updateGanttChart();
            updateBulkActionsToolbar();
        }
        
        // Check for similar activities and offer bulk action
        function checkForSimilarItemsAction(actionIndex, actionType) {
            const actionItem = parsedItems[actionIndex];
            const normalizedName = normalizeActivityName(actionItem.original);
            
            // Find similar items that haven't been acted upon yet
            const similarItems = parsedItems
                .map((item, index) => ({ item, index }))
                .filter(({ item, index }) => {
                    return index !== actionIndex && // Not the same item
                           !item.acceptedByUser && // Not already accepted
                           !item.rejectedByUser && // Not already rejected
                           item.confidence > 0 && // Still trackable
                           normalizeActivityName(item.original) === normalizedName; // Same normalized name
                });
            
            if (similarItems.length > 0) {
                showBulkActionModal(actionItem, similarItems, actionType);
            }
        }
        
        // Show modal for bulk action on similar items
        function showBulkActionModal(actionItem, similarItems, actionType) {
            const actionText = actionType === 'accept' ? 'accept' : 'reject';
            const actionIcon = actionType === 'accept' ? '‚úÖ' : '‚ùå';
            const actionColor = actionType === 'accept' ? '#16a34a' : '#dc2626';
            
            // Create modal overlay
            const modalOverlay = document.createElement('div');
            modalOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.5);
                z-index: 1000;
                display: flex;
                justify-content: center;
                align-items: center;
            `;
            
            // Create modal content
            const modal = document.createElement('div');
            modal.style.cssText = `
                background: white;
                border-radius: 12px;
                padding: 24px;
                max-width: 600px;
                width: 90%;
                max-height: 70vh;
                overflow-y: auto;
                box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
            `;
            
            modal.innerHTML = 
                '<div style="margin-bottom: 20px;">' +
                    '<h3 style="margin: 0 0 8px 0; color: #1f2937; font-size: 18px; font-weight: 600;">' +
                        actionIcon + ' Bulk ' + actionText.charAt(0).toUpperCase() + actionText.slice(1) + ' Similar Activities' +
                    '</h3>' +
                    '<p style="margin: 0; color: #6b7280; font-size: 14px; line-height: 1.5;">' +
                        'Found ' + similarItems.length + ' similar activities. Would you like to ' + actionText + ' them all?' +
                    '</p>' +
                '</div>' +
                
                '<div style="background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 8px; padding: 12px; margin-bottom: 20px;">' +
                    '<div style="font-size: 12px; color: #6b7280; margin-bottom: 6px;">You just ' + (actionType === 'accept' ? 'accepted' : 'rejected') + ':</div>' +
                    '<div style="font-weight: 500; color: #1f2937;">"' + actionItem.original + '"</div>' +
                    '<div style="font-size: 12px; color: #6b7280; margin-top: 4px;">‚Üí ' + actionItem.suggested + '</div>' +
                '</div>' +
                
                '<div style="margin-bottom: 20px;">' +
                    '<div style="font-size: 14px; font-weight: 500; color: #374151; margin-bottom: 8px;">Similar activities:</div>' +
                    '<div style="max-height: 200px; overflow-y: auto; border: 1px solid #e5e7eb; border-radius: 6px;">' +
                        similarItems.map(({ item, index }) => 
                            '<div style="padding: 8px 12px; border-bottom: 1px solid #f3f4f6; font-size: 13px;">' +
                                '<div style="color: #1f2937;">"' + item.original + '"</div>' +
                                '<div style="color: #6b7280; font-size: 11px;">‚Üí ' + item.suggested + ' (' + item.confidence + '% confidence)</div>' +
                            '</div>'
                        ).join('') +
                    '</div>' +
                '</div>' +
                
                '<div style="display: flex; gap: 12px; justify-content: flex-end;">' +
                    '<button onclick="closeBulkActionModal()" style="background: #f3f4f6; color: #374151; border: none; padding: 8px 16px; border-radius: 6px; font-size: 14px; cursor: pointer;">' +
                        'Skip' +
                    '</button>' +
                    '<button onclick="applyBulkAction(&quot;' + actionType + '&quot;, [' + similarItems.map(s => s.index).join(',') + '])" ' +
                            'style="background: ' + actionColor + '; color: white; border: none; padding: 8px 16px; border-radius: 6px; font-size: 14px; cursor: pointer;">' +
                        actionIcon + ' ' + actionText.charAt(0).toUpperCase() + actionText.slice(1) + ' All ' + similarItems.length +
                    '</button>' +
                '</div>';
            
            modalOverlay.appendChild(modal);
            document.body.appendChild(modalOverlay);
            
            // Store reference for cleanup
            window.currentBulkModal = modalOverlay;
        }
        
        // Close bulk action modal
        function closeBulkActionModal() {
            if (window.currentBulkModal) {
                document.body.removeChild(window.currentBulkModal);
                window.currentBulkModal = null;
            }
        }
        
        // Apply bulk action to similar items
        function applyBulkAction(actionType, indices) {
            let processedCount = 0;
            
            indices.forEach(index => {
                if (actionType === 'accept') {
                    // Apply accept without triggering another modal
                    parsedItems[index].acceptedByUser = true;
                    parsedItems[index].userAction = 'accepted';
                    acceptedMappings.push(parsedItems[index]);
                    processedCount++;
                } else if (actionType === 'reject') {
                    // Apply reject without triggering another modal
                    const rejectedItem = parsedItems[index];
                    
                    // Add to rejection draft list
                    rejectedMappings.push({
                        original: rejectedItem.original,
                        suggested: rejectedItem.suggested,
                        trade: rejectedItem.trade,
                        confidence: rejectedItem.confidence,
                        reason: 'User bulk rejected',
                        timestamp: new Date().toISOString(),
                        buildingType: AppState.config.selectedBuildingType || 'Unknown'
                    });
                    
                    // Add to learning database
                    if (rejectedItem.tradeId && rejectedItem.suggested !== 'No Match') {
                        addRejectionToLearning(
                            rejectedItem.original, 
                            rejectedItem.suggested, 
                            rejectedItem.tradeId, 
                            'User bulk rejected'
                        );
                    }
                    
                    // Update item state
                    parsedItems[index] = { 
                        ...rejectedItem, 
                        confidence: 0, 
                        suggested: 'Rejected', 
                        status: 'User Rejected',
                        rejectedByUser: true,
                        userAction: 'rejected'
                    };
                    processedCount++;
                }
            });
            
            // Update UI
            renderParsedItems();
            updateGanttChart();
            updateRejectionCount();
            
            console.log(`üîÑ Bulk ${actionType}ed ${processedCount} similar activities`);
            
            // Close modal
            closeBulkActionModal();
        }
        // Drag and drop functionality for 1-hour setup
        let dragState1Hour = {
            isDragging: false,
            isResizing: false,
            tradeIndex: null,
            startX: 0,
            startLeft: 0,
            startWidth: 0,
            weekWidth: 120
        };

        function startDrag1Hour(event, tradeIndex) {
            if (event.target.classList.contains('timeline-bar-resize-handle')) {
                return; // Don't drag when clicking resize handle
            }
            
            event.preventDefault();
            event.stopPropagation();
            
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const bar = event.currentTarget;
            
            dragState1Hour.isDragging = true;
            dragState1Hour.tradeIndex = tradeIndex;
            dragState1Hour.startX = clientX;
            dragState1Hour.startLeft = parseInt(bar.style.left);
            dragState1Hour.weekWidth = 120; // Fixed week width in 1-hour setup
            
            bar.classList.add('dragging');
            
            document.addEventListener('mousemove', handleDrag1Hour);
            document.addEventListener('mouseup', stopDrag1Hour);
            document.addEventListener('touchmove', handleDrag1Hour, { passive: false });
            document.addEventListener('touchend', stopDrag1Hour);
        }

        function startResize1Hour(event, tradeIndex) {
            event.preventDefault();
            event.stopPropagation();
            
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const bar = event.currentTarget.parentElement;
            
            dragState1Hour.isResizing = true;
            dragState1Hour.tradeIndex = tradeIndex;
            dragState1Hour.startX = clientX;
            dragState1Hour.startWidth = parseInt(bar.style.width);
            dragState1Hour.weekWidth = 120;
            
            bar.classList.add('dragging');
            
            document.addEventListener('mousemove', handleResize1Hour);
            document.addEventListener('mouseup', stopResize1Hour);
            document.addEventListener('touchmove', handleResize1Hour, { passive: false });
            document.addEventListener('touchend', stopResize1Hour);
        }

        function handleDrag1Hour(event) {
            if (!dragState1Hour.isDragging) return;
            
            event.preventDefault();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const deltaX = clientX - dragState1Hour.startX;
            const newLeft = Math.max(0, dragState1Hour.startLeft + deltaX);
            
            const bar = document.querySelector(`[data-trade-index="${dragState1Hour.tradeIndex}"]`);
            if (bar) {
                bar.style.left = `${newLeft}px`;
            }
        }

        function handleResize1Hour(event) {
            if (!dragState1Hour.isResizing) return;
            
            event.preventDefault();
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const deltaX = clientX - dragState1Hour.startX;
            const newWidth = Math.max(dragState1Hour.weekWidth, dragState1Hour.startWidth + deltaX);
            
            const bar = document.querySelector(`[data-trade-index="${dragState1Hour.tradeIndex}"]`);
            if (bar) {
                bar.style.width = `${newWidth}px`;
            }
        }

        function stopDrag1Hour(event) {
            if (!dragState1Hour.isDragging) return;
            
            const bar = document.querySelector(`[data-trade-index="${dragState1Hour.tradeIndex}"]`);
            if (bar) {
                bar.classList.remove('dragging');
                
                // Update the parsed item data
                const newLeft = parseInt(bar.style.left);
                const newStartWeek = Math.max(1, Math.round((newLeft - 10) / dragState1Hour.weekWidth) + 1);
                
                if (parsedItems[dragState1Hour.tradeIndex]) {
                    parsedItems[dragState1Hour.tradeIndex].startWeek = newStartWeek;
                    console.log(`üìÖ Moved ${parsedItems[dragState1Hour.tradeIndex].suggested} to start on week ${newStartWeek}`);
                }
            }
            
            dragState1Hour.isDragging = false;
            dragState1Hour.tradeIndex = null;
            
            document.removeEventListener('mousemove', handleDrag1Hour);
            document.removeEventListener('mouseup', stopDrag1Hour);
            document.removeEventListener('touchmove', handleDrag1Hour);
            document.removeEventListener('touchend', stopDrag1Hour);
        }

        function stopResize1Hour(event) {
            if (!dragState1Hour.isResizing) return;
            
            const bar = document.querySelector(`[data-trade-index="${dragState1Hour.tradeIndex}"]`);
            if (bar) {
                bar.classList.remove('dragging');
                
                // Update the parsed item data
                const newWidth = parseInt(bar.style.width);
                const newDurationWeeks = Math.max(1, Math.round((newWidth + 20) / dragState1Hour.weekWidth));
                
                if (parsedItems[dragState1Hour.tradeIndex]) {
                    parsedItems[dragState1Hour.tradeIndex].duration = newDurationWeeks;
                    console.log(`‚è±Ô∏è Resized ${parsedItems[dragState1Hour.tradeIndex].suggested} to ${newDurationWeeks} weeks`);
                }
            }
            
            dragState1Hour.isResizing = false;
            dragState1Hour.tradeIndex = null;
            
            document.removeEventListener('mousemove', handleResize1Hour);
            document.removeEventListener('mouseup', stopResize1Hour);
            document.removeEventListener('touchmove', handleResize1Hour);
            document.removeEventListener('touchend', stopResize1Hour);
        }

        // Review Modal Functions for 1-hour setup
        function openReviewModal1Hour() {
            if (!parsedItems || parsedItems.length === 0) {
                alert('Please upload and process a schedule first before sending for review.');
                return;
            }
            
            // Capture Gantt chart screenshot
            captureGanttScreenshot1Hour();
            
            // Show modal
            document.getElementById('reviewModal').style.display = 'flex';
        }

        function closeReviewModal1Hour() {
            document.getElementById('reviewModal').style.display = 'none';
            document.getElementById('reviewEmail').value = '';
        }

        function captureGanttScreenshot1Hour() {
            const ganttChart = document.querySelector('.timeline-gantt-wrapper');
            const screenshotContainer = document.getElementById('ganttScreenshot');
            
            if (ganttChart) {
                // Clone the Gantt chart for screenshot
                const clone = ganttChart.cloneNode(true);
                clone.style.transform = 'scale(0.6)';
                clone.style.transformOrigin = 'top left';
                clone.style.width = '166.67%'; // Compensate for scale
                clone.style.height = 'auto';
                clone.style.maxHeight = '400px';
                clone.style.overflow = 'hidden';
                
                // Clear previous screenshot
                screenshotContainer.innerHTML = '';
                screenshotContainer.appendChild(clone);
            } else {
                screenshotContainer.innerHTML = `
                    <div style="padding: 40px; text-align: center; color: #6b7280;">
                        <div style="font-size: 48px; margin-bottom: 16px;">üìä</div>
                        <div>No timeline generated yet</div>
                    </div>
                `;
            }
        }

        function sendForReview1Hour() {
            const email = document.getElementById('reviewEmail').value;
            
            if (!email) {
                alert('Please enter a reviewer email address.');
                return;
            }
            
            if (!email.match(/^[^\s@]+@[^\s@]+\.[^\s@]+$/)) {
                alert('Please enter a valid email address.');
                return;
            }
            
            // Count accepted and rejected items
            const acceptedCount = parsedItems.filter(item => item.acceptedByUser).length;
            const rejectedCount = parsedItems.filter(item => item.rejectedByUser).length;
            
            // Simulate sending email
            const projectData = {
                buildingType: AppState.config.selectedBuildingType,
                totalActivities: parsedItems.length,
                acceptedTrades: acceptedCount,
                rejectedTrades: rejectedCount,
                pendingReview: parsedItems.length - acceptedCount - rejectedCount
            };
            
            console.log('üìß Sending project for review:', {
                email: email,
                project: projectData
            });
            
            // Show success message
            alert(`‚úÖ Project timeline sent successfully to ${email}!\n\nIncludes:\n‚Ä¢ ${projectData.totalActivities} total activities\n‚Ä¢ ${projectData.acceptedTrades} accepted trades\n‚Ä¢ ${projectData.rejectedTrades} rejected trades\n‚Ä¢ ${projectData.pendingReview} pending review`);
            
            // Close modal
            closeReviewModal1Hour();
        }

        // Close modal when clicking outside
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('reviewModal');
            if (event.target === modal) {
                closeReviewModal1Hour();
            }
        });
    </script>

    <!-- Review Modal -->
    <div id="reviewModal" class="review-modal">
        <div class="review-modal-content">
            <div class="review-modal-header">
                <h3 class="review-modal-title">üìß Send Project for Review</h3>
                <button class="review-modal-close" onclick="closeReviewModal1Hour()">&times;</button>
            </div>
            
            <div class="review-modal-body">
                <div class="review-section">
                    <div class="review-section-title">Project Timeline Preview</div>
                    <div id="ganttScreenshot" class="gantt-screenshot">
                        <!-- Screenshot will be inserted here -->
                    </div>
                </div>
                
                <div class="review-section">
                    <div class="review-section-title">Send to Email</div>
                    <input 
                        type="email" 
                        id="reviewEmail" 
                        class="email-field" 
                        placeholder="Enter reviewer's email address"
                        required>
                </div>
            </div>
            
            <div class="review-modal-footer">
                <button class="btn-cancel" onclick="closeReviewModal1Hour()">Cancel</button>
                <button class="btn-primary" onclick="sendForReview1Hour()">üì§ Send for Review</button>
            </div>
        </div>
    </div>
</body>
</html>
