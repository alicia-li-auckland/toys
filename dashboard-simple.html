<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Construction Analytics Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        .tab-button.active {
            border-bottom: 2px solid #3b82f6;
            color: #2563eb;
            background-color: #eff6ff;
        }
        .anomaly-tile {
            transition: all 0.2s;
            cursor: pointer;
        }
        .anomaly-tile:hover {
            border-color: #d1d5db;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }
        .filter-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            z-index: 50;
            max-height: 200px;
            overflow-y: auto;
        }
        .filter-option {
            padding: 0.5rem;
            cursor: pointer;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .filter-option:hover {
            background-color: #f3f4f6;
        }
        .filter-option.selected {
            background-color: #eff6ff;
            color: #2563eb;
        }
        .filter-checkbox {
            width: 12px;
            height: 12px;
            border: 1px solid #d1d5db;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .filter-checkbox.checked {
            background-color: #3b82f6;
            border-color: #3b82f6;
            color: white;
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="root" class="min-h-screen p-6">
        <div class="max-w-7xl mx-auto">
            <!-- Header -->
            <div class="mb-8">
                <h1 class="text-3xl font-bold text-gray-900 mb-2">Construction Analytics Dashboard</h1>
                <p class="text-gray-600">Comprehensive analytics for construction project insights</p>
            </div>

            <!-- CSV Upload Section -->
            <div id="upload-section" class="min-h-screen flex items-center justify-center">
                <div class="max-w-2xl w-full">
                    <div class="text-center mb-8">
                        <svg class="w-16 h-16 text-blue-600 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                        </svg>
                        <h1 class="text-3xl font-bold text-gray-900 mb-2">Construction Analytics Dashboard</h1>
                        <p class="text-gray-600">Upload your construction data CSV to get started</p>
                    </div>
                    
                    <div id="dropzone" class="bg-white p-8 rounded-lg shadow-sm border-2 border-dashed border-gray-300 hover:border-blue-400 transition-colors cursor-pointer">
                        <div class="text-center">
                            <svg class="w-12 h-12 text-gray-400 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                            </svg>
                            <h3 class="text-lg font-semibold text-gray-900 mb-2">Upload CSV File</h3>
                            <p class="text-gray-600 mb-4">
                                Drag and drop your construction data CSV file here, or click to browse
                            </p>
                            <p class="text-sm text-gray-500 mb-4">
                                Expected columns: trade, location, state/status, level/floor, section, capture_date, complete_date
                            </p>
                            <button class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">
                                Choose File
                            </button>
                            <p class="text-xs text-gray-400 mt-2">Upload your CSV file to begin analysis</p>
                        </div>
                        
                        <input type="file" id="csvFile" accept=".csv" class="hidden">
                    </div>
                    
                    <div id="upload-progress" class="hidden mt-6">
                        <div class="text-center">
                            <div class="inline-flex items-center gap-2 text-blue-600">
                                <svg class="animate-spin h-4 w-4" fill="none" viewBox="0 0 24 24">
                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                    <path class="opacity-75" fill="currentColor" d="m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                                <span id="upload-status">Processing CSV file...</span>
                            </div>
                        </div>
                    </div>

                    <div id="upload-error" class="hidden mt-6 p-4 bg-red-50 border border-red-200 rounded-lg">
                        <div class="flex">
                            <svg class="w-5 h-5 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                            </svg>
                            <div class="ml-3">
                                <h3 class="text-sm font-medium text-red-800">Error processing file</h3>
                                <p id="error-message" class="text-sm text-red-700 mt-1"></p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Loading State -->
            <div id="loading" class="min-h-screen flex items-center justify-center hidden">
                <div class="text-center">
                    <svg class="w-12 h-12 text-gray-400 mx-auto mb-4 animate-pulse" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                    </svg>
                    <p class="text-gray-600">Loading construction analytics...</p>
                </div>
            </div>

            <!-- Main Dashboard -->
            <div id="dashboard" class="hidden">
                <!-- File Info & Filters -->
                <div class="bg-white p-4 rounded-lg shadow-sm border border-gray-200 mb-6">
                    <div class="flex items-center justify-between mb-4">
                        <div class="flex items-center gap-3">
                            <svg class="w-5 h-5 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            <div>
                                <p class="text-sm font-medium text-gray-900" id="file-info">Data loaded successfully</p>
                                <p class="text-xs text-gray-500" id="data-stats">Processing data...</p>
                            </div>
                        </div>
                        <button onclick="reloadData()" class="text-blue-600 hover:text-blue-800 text-sm font-medium">
                            Upload New File
                        </button>
                    </div>
                    
                    <div class="flex items-center gap-6 flex-wrap">
                        <div class="flex items-center gap-2">
                            <svg class="w-4 h-4 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4a1 1 0 011-1h16a1 1 0 011 1v2.586a1 1 0 01-.293.707l-6.414 6.414a1 1 0 00-.293.707V17l-4 4v-6.586a1 1 0 00-.293-.707L3.293 7.414A1 1 0 013 6.707V4z"></path>
                            </svg>
                            <span class="text-sm font-medium text-gray-700">Filters:</span>
                        </div>
                        
                        <div class="flex items-center gap-2">
                            <label class="text-xs text-gray-600">Level:</label>
                            <div class="relative">
                                <div id="levelFilterDisplay" class="text-xs border rounded px-2 py-1 min-w-24 bg-white cursor-pointer hover:bg-gray-50 flex items-center justify-between">
                                    <span>All Levels</span>
                                    <svg class="w-3 h-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                    </svg>
                                </div>
                            </div>
                        </div>
                        
                        <div class="flex items-center gap-2">
                            <label class="text-xs text-gray-600">Section:</label>
                            <div class="relative">
                                <div id="sectionFilterDisplay" class="text-xs border rounded px-2 py-1 min-w-24 bg-white cursor-pointer hover:bg-gray-50 flex items-center justify-between">
                                    <span>All Sections</span>
                                    <svg class="w-3 h-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                    </svg>
                                </div>
                            </div>
                        </div>
                        
                        <div class="flex items-center gap-2">
                            <label class="text-xs text-gray-600">Trade:</label>
                            <div class="relative">
                                <div id="tradeFilterDisplay" class="text-xs border rounded px-2 py-1 min-w-32 bg-white cursor-pointer hover:bg-gray-50 flex items-center justify-between">
                                    <span>All Trades</span>
                                    <svg class="w-3 h-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                    </svg>
                                </div>
                            </div>
                        </div>
                        
                        <div class="flex items-center gap-2">
                            <label class="text-xs text-gray-600">Time:</label>
                            <div class="relative">
                                <div id="timeFilterDisplay" class="text-xs border rounded px-2 py-1 min-w-32 bg-white cursor-pointer hover:bg-gray-50 flex items-center justify-between">
                                    <span>All Time</span>
                                    <svg class="w-3 h-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                    </svg>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Navigation Tabs -->
                <div class="bg-white rounded-lg shadow-sm border border-gray-200 mb-6">
                    <div class="flex border-b border-gray-200">
                        <button onclick="switchTab('executive')" class="tab-button px-6 py-3 text-sm font-medium border-b-2 border-transparent text-gray-500" id="executive-tab">
                            Executive Dashboard
                        </button>
                        <button onclick="switchTab('overview')" class="tab-button active px-6 py-3 text-sm font-medium border-b-2 border-blue-500 text-blue-600" id="overview-tab">
                            Project Overview
                        </button>
                        <button onclick="switchTab('anomalies')" class="tab-button px-6 py-3 text-sm font-medium border-b-2 border-transparent text-gray-500" id="anomalies-tab">
                            Trade Anomalies
                        </button>
                    </div>
                </div>

                <!-- Tab Content -->
                <div id="tab-content">
                    <!-- Executive Dashboard -->
                    <div id="executive-content" class="space-y-6 hidden">
                        <!-- Row 1: Key Metrics Cards -->
                        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
                            <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <p class="text-sm font-medium text-gray-600">Project Completion</p>
                                        <p class="text-3xl font-bold text-blue-600" id="completion-rate">0%</p>
                                        <p class="text-xs text-gray-500" id="completion-tasks">0 of 0 tasks</p>
                                    </div>
                                    <div class="w-10 h-10 bg-blue-100 rounded-full flex items-center justify-center">
                                        <svg class="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                        </svg>
                                    </div>
                                </div>
                            </div>

                            <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <p class="text-sm font-medium text-gray-600">Completion Rate</p>
                                        <p class="text-3xl font-bold text-green-600" id="work-velocity">0</p>
                                        <p class="text-xs text-gray-500">tasks/day average</p>
                                    </div>
                                    <div class="w-10 h-10 bg-green-100 rounded-full flex items-center justify-center">
                                        <svg class="w-6 h-6 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path>
                                        </svg>
                                    </div>
                                </div>
                            </div>

                            <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <p class="text-sm font-medium text-gray-600">Active Trades</p>
                                        <p class="text-3xl font-bold text-purple-600" id="active-trades">0</p>
                                        <p class="text-xs text-gray-500">currently working</p>
                                    </div>
                                    <div class="w-10 h-10 bg-purple-100 rounded-full flex items-center justify-center">
                                        <svg class="w-6 h-6 text-purple-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
                                        </svg>
                                    </div>
                                </div>
                            </div>

                            <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                                <div class="flex items-center justify-between">
                                    <div>
                                        <p class="text-sm font-medium text-gray-600">Active Locations</p>
                                        <p class="text-3xl font-bold text-orange-600" id="active-locations">0</p>
                                        <p class="text-xs text-gray-500">with ongoing work</p>
                                    </div>
                                    <div class="w-10 h-10 bg-orange-100 rounded-full flex items-center justify-center">
                                        <svg class="w-6 h-6 text-orange-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"></path>
                                        </svg>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Key Insights & Actions -->
                        <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                            <h3 class="text-lg font-semibold text-gray-900 mb-4 flex items-center gap-2">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                                </svg>
                                Key Insights & Actions
                            </h3>
                            <div class="grid grid-cols-1 lg:grid-cols-2 gap-4" id="insights-container">
                                <!-- Insights will be populated by JavaScript -->
                            </div>
                        </div>

                        <!-- Project Milestone Timeline -->
                        <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                            <h3 class="text-lg font-semibold text-gray-900 mb-6 flex items-center gap-2">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                                </svg>
                                Project Milestone Timeline
                            </h3>
                            
                            <!-- Timeline visualization -->
                            <div class="relative">
                                <!-- Timeline line -->
                                <div class="absolute left-6 top-0 bottom-0 w-0.5 bg-gray-300"></div>
                                
                                <div class="space-y-6" id="timeline-container">
                                    <!-- Timeline items will be populated by JavaScript -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Project Overview -->
                    <div id="overview-content" class="space-y-6">
                        <!-- Charts will be dynamically created here -->
                    </div>

                    <!-- Trade Anomalies -->
                    <div id="anomalies-content" class="space-y-6 hidden">
                        <!-- Anomaly Tiles -->
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4" id="anomaly-tiles">
                            <!-- Tiles will be populated by JavaScript -->
                        </div>

                        <!-- Anomaly Detail Chart -->
                        <div id="anomaly-chart-container" class="bg-white p-6 rounded-lg shadow-sm border border-gray-200 hidden">
                            <div class="flex items-center justify-between mb-4">
                                <h3 class="text-lg font-semibold text-gray-900" id="anomaly-chart-title">Anomaly Analysis</h3>
                                <button onclick="closeAnomalyChart()" class="text-gray-400 hover:text-gray-600">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                                    </svg>
                                </button>
                            </div>
                            <div class="h-80">
                                <canvas id="anomalyChart"></canvas>
                            </div>
                        </div>


                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize anomaly types with zero counts - will be updated by analyzeAnomalies()
        let anomalyTypes = [
            { id: 'abandonment', name: 'Trade Abandonment', category: 'Time-based', count: 0, severity: 'high', color: '#ef4444' },
            { id: 'starvation', name: 'Trade Starvation', category: 'Time-based', count: 0, severity: 'high', color: '#ef4444' },
            { id: 'burst_start', name: 'Burst Start', category: 'Time-based', count: 0, severity: 'medium', color: '#f97316' },
            { id: 'swiss_cheese', name: 'Swiss-Cheese Flow', category: 'Spatial', count: 0, severity: 'medium', color: '#f97316' },
            { id: 'blockage', name: 'Trade Blockage', category: 'Cross-trade', count: 0, severity: 'high', color: '#ef4444' },
            { id: 'premature_start', name: 'Premature Start', category: 'Cross-trade', count: 0, severity: 'medium', color: '#f97316' }
        ];

        // Data arrays - start empty until CSV is uploaded
        let currentData = [];
        let filteredData = [];
        let charts = {};

        // Initialize upload functionality
        function initUpload() {
            const dropzone = document.getElementById('dropzone');
            const csvFile = document.getElementById('csvFile');

            // Dropzone click handler
            dropzone.addEventListener('click', () => {
                csvFile.click();
            });

            // File selection handler
            csvFile.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleFileUpload(e.target.files[0]);
                }
            });

            // Drag and drop handlers
            dropzone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropzone.classList.add('border-blue-400', 'bg-blue-50');
            });

            dropzone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                dropzone.classList.remove('border-blue-400', 'bg-blue-50');
            });

            dropzone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropzone.classList.remove('border-blue-400', 'bg-blue-50');
                
                if (e.dataTransfer.files.length > 0) {
                    const file = e.dataTransfer.files[0];
                    if (file.type === 'text/csv' || file.name.endsWith('.csv')) {
                        handleFileUpload(file);
                    } else {
                        showError('Please upload a CSV file.');
                    }
                }
            });


        }

        // Handle CSV file upload
        function handleFileUpload(file) {
            if (!file.name.endsWith('.csv')) {
                showError('Please select a CSV file.');
                return;
            }

            showProgress('Reading CSV file...');

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvContent = e.target.result;
                    parseCSV(csvContent);
                } catch (error) {
                    showError('Error reading file: ' + error.message);
                }
            };
            reader.onerror = function() {
                showError('Error reading file.');
            };
            reader.readAsText(file);
        }

        // Parse CSV content
        function parseCSV(csvContent) {
            showProgress('Processing CSV data...');

            try {
                const lines = csvContent.trim().split('\n');
                if (lines.length < 2) {
                    throw new Error('CSV file must contain at least a header row and one data row.');
                }

                const headers = lines[0].split(',').map(h => h.replace(/"/g, '').trim().toLowerCase());
                const data = [];

                for (let i = 1; i < lines.length; i++) {
                    const values = lines[i].split(',').map(v => v.replace(/"/g, '').trim());
                    if (values.length !== headers.length) continue; // Skip malformed rows
                    
                    const row = {};
                    headers.forEach((header, index) => {
                        row[header] = values[index] || '';
                    });

                    // Only include rows that have essential data
                    if (row.trade && row.location) {
                        data.push(row);
                    }
                }

                if (data.length === 0) {
                    throw new Error('No valid data rows found. Please ensure your CSV has trade and location columns.');
                }

                // Validate required columns
                const requiredColumns = ['trade', 'location'];
                const missingColumns = requiredColumns.filter(col => !headers.includes(col));
                if (missingColumns.length > 0) {
                    throw new Error(`Missing required columns: ${missingColumns.join(', ')}`);
                }

                // Update data and initialize dashboard
                currentData = data.map(row => ({
                    trade: row.trade,
                    location: row.location,
                    state: row.state || row.status || 'unknown',
                    level: row.level || row['level / floor'] || row.floor || '1',
                    section: row.section || 'A',
                    capture_date: row.capture_date || row.date || new Date().toISOString().split('T')[0],
                    complete_date: row.complete_date || row.completion_date || null
                }));

                filteredData = [...currentData];
                
                showProgress('Initializing dashboard...');
                setTimeout(() => {
                    initDashboard();
                }, 500);

            } catch (error) {
                showError('Error parsing CSV: ' + error.message);
            }
        }



        // Initialize dashboard
        function initDashboard() {
            document.getElementById('upload-section').classList.add('hidden');
            document.getElementById('loading').classList.remove('hidden');
            
            setTimeout(() => {
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('dashboard').classList.remove('hidden');
                
                updateDataStats();
                populateFilters();
                updateMetrics();
                
                // Analyze anomalies with real data before rendering tiles
                analyzeAnomalies(currentData);
                renderAnomalyTiles();
                
                renderInsights();
                renderTimeline();
                
                // Initialize Project Overview tab since it's the default
                switchTab('overview');
            }, 1000);
        }

        // Update data statistics
        function updateDataStats() {
            const totalRows = currentData.length;
            const uniqueTrades = [...new Set(currentData.map(row => row.trade))].length;
            const uniqueLocations = [...new Set(currentData.map(row => row.location))].length;
            
            document.getElementById('data-stats').textContent = 
                `${totalRows} tasks • ${uniqueTrades} trades • ${uniqueLocations} locations`;
        }

        // Reload data (go back to upload)
        function reloadData() {
            document.getElementById('dashboard').classList.add('hidden');
            document.getElementById('upload-section').classList.remove('hidden');
            
            // Reset file input
            document.getElementById('csvFile').value = '';
            document.getElementById('upload-progress').classList.add('hidden');
            document.getElementById('upload-error').classList.add('hidden');
        }

        // Show upload progress
        function showProgress(message) {
            document.getElementById('upload-error').classList.add('hidden');
            document.getElementById('upload-progress').classList.remove('hidden');
            document.getElementById('upload-status').textContent = message;
        }

        // Show error message
        function showError(message) {
            document.getElementById('upload-progress').classList.add('hidden');
            document.getElementById('upload-error').classList.remove('hidden');
            document.getElementById('error-message').textContent = message;
        }

        // Multi-select filter state
        const filterState = {
            levels: [],
            sections: [],
            trades: [],
            time: []
        };

        // Populate filter dropdowns with multi-select functionality
        function populateFilters() {
            const levels = [...new Set(currentData.map(row => row.level))].sort();
            const sections = [...new Set(currentData.map(row => row.section).filter(Boolean))].sort();
            const trades = [...new Set(currentData.map(row => row.trade))].sort();
            const captureDates = [...new Set(currentData.map(row => row.capture_date).filter(Boolean))].sort();

            // Initialize filter state
            filterState.levels = [];
            filterState.sections = [];
            filterState.trades = [];
            filterState.time = [];

            // Setup multi-select for levels
            setupMultiSelect('level', levels, (level) => `Level ${level}`);
            
            // Setup multi-select for sections
            setupMultiSelect('section', sections, (section) => `Section ${section}`);
            
            // Setup multi-select for trades
            setupMultiSelect('trade', trades, (trade) => trade);
            
            // Setup multi-select for time with special handling
            setupTimeFilter(captureDates);
        }

        // Setup multi-select dropdown functionality
        function setupMultiSelect(filterType, options, labelFormatter) {
            const display = document.getElementById(`${filterType}FilterDisplay`);
            const container = display.parentElement;
            
            // Remove existing dropdown if any
            const existingDropdown = container.querySelector('.filter-dropdown');
            if (existingDropdown) {
                existingDropdown.remove();
            }

            // Create dropdown
            const dropdown = document.createElement('div');
            dropdown.className = 'filter-dropdown hidden';
            
            // Add "All" option
            const allOption = document.createElement('div');
            allOption.className = 'filter-option selected';
            allOption.innerHTML = `
                <div class="filter-checkbox checked">✓</div>
                <span>All ${filterType.charAt(0).toUpperCase() + filterType.slice(1)}s</span>
            `;
            allOption.onclick = () => selectAllOptions(filterType, dropdown, display);
            dropdown.appendChild(allOption);

            // Add individual options
            options.forEach(option => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'filter-option';
                optionDiv.innerHTML = `
                    <div class="filter-checkbox"></div>
                    <span>${labelFormatter(option)}</span>
                `;
                optionDiv.dataset.value = option;
                optionDiv.onclick = () => toggleOption(filterType, option, optionDiv, dropdown, display);
                dropdown.appendChild(optionDiv);
            });

            container.appendChild(dropdown);

            // Toggle dropdown on display click
            display.onclick = () => {
                dropdown.classList.toggle('hidden');
                // Close other dropdowns
                document.querySelectorAll('.filter-dropdown').forEach(d => {
                    if (d !== dropdown) d.classList.add('hidden');
                });
            };

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!container.contains(e.target)) {
                    dropdown.classList.add('hidden');
                }
            });
        }

        // Setup time filter with both individual dates and period options
        function setupTimeFilter(captureDates) {
            const display = document.getElementById('timeFilterDisplay');
            const container = display.parentElement;
            
            // Remove existing dropdown if any
            const existingDropdown = container.querySelector('.filter-dropdown');
            if (existingDropdown) {
                existingDropdown.remove();
            }

            // Create dropdown
            const dropdown = document.createElement('div');
            dropdown.className = 'filter-dropdown hidden';
            
            // Add "All Time" option
            const allOption = document.createElement('div');
            allOption.className = 'filter-option selected';
            allOption.innerHTML = `
                <div class="filter-checkbox checked">✓</div>
                <span>All Time</span>
            `;
            allOption.onclick = () => selectAllTimeOptions(dropdown, display);
            dropdown.appendChild(allOption);

            // Add period options
            const periods = [
                { id: 'last_week', label: 'Last 7 Days' },
                { id: 'last_2_weeks', label: 'Last 2 Weeks' },
                { id: 'last_month', label: 'Last 30 Days' }
            ];

            periods.forEach(period => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'filter-option';
                optionDiv.innerHTML = `
                    <div class="filter-checkbox"></div>
                    <span>${period.label}</span>
                `;
                optionDiv.dataset.value = period.id;
                optionDiv.onclick = () => toggleTimePeriod(period.id, optionDiv, dropdown, display, captureDates);
                dropdown.appendChild(optionDiv);
            });

            // Add separator
            const separator = document.createElement('div');
            separator.className = 'border-t border-gray-200 my-1';
            dropdown.appendChild(separator);

            // Add individual capture dates
            captureDates.forEach(date => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'filter-option';
                optionDiv.innerHTML = `
                    <div class="filter-checkbox"></div>
                    <span>${date}</span>
                `;
                optionDiv.dataset.value = date;
                optionDiv.onclick = () => toggleTimeOption(date, optionDiv, dropdown, display);
                dropdown.appendChild(optionDiv);
            });

            container.appendChild(dropdown);

            // Toggle dropdown on display click
            display.onclick = () => {
                dropdown.classList.toggle('hidden');
                // Close other dropdowns
                document.querySelectorAll('.filter-dropdown').forEach(d => {
                    if (d !== dropdown) d.classList.add('hidden');
                });
            };

            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (!container.contains(e.target)) {
                    dropdown.classList.add('hidden');
                }
            });
        }

        // Helper functions for multi-select
        function selectAllOptions(filterType, dropdown, display) {
            // Clear current selection
            filterState[filterType + 's'] = [];
            
            // Update visual state
            dropdown.querySelectorAll('.filter-option').forEach((option, index) => {
                option.classList.remove('selected');
                const checkbox = option.querySelector('.filter-checkbox');
                checkbox.classList.remove('checked');
                checkbox.textContent = '';
                
                // Select "All" option (first option)
                if (index === 0) {
                    option.classList.add('selected');
                    checkbox.classList.add('checked');
                    checkbox.textContent = '✓';
                }
            });
            
            // Update display
            updateFilterDisplay(filterType, display);
            
            // Apply filters
            applyFilters();
        }

        function toggleOption(filterType, value, optionDiv, dropdown, display) {
            const filterArray = filterState[filterType + 's'];
            const allOption = dropdown.querySelector('.filter-option');
            const checkbox = optionDiv.querySelector('.filter-checkbox');
            const allCheckbox = allOption.querySelector('.filter-checkbox');
            
            if (filterArray.includes(value)) {
                // Remove from selection
                const index = filterArray.indexOf(value);
                filterArray.splice(index, 1);
                optionDiv.classList.remove('selected');
                checkbox.classList.remove('checked');
                checkbox.textContent = '';
            } else {
                // Add to selection
                filterArray.push(value);
                optionDiv.classList.add('selected');
                checkbox.classList.add('checked');
                checkbox.textContent = '✓';
                
                // Remove "All" selection when individual items are selected
                allOption.classList.remove('selected');
                allCheckbox.classList.remove('checked');
                allCheckbox.textContent = '';
            }
            
            // If no individual options selected, select "All"
            if (filterArray.length === 0) {
                allOption.classList.add('selected');
                allCheckbox.classList.add('checked');
                allCheckbox.textContent = '✓';
            }
            
            updateFilterDisplay(filterType, display);
            applyFilters();
        }

        function updateFilterDisplay(filterType, display) {
            const filterArray = filterState[filterType + 's'];
            const textSpan = display.querySelector('span');
            
            if (filterArray.length === 0) {
                textSpan.textContent = `All ${filterType.charAt(0).toUpperCase() + filterType.slice(1)}s`;
            } else if (filterArray.length === 1) {
                const label = filterType === 'level' ? `Level ${filterArray[0]}` : 
                             filterType === 'section' ? `Section ${filterArray[0]}` : 
                             filterArray[0];
                textSpan.textContent = label;
            } else {
                textSpan.textContent = `${filterArray.length} ${filterType.charAt(0).toUpperCase() + filterType.slice(1)}s`;
            }
        }

        // Time filter helper functions
        function selectAllTimeOptions(dropdown, display) {
            filterState.time = [];
            
            dropdown.querySelectorAll('.filter-option').forEach((option, index) => {
                option.classList.remove('selected');
                const checkbox = option.querySelector('.filter-checkbox');
                checkbox.classList.remove('checked');
                checkbox.textContent = '';
                
                if (index === 0) {
                    option.classList.add('selected');
                    checkbox.classList.add('checked');
                    checkbox.textContent = '✓';
                }
            });
            
            updateTimeFilterDisplay(display);
            applyFilters();
        }

        function toggleTimePeriod(periodId, optionDiv, dropdown, display, captureDates) {
            const allOption = dropdown.querySelector('.filter-option');
            const checkbox = optionDiv.querySelector('.filter-checkbox');
            const allCheckbox = allOption.querySelector('.filter-checkbox');
            
            // Clear all other selections
            dropdown.querySelectorAll('.filter-option').forEach(option => {
                option.classList.remove('selected');
                const cb = option.querySelector('.filter-checkbox');
                cb.classList.remove('checked');
                cb.textContent = '';
            });
            
            // Select this period
            optionDiv.classList.add('selected');
            checkbox.classList.add('checked');
            checkbox.textContent = '✓';
            
            // Calculate dates for this period
            const now = new Date();
            let daysBack = 7;
            if (periodId === 'last_2_weeks') daysBack = 14;
            if (periodId === 'last_month') daysBack = 30;
            
            const cutoffDate = new Date(now.getTime() - (daysBack * 24 * 60 * 60 * 1000));
            filterState.time = captureDates.filter(date => new Date(date) >= cutoffDate);
            
            updateTimeFilterDisplay(display);
            applyFilters();
        }

        function toggleTimeOption(date, optionDiv, dropdown, display) {
            const allOption = dropdown.querySelector('.filter-option');
            const checkbox = optionDiv.querySelector('.filter-checkbox');
            const allCheckbox = allOption.querySelector('.filter-checkbox');
            
            if (filterState.time.includes(date)) {
                const index = filterState.time.indexOf(date);
                filterState.time.splice(index, 1);
                optionDiv.classList.remove('selected');
                checkbox.classList.remove('checked');
                checkbox.textContent = '';
            } else {
                filterState.time.push(date);
                optionDiv.classList.add('selected');
                checkbox.classList.add('checked');
                checkbox.textContent = '✓';
                allOption.classList.remove('selected');
                allCheckbox.classList.remove('checked');
                allCheckbox.textContent = '';
            }
            
            if (filterState.time.length === 0) {
                allOption.classList.add('selected');
                allCheckbox.classList.add('checked');
                allCheckbox.textContent = '✓';
            }
            
            updateTimeFilterDisplay(display);
            applyFilters();
        }

        function updateTimeFilterDisplay(display) {
            const textSpan = display.querySelector('span');
            
            if (filterState.time.length === 0) {
                textSpan.textContent = 'All Time';
            } else if (filterState.time.length === 1) {
                textSpan.textContent = filterState.time[0];
            } else {
                textSpan.textContent = `${filterState.time.length} Days`;
            }
        }

        // Apply filters with multi-select support
        function applyFilters() {
            filteredData = currentData.filter(row => {
                const levelMatch = filterState.levels.length === 0 || filterState.levels.includes(row.level);
                const sectionMatch = filterState.sections.length === 0 || filterState.sections.includes(row.section);
                const tradeMatch = filterState.trades.length === 0 || filterState.trades.includes(row.trade);
                const timeMatch = filterState.time.length === 0 || filterState.time.includes(row.capture_date);
                
                return levelMatch && sectionMatch && tradeMatch && timeMatch;
            });

            updateMetrics();
            
            // Re-analyze anomalies with filtered data
            analyzeAnomalies(filteredData);
            renderAnomalyTiles();
            
            updateCharts();
        }

        // Update metrics
        function updateMetrics() {
            const totalTasks = filteredData.length;
            const completedTasks = filteredData.filter(row => row.state === 'complete').length;
            // Count unique trades that have at least one "in progress" task in the filtered data
            const activeTrades = [...new Set(filteredData.filter(row => 
                row.state === 'in progress' || row.state === 'in-progress'
            ).map(row => row.trade))].length;
            const completionRate = totalTasks > 0 ? ((completedTasks / totalTasks) * 100).toFixed(1) : 0;

            // Calculate work velocity (tasks completed per day)
            const completionDates = [...new Set(filteredData
                .filter(row => row.complete_date && row.state === 'complete')
                .map(row => row.complete_date)
            )];
            const workVelocity = completionDates.length > 0 ? 
                Math.round(completedTasks / completionDates.length) : 0;

            // Get last capture date
            const captureDates = [...new Set(filteredData
                .map(row => row.capture_date)
                .filter(Boolean)
            )].sort();
            const lastCaptureDate = captureDates.length > 0 ? 
                captureDates[captureDates.length - 1] : 'N/A';
            
            // Format last capture date for display
            let formattedLastCapture = lastCaptureDate;
            if (lastCaptureDate !== 'N/A') {
                const parts = lastCaptureDate.split('/');
                if (parts.length === 3) {
                    formattedLastCapture = parts[1] + '/' + parts[2]; // MM/DD
                } else {
                    const dateParts = lastCaptureDate.split('-');
                    if (dateParts.length === 3) {
                        formattedLastCapture = dateParts[1] + '/' + dateParts[2]; // MM/DD from YYYY-MM-DD
                    }
                }
            }

            // Count unique locations that have at least one "in progress" task in the filtered data
            const activeLocations = [...new Set(filteredData.filter(row => 
                row.state === 'in progress' || row.state === 'in-progress'
            ).map(row => row.location))].length;

            // Update DOM elements
            document.getElementById('completion-rate').textContent = `${completionRate}%`;
            document.getElementById('completion-tasks').textContent = `${completedTasks} of ${totalTasks} tasks`;
            document.getElementById('active-trades').textContent = activeTrades;
            document.getElementById('work-velocity').textContent = workVelocity > 0 ? `+${workVelocity}` : '0';
            document.getElementById('active-locations').textContent = activeLocations;
        }

        // Switch tabs
        function switchTab(tab) {
            console.log('Switching to tab:', tab);
            
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`${tab}-tab`).classList.add('active');

            // Show/hide content
            if (tab === 'anomalies') {
                console.log('Showing anomalies tab');
                document.getElementById('executive-content').classList.add('hidden');
                document.getElementById('anomalies-content').classList.remove('hidden');
                if (document.getElementById('overview-content')) {
                    document.getElementById('overview-content').classList.add('hidden');
                }
                console.log('Anomalies content visibility:', !document.getElementById('anomalies-content').classList.contains('hidden'));
            } else if (tab === 'overview') {
                document.getElementById('executive-content').classList.add('hidden');
                document.getElementById('anomalies-content').classList.add('hidden');
                
                // Create overview content with charts if it's empty
                const overviewContent = document.getElementById('overview-content');
                if (overviewContent.children.length === 0) {
                    createOverviewTab();
                }
                overviewContent.classList.remove('hidden');
            } else {
                // Executive dashboard
                document.getElementById('executive-content').classList.remove('hidden');
                document.getElementById('anomalies-content').classList.add('hidden');
                if (document.getElementById('overview-content')) {
                    document.getElementById('overview-content').classList.add('hidden');
                }
            }
        }

        // Create overview tab with charts
        function createOverviewTab() {
            const overviewContent = document.getElementById('overview-content');
            overviewContent.innerHTML = `
                <!-- Row 2: Trade Progress Chart -->
                <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                    <h3 class="text-lg font-semibold text-gray-900 mb-4">Trade Progress Over Time</h3>
                    <div class="h-80">
                        <canvas id="progressChart"></canvas>
                    </div>
                </div>

                <!-- Row 3: Velocity Chart -->
                <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                    <h3 class="text-lg font-semibold text-gray-900 mb-4">Daily Completion Velocity</h3>
                    <div class="h-80">
                        <canvas id="velocityChart"></canvas>
                    </div>
                </div>

                <!-- Row 4: Distribution Charts -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                        <h3 class="text-lg font-semibold text-gray-900 mb-4">Trade Distribution</h3>
                        <div class="h-64">
                            <canvas id="distributionChart"></canvas>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-gray-200">
                        <h3 class="text-lg font-semibold text-gray-900 mb-4">Trade Performance</h3>
                        <div class="h-64">
                            <canvas id="performanceChart"></canvas>
                        </div>
                    </div>
                </div>
            `;
            
            // Create charts after DOM is updated
            setTimeout(() => {
                createCharts();
            }, 100);
        }

        // Create charts
        function createCharts() {
            createProgressChart();
            createVelocityChart();
            createDistributionChart();
            createPerformanceChart();
        }

        function createProgressChart() {
            const ctx = document.getElementById('progressChart').getContext('2d');
            
            // Get all unique dates and sort them
            const allDates = [...new Set(filteredData.map(row => row.capture_date).filter(Boolean))].sort();
            const trades = [...new Set(filteredData.map(row => row.trade).filter(Boolean))];
            
            // If no dates, use placeholder
            if (allDates.length === 0) {
                allDates.push(new Date().toISOString().split('T')[0]);
            }
            
            // Format dates for display (MM/DD)
            const dateLabels = allDates.map(date => {
                const parts = date.split('/');
                if (parts.length === 3) {
                    return parts[1] + '/' + parts[2]; // MM/DD
                }
                return date.split('-').slice(1).join('/'); // Handle YYYY-MM-DD format
            });
            
            // Create datasets for each trade
            const datasets = trades.map((trade, index) => {
                const tradeData = allDates.map(date => {
                    const tradeTasksUpToDate = filteredData.filter(row => 
                        row.trade === trade && 
                        row.capture_date <= date
                    );
                    const completedUpToDate = tradeTasksUpToDate.filter(row => 
                        row.state === 'complete' && 
                        row.complete_date && 
                        row.complete_date <= date
                    );
                    const totalTradeTasks = filteredData.filter(row => row.trade === trade).length;
                    
                    return totalTradeTasks > 0 ? Math.round((completedUpToDate.length / totalTradeTasks) * 100) : 0;
                });
                
                const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#06b6d4', '#84cc16'];
                
                return {
                    label: trade,
                    data: tradeData,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '20',
                    tension: 0.1,
                    fill: false
                };
            });
            
            charts.progress = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dateLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: '% Complete'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Capture Date'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    }
                }
            });
        }

        function createVelocityChart() {
            const ctx = document.getElementById('velocityChart').getContext('2d');
            
            // Get all unique completion dates and sort them
            const completionDates = [...new Set(filteredData
                .filter(row => row.complete_date && row.state === 'complete')
                .map(row => row.complete_date)
            )].sort();
            
            const trades = [...new Set(filteredData.map(row => row.trade).filter(Boolean))];
            
            // If no completion dates, show placeholder
            if (completionDates.length === 0) {
                charts.velocity = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: ['No Data'],
                        datasets: [{
                            label: 'No completed tasks found',
                            data: [0],
                            borderColor: '#9ca3af',
                            backgroundColor: 'rgba(156, 163, 175, 0.1)',
                            tension: 0.1,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Tasks Completed'
                                }
                            }
                        }
                    }
                });
                return;
            }
            
            // Format dates for display
            const dateLabels = completionDates.map(date => {
                const parts = date.split('/');
                if (parts.length === 3) {
                    return parts[1] + '/' + parts[2]; // MM/DD
                }
                return date.split('-').slice(1).join('/'); // Handle YYYY-MM-DD format
            });
            
            // Create datasets for each trade showing daily completions
            const datasets = trades.map((trade, index) => {
                const tradeData = completionDates.map(date => {
                    return filteredData.filter(row => 
                        row.trade === trade && 
                        row.complete_date === date && 
                        row.state === 'complete'
                    ).length;
                });
                
                const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#06b6d4', '#84cc16'];
                
                return {
                    label: trade,
                    data: tradeData,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '20',
                    tension: 0.1,
                    fill: false
                };
            });
            
            // Add total line
            const totalData = completionDates.map(date => {
                return filteredData.filter(row => 
                    row.complete_date === date && 
                    row.state === 'complete'
                ).length;
            });
            
            datasets.push({
                label: 'Total (All Trades)',
                data: totalData,
                borderColor: '#1f2937',
                backgroundColor: 'rgba(31, 41, 55, 0.1)',
                tension: 0.1,
                fill: true,
                borderWidth: 3
            });
            
            charts.velocity = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dateLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Tasks Completed Per Day'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Completion Date'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    }
                }
            });
        }

        function createDistributionChart() {
            const ctx = document.getElementById('distributionChart').getContext('2d');
            const trades = [...new Set(filteredData.map(row => row.trade))];
            
            // Calculate real completion percentages for each trade
            const tradeData = trades.map(trade => {
                const tradeRows = filteredData.filter(row => row.trade === trade);
                const completed = tradeRows.filter(row => row.state === 'complete').length;
                const total = tradeRows.length;
                return total > 0 ? Math.round((completed / total) * 100) : 0;
            });
            
            charts.distribution = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: trades,
                    datasets: [{
                        data: tradeData,
                        backgroundColor: [
                            '#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#06b6d4', '#84cc16'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const trade = context.label;
                                    const percentage = context.raw;
                                    const tradeRows = filteredData.filter(row => row.trade === trade);
                                    const completed = tradeRows.filter(row => row.state === 'complete').length;
                                    const total = tradeRows.length;
                                    return `${trade}: ${percentage}% (${completed}/${total})`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function createPerformanceChart() {
            const ctx = document.getElementById('performanceChart').getContext('2d');
            const trades = [...new Set(filteredData.map(row => row.trade))];
            
            charts.performance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: trades,
                    datasets: [{
                        label: 'Completion %',
                        data: trades.map(trade => {
                            const tradeData = filteredData.filter(row => row.trade === trade);
                            const completed = tradeData.filter(row => row.state === 'complete').length;
                            return Math.round((completed / tradeData.length) * 100);
                        }),
                        backgroundColor: '#3b82f6'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: '% Complete'
                            }
                        }
                    }
                }
            });
        }

        function updateCharts() {
            // Destroy existing charts and recreate them with filtered data
            if (charts.progress) {
                charts.progress.destroy();
            }
            if (charts.velocity) {
                charts.velocity.destroy();
            }
            if (charts.distribution) {
                charts.distribution.destroy();
            }
            if (charts.performance) {
                charts.performance.destroy();
            }
            
            // Recreate all charts with filtered data
            createCharts();
        }

        // Analyze real data for anomalies
        function analyzeAnomalies(data) {
            // Reset all counts
            anomalyTypes.forEach(anomaly => anomaly.count = 0);
            
            // 1. Trade Abandonment: Tasks in-progress for extended periods without completion
            const abandonmentCount = detectAbandonedTrades(data);
            anomalyTypes.find(a => a.id === 'abandonment').count = abandonmentCount;
            
            // 2. Trade Starvation: Locations with multiple trades stuck
            const starvationCount = detectStarvation(data);
            anomalyTypes.find(a => a.id === 'starvation').count = starvationCount;
            
            // 3. Burst Start: Unusual concentration of trade starts
            const burstCount = detectBurstStart(data);
            anomalyTypes.find(a => a.id === 'burst_start').count = burstCount;
            
            // 4. Swiss Cheese Flow: Random gaps in completion patterns
            const swissCheeseCount = detectSwissCheese(data);
            anomalyTypes.find(a => a.id === 'swiss_cheese').count = swissCheeseCount;
            
            // 5. Trade Blockage: Conflicting trades in same location
            const blockageCount = detectTradeBlockage(data);
            anomalyTypes.find(a => a.id === 'blockage').count = blockageCount;
            
            // 6. Premature Start: Trades starting before prerequisites
            const prematureCount = detectPrematureStart(data);
            anomalyTypes.find(a => a.id === 'premature_start').count = prematureCount;
        }

        // Detection algorithms for each anomaly type
        function detectAbandonedTrades(data) {
            const now = new Date();
            let abandonedCount = 0;
            
            // Find trades that have been in-progress for >14 days
            const inProgressTrades = data.filter(row => row.state === 'in progress' || row.state === 'in-progress');
            
            inProgressTrades.forEach(row => {
                if (row.capture_date) {
                    const captureDate = new Date(row.capture_date);
                    const daysDiff = (now - captureDate) / (1000 * 60 * 60 * 24);
                    
                    // Count tasks stalled for more than 14 days
                    if (daysDiff > 14) {
                        abandonedCount++;
                    }
                }
            });
            
            return abandonedCount;
        }

        function detectStarvation(data) {
            // Find locations where multiple trades compete on individual days
            let starvationCount = 0;
            const captureDates = [...new Set(data.map(row => row.capture_date).filter(Boolean))];
            
            captureDates.forEach(date => {
                const dayData = data.filter(row => row.capture_date === date && (row.state === 'in progress' || row.state === 'in-progress'));
                const locationGroups = {};
                
                dayData.forEach(row => {
                    if (!locationGroups[row.location]) {
                        locationGroups[row.location] = [];
                    }
                    locationGroups[row.location].push(row);
                });
                
                // Count instances where multiple trades compete on the same day
                Object.values(locationGroups).forEach(trades => {
                    if (trades.length >= 2) {
                        starvationCount++;
                    }
                });
            });
            
            return starvationCount;
        }

        function detectBurstStart(data) {
            // Look for unusual clustering of trade starts
            const startDates = {};
            
            data.forEach(row => {
                if (row.capture_date) {
                    const date = row.capture_date;
                    if (!startDates[date]) {
                        startDates[date] = 0;
                    }
                    startDates[date]++;
                }
            });
            
            // Find dates with unusually high activity (>20 starts)
            return Object.values(startDates).filter(count => count > 20).length;
        }

        function detectSwissCheese(data) {
            // Find random gaps in otherwise completed areas
            const completedByLocation = {};
            
            data.forEach(row => {
                if (!completedByLocation[row.location]) {
                    completedByLocation[row.location] = { total: 0, completed: 0 };
                }
                completedByLocation[row.location].total++;
                if (row.state === 'complete') {
                    completedByLocation[row.location].completed++;
                }
            });
            
            // Find locations that are completely empty (0% complete) surrounded by completed areas
            const locations = Object.keys(completedByLocation).sort();
            let gapCount = 0;
            
            for (let i = 1; i < locations.length - 1; i++) {
                const current = completedByLocation[locations[i]];
                const prev = completedByLocation[locations[i-1]];
                const next = completedByLocation[locations[i+1]];
                
                // If current is 0% complete but neighbors are >80% complete
                if (current.completed === 0 && 
                    prev.completed / prev.total > 0.8 && 
                    next.completed / next.total > 0.8) {
                    gapCount++;
                }
            }
            
            return gapCount;
        }

        function detectVerticalLag(data) {
            // Check if upper levels/floors are behind lower levels
            const levelGroups = {};
            
            data.forEach(row => {
                const level = row.level || row.floor || '1';
                if (!levelGroups[level]) {
                    levelGroups[level] = { total: 0, completed: 0 };
                }
                levelGroups[level].total++;
                if (row.state === 'complete') {
                    levelGroups[level].completed++;
                }
            });
            
            // Check if higher numbered levels have lower completion rates
            const levels = Object.keys(levelGroups).sort((a, b) => parseInt(a) - parseInt(b));
            let lagCount = 0;
            
            for (let i = 1; i < levels.length; i++) {
                const currentLevel = levelGroups[levels[i]];
                const prevLevel = levelGroups[levels[i-1]];
                
                const currentRate = currentLevel.completed / currentLevel.total;
                const prevRate = prevLevel.completed / prevLevel.total;
                
                // If current level is significantly behind previous level
                if (prevRate - currentRate > 0.2) {
                    lagCount++;
                }
            }
            
            return lagCount;
        }

        function detectOrphanLocations(data) {
            // Find isolated incomplete locations
            const locationCompletion = {};
            
            data.forEach(row => {
                if (!locationCompletion[row.location]) {
                    locationCompletion[row.location] = { total: 0, completed: 0 };
                }
                locationCompletion[row.location].total++;
                if (row.state === 'complete') {
                    locationCompletion[row.location].completed++;
                }
            });
            
            // Count locations with very low completion rates (<10%)
            return Object.values(locationCompletion).filter(loc => {
                const rate = loc.completed / loc.total;
                return rate < 0.1 && loc.total > 0;
            }).length;
        }

        function detectTradeBlockage(data) {
            // Find locations where conflicting trades are both in-progress
            const locationTrades = {};
            
            data.filter(row => row.state === 'in progress' || row.state === 'in-progress').forEach(row => {
                if (!locationTrades[row.location]) {
                    locationTrades[row.location] = [];
                }
                locationTrades[row.location].push(row.trade);
            });
            
            // Define conflicting trade pairs (from memory)
            const conflicts = [
                ['Overhead Duct Rough In', 'Wall Prime Paint'],
                ['Overhead Plumbing', 'Wall Drywall Finish'],
                ['Overhead Duct Insulation', 'Wall Prime Paint'],
                ['Wall Drywall', 'Overhead Duct Rough In']
            ];
            
            let blockageCount = 0;
            Object.values(locationTrades).forEach(trades => {
                const uniqueTrades = [...new Set(trades)];
                for (const [trade1, trade2] of conflicts) {
                    if (uniqueTrades.includes(trade1) && uniqueTrades.includes(trade2)) {
                        blockageCount++;
                        break; // Count each location only once
                    }
                }
            });
            
            return blockageCount;
        }

        function detectPrematureStart(data) {
            // Find trades that started before their prerequisites were complete
            const tradeSequence = {
                'Overhead Duct Insulation': ['Overhead Duct Rough In'],
                'In Wall Insulation': ['Overhead Duct Rough In', 'Overhead Plumbing'],
                'Wall Drywall': ['In Wall Insulation', 'Overhead Duct Insulation'],
                'Wall Drywall Finish': ['Wall Drywall'],
                'Wall Prime Paint': ['Wall Drywall Finish']
            };
            
            let violationCount = 0;
            
            Object.keys(tradeSequence).forEach(trade => {
                const prerequisites = tradeSequence[trade];
                
                // Find locations where this trade is in-progress or complete
                const tradeLocations = data.filter(row => 
                    row.trade === trade && (row.state === 'in progress' || row.state === 'in-progress' || row.state === 'complete')
                ).map(row => row.location);
                
                // For each location, check if prerequisites are complete
                tradeLocations.forEach(location => {
                    const hasAllPrereqs = prerequisites.every(prereq => {
                        return data.some(row => 
                            row.location === location && 
                            row.trade === prereq && 
                            row.state === 'complete'
                        );
                    });
                    
                    if (!hasAllPrereqs) {
                        violationCount++;
                    }
                });
            });
            
            return violationCount;
        }

        // Render anomaly tiles
        function renderAnomalyTiles() {
            const container = document.getElementById('anomaly-tiles');
            container.innerHTML = '';

            anomalyTypes.forEach(anomaly => {
                const tile = document.createElement('div');
                tile.className = 'anomaly-tile p-4 rounded-lg border border-gray-200 bg-white cursor-pointer hover:shadow-lg transition-shadow';
                tile.onclick = () => showAnomalyChart(anomaly);
                
                tile.innerHTML = `
                    <div class="flex items-center justify-between mb-2">
                        <div class="flex items-center gap-2">
                            <svg class="w-5 h-5" style="color: ${anomaly.color}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
                            </svg>
                            <h4 class="font-semibold text-gray-900 text-sm">${anomaly.name}</h4>
                        </div>
                        <span class="px-2 py-1 text-xs font-medium rounded-full text-white" style="background-color: ${anomaly.color}">
                            ${anomaly.count}
                        </span>
                    </div>
                    <p class="text-xs text-gray-600 mb-2">${anomaly.category}</p>
                    <div class="text-xs px-2 py-1 rounded inline-block ${
                        anomaly.severity === 'high' ? 'bg-red-100 text-red-800' :
                        anomaly.severity === 'medium' ? 'bg-orange-100 text-orange-800' :
                        'bg-yellow-100 text-yellow-800'
                    }">
                        ${anomaly.severity.toUpperCase()} PRIORITY
                    </div>
                `;
                
                container.appendChild(tile);
            });


        }



        // Global variable to track anomaly chart
        let anomalyChart = null;

        // Show anomaly-specific chart
        function showAnomalyChart(anomaly) {
            const container = document.getElementById('anomaly-chart-container');
            const title = document.getElementById('anomaly-chart-title');
            
            title.textContent = `${anomaly.name} Analysis`;
            container.classList.remove('hidden');
            
            // Destroy existing chart if it exists
            if (anomalyChart) {
                anomalyChart.destroy();
            }
            
            // Create appropriate chart based on anomaly type
            createAnomalyVisualization(anomaly);
        }

        // Close anomaly chart
        function closeAnomalyChart() {
            const container = document.getElementById('anomaly-chart-container');
            container.classList.add('hidden');
            
            if (anomalyChart) {
                anomalyChart.destroy();
                anomalyChart = null;
            }
        }

        // Create visualization based on anomaly type
        function createAnomalyVisualization(anomaly) {
            const ctx = document.getElementById('anomalyChart').getContext('2d');
            
            switch(anomaly.id) {
                case 'abandonment':
                    createAbandonmentChart(ctx, anomaly);
                    break;
                case 'starvation':
                    createStarvationChart(ctx, anomaly);
                    break;
                case 'burst_start':
                    createBurstStartChart(ctx, anomaly);
                    break;
                case 'swiss_cheese':
                    createSwissCheeseChart(ctx, anomaly);
                    break;
                case 'blockage':
                    createBlockageChart(ctx, anomaly);
                    break;
                case 'premature_start':
                    createPrematureStartChart(ctx, anomaly);
                    break;
                default:
                    createGenericAnomalyChart(ctx, anomaly);
            }
        }

        // Helper functions to get real data for charts
        function getAbandonedTradesData() {
            const now = new Date();
            
            // Get trades that are in-progress and stalled >14 days
            const abandonedTrades = filteredData.filter(row => {
                if (row.state !== 'in progress' && row.state !== 'in-progress') return false;
                
                // Calculate days stalled from capture date
                if (row.capture_date) {
                    const captureDate = new Date(row.capture_date);
                    const daysDiff = (now - captureDate) / (1000 * 60 * 60 * 24);
                    return daysDiff > 14;
                }
                
                return false;
            });
            
            // Group by location and collect trade details
            const locationData = {};
            abandonedTrades.forEach(row => {
                const location = row.location;
                
                if (!locationData[location]) {
                    locationData[location] = {
                        totalStalled: 0,
                        trades: {}
                    };
                }
                
                // Calculate days stalled
                const captureDate = new Date(row.capture_date);
                const daysStalled = Math.floor((now - captureDate) / (1000 * 60 * 60 * 24));
                
                if (!locationData[location].trades[row.trade]) {
                    locationData[location].trades[row.trade] = {
                        count: 0,
                        maxDays: 0,
                        minDays: Infinity
                    };
                }
                
                locationData[location].totalStalled++;
                locationData[location].trades[row.trade].count++;
                locationData[location].trades[row.trade].maxDays = Math.max(
                    locationData[location].trades[row.trade].maxDays, 
                    daysStalled
                );
                locationData[location].trades[row.trade].minDays = Math.min(
                    locationData[location].trades[row.trade].minDays, 
                    daysStalled
                );
            });
            
            return locationData;
        }

        function getStarvationData() {
            // Analyze starvation by individual capture days
            const starvationByDay = {};
            
            // Group data by capture date and location
            const captureDates = [...new Set(filteredData.map(row => row.capture_date).filter(Boolean))];
            
            captureDates.forEach(date => {
                const dayData = filteredData.filter(row => row.capture_date === date);
                const locationGroups = {};
                
                // Group by location for this specific day
                dayData.filter(row => row.state === 'in progress' || row.state === 'in-progress').forEach(row => {
                    if (!locationGroups[row.location]) {
                        locationGroups[row.location] = [];
                    }
                    locationGroups[row.location].push(row);
                });
                
                // Find locations with multiple competing trades on this day
                Object.entries(locationGroups).forEach(([location, trades]) => {
                    if (trades.length >= 2) {
                        const key = `${location} (${date})`;
                        if (!starvationByDay[key]) {
                            starvationByDay[key] = {
                                count: trades.length,
                                trades: [...new Set(trades.map(t => t.trade))],
                                date: date,
                                location: location
                            };
                        }
                    }
                });
            });
            
            return starvationByDay;
        }

        function getSwissCheeseData() {
            // Find locations with gaps in completion patterns
            const locationCompletion = {};
            
            // Calculate completion rate for each location
            filteredData.forEach(row => {
                if (!locationCompletion[row.location]) {
                    locationCompletion[row.location] = { total: 0, completed: 0 };
                }
                locationCompletion[row.location].total++;
                if (row.state === 'complete') {
                    locationCompletion[row.location].completed++;
                }
            });
            
            // Calculate completion percentages and identify gaps
            const completionData = {};
            Object.entries(locationCompletion).forEach(([location, data]) => {
                const percentage = data.total > 0 ? Math.round((data.completed / data.total) * 100) : 0;
                completionData[location] = {
                    percentage: percentage,
                    isGap: percentage === 0 && data.total > 0, // Has tasks but 0% complete
                    total: data.total,
                    completed: data.completed
                };
            });
            
            return completionData;
        }

        function getVerticalLagData() {
            // Analyze completion rates by level
            const levelGroups = {};
            filteredData.forEach(row => {
                const level = row.level || row.floor || '1';
                if (!levelGroups[level]) {
                    levelGroups[level] = { total: 0, completed: 0 };
                }
                levelGroups[level].total++;
                if (row.state === 'complete') {
                    levelGroups[level].completed++;
                }
            });
            
            // Calculate completion rates
            return Object.entries(levelGroups).reduce((acc, [level, data]) => {
                acc[level] = (data.completed / data.total * 100).toFixed(1);
                return acc;
            }, {});
        }

        // Trade Abandonment - Bar chart showing locations with stalled tasks >14 days
        function createAbandonmentChart(ctx, anomaly) {
            // Get real abandoned trades data
            const locationData = getAbandonedTradesData();
            const locations = Object.keys(locationData);
            const data = locations.map(location => locationData[location].totalStalled);
            
            // If no data, show placeholder
            if (locations.length === 0) {
                locations.push('No stalled locations found');
                data.push(0);
            }
            
            anomalyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: locations,
                    datasets: [{
                        label: 'Stalled Tasks',
                        data: data,
                        backgroundColor: anomaly.color + '80',
                        borderColor: anomaly.color,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Stalled Tasks'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Locations'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Trade Abandonment by Location - Tasks stalled >14 days'
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return `Location: ${context[0].label}`;
                                },
                                label: function(context) {
                                    const location = context.label;
                                    if (!locationData[location]) return 'No data';
                                    
                                    const data = locationData[location];
                                    return `Total Stalled Tasks: ${data.totalStalled}`;
                                },
                                afterLabel: function(context) {
                                    const location = context.label;
                                    if (!locationData[location]) return [];
                                    
                                    const data = locationData[location];
                                    const details = [];
                                    
                                    details.push(''); // Empty line for spacing
                                    details.push('Breakdown by Trade:');
                                    
                                    Object.entries(data.trades).forEach(([trade, tradeInfo]) => {
                                        const daysRange = tradeInfo.minDays === tradeInfo.maxDays 
                                            ? `${tradeInfo.maxDays} days`
                                            : `${tradeInfo.minDays}-${tradeInfo.maxDays} days`;
                                        
                                        details.push(`• ${trade}: ${tradeInfo.count} task${tradeInfo.count > 1 ? 's' : ''} (stalled ${daysRange})`);
                                    });
                                    
                                    return details;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Trade Starvation - Bar chart showing locations with multiple competing trades by day
        function createStarvationChart(ctx, anomaly) {
            const starvationData = getStarvationData();
            const labels = Object.keys(starvationData);
            const data = labels.map(key => starvationData[key].count);
            
            // If no data, show placeholder
            if (labels.length === 0) {
                labels.push('No resource conflicts found');
                data.push(0);
            }
            
            anomalyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Competing Trades',
                        data: data,
                        backgroundColor: anomaly.color + '80',
                        borderColor: anomaly.color,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Competing Trades'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Location (Date)'
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Trade Starvation - Daily analysis of competing trades by location'
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return context[0].label;
                                },
                                label: function(context) {
                                    const key = context.label;
                                    const data = starvationData[key];
                                    if (!data) return 'No data';
                                    return `Competing Trades: ${data.count}`;
                                },
                                afterLabel: function(context) {
                                    const key = context.label;
                                    const data = starvationData[key];
                                    if (!data) return [];
                                    
                                    const details = [];
                                    details.push(''); // Empty line
                                    details.push('Competing Trades:');
                                    data.trades.forEach(trade => {
                                        details.push(`• ${trade}`);
                                    });
                                    details.push(''); // Empty line
                                    details.push('Multiple in-progress trades competing for the same location on this day');
                                    
                                    return details;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Burst Start - Line chart showing sudden activity spikes
        function createBurstStartChart(ctx, anomaly) {
            const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
            const normalActivity = [8, 10, 12, 9, 11, 3, 2];
            const burstActivity = [8, 10, 35, 9, 11, 3, 2]; // Spike on Wednesday
            
            anomalyChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: days,
                    datasets: [{
                        label: 'Normal Activity',
                        data: normalActivity,
                        borderColor: '#6b7280',
                        backgroundColor: '#6b728020',
                        borderWidth: 2
                    }, {
                        label: 'Burst Activity',
                        data: burstActivity,
                        borderColor: anomaly.color,
                        backgroundColor: anomaly.color + '30',
                        borderWidth: 3,
                        pointBackgroundColor: anomaly.color,
                        pointRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Tasks Started'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Burst Start Pattern - Sudden large volume of work starting'
                        }
                    }
                }
            });
        }

        // Swiss Cheese Flow - Bar chart showing gaps in completion patterns
        function createSwissCheeseChart(ctx, anomaly) {
            const swissCheeseData = getSwissCheeseData();
            const locations = Object.keys(swissCheeseData);
            const completionPercentages = locations.map(loc => swissCheeseData[loc].percentage);
            
            // If no data, show placeholder
            if (locations.length === 0) {
                locations.push('No completion gaps found');
                completionPercentages.push(0);
            }
            
            anomalyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: locations,
                    datasets: [{
                        label: 'Completion %',
                        data: completionPercentages,
                        backgroundColor: completionPercentages.map((val, idx) => {
                            if (locations.length === 1 && completionPercentages[0] === 0) return anomaly.color;
                            return swissCheeseData[locations[idx]]?.isGap ? '#ef4444' : anomaly.color + '80';
                        }),
                        borderColor: completionPercentages.map((val, idx) => {
                            if (locations.length === 1 && completionPercentages[0] === 0) return anomaly.color;
                            return swissCheeseData[locations[idx]]?.isGap ? '#dc2626' : anomaly.color;
                        }),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Completion Percentage'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Swiss Cheese Flow - Completion gaps in project locations'
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return `Location: ${context[0].label}`;
                                },
                                label: function(context) {
                                    const location = context.label;
                                    const data = swissCheeseData[location];
                                    if (!data) return `Completion: ${context.parsed.y}%`;
                                    
                                    return `Completion: ${data.percentage}% (${data.completed}/${data.total} tasks)`;
                                },
                                afterLabel: function(context) {
                                    const location = context.label;
                                    const data = swissCheeseData[location];
                                    if (!data) return [];
                                    
                                    if (data.isGap) {
                                        return ['', 'This location has tasks but 0% completion - a potential gap!'];
                                    } else if (data.percentage < 50) {
                                        return ['', 'Low completion rate may indicate workflow issues'];
                                    }
                                    return [];
                                }
                            }
                        }
                    }
                }
            });
        }

        // Vertical Lag - Bar chart showing floor-by-floor delays
        function createVerticalLagChart(ctx, anomaly) {
            const verticalData = getVerticalLagData();
            const levels = Object.keys(verticalData).sort((a, b) => parseInt(a) - parseInt(b));
            const completionRates = levels.map(level => parseFloat(verticalData[level]));
            
            anomalyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: levels.map(level => `Level ${level}`),
                    datasets: [{
                        label: 'Completion %',
                        data: completionRates,
                        backgroundColor: levels.map((_, i) => `hsl(${120 - (i * 20)}, 70%, 50%)`), // Green to red gradient
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Completion Percentage'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Vertical Lag - Upper floors lagging behind lower floors'
                        }
                    }
                }
            });
        }

        // Generic chart for remaining anomaly types
        function createOrphanLocationChart(ctx, anomaly) {
            createGenericAnomalyChart(ctx, anomaly, 'Orphan Location - Isolated incomplete areas');
        }

        function createBlockageChart(ctx, anomaly) {
            createGenericAnomalyChart(ctx, anomaly, 'Trade Blockage - Trades blocking each other');
        }

        function createPrematureStartChart(ctx, anomaly) {
            createGenericAnomalyChart(ctx, anomaly, 'Premature Start - Trades starting before prerequisites');
        }

        // Generic anomaly chart
        function createGenericAnomalyChart(ctx, anomaly, titleOverride = null) {
            const data = Array.from({length: 7}, () => Math.floor(Math.random() * 5) + 1);
            const labels = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
            
            anomalyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Occurrences',
                        data: data,
                        backgroundColor: anomaly.color,
                        borderColor: anomaly.color,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Incidents'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: titleOverride || `${anomaly.name} - Weekly occurrence pattern`
                        }
                    }
                }
            });
        }

        // Render insights based on real data
        function renderInsights() {
            const container = document.getElementById('insights-container');
            container.innerHTML = '';

            // Get insights from real data
            const insights = getInsightsFromData();

            insights.forEach(insight => {
                const insightCard = document.createElement('div');
                insightCard.className = `p-4 rounded-lg border-l-4 ${
                    insight.type === 'achievement' ? 'border-green-500 bg-green-50' :
                    insight.type === 'concern' ? 'border-red-500 bg-red-50' :
                    insight.type === 'opportunity' ? 'border-blue-500 bg-blue-50' :
                    'border-yellow-500 bg-yellow-50'
                }`;
                
                insightCard.innerHTML = `
                    <div class="flex items-start justify-between mb-2">
                        <h4 class="font-semibold text-gray-900">${insight.title}</h4>
                        <span class="px-2 py-1 text-xs font-medium rounded-full ${
                            insight.type === 'achievement' ? 'bg-green-100 text-green-800' :
                            insight.type === 'concern' ? 'bg-red-100 text-red-800' :
                            insight.type === 'opportunity' ? 'bg-blue-100 text-blue-800' :
                            'bg-yellow-100 text-yellow-800'
                        }">
                            ${insight.type}
                        </span>
                    </div>
                    <p class="text-sm text-gray-700 mb-3">${insight.description}</p>
                    <p class="text-xs font-medium text-gray-900">
                        <span class="text-gray-600">Action: </span>
                        ${insight.action}
                    </p>
                `;
                
                container.appendChild(insightCard);
            });
        }

        // Get insights from actual data
        function getInsightsFromData() {
            const insights = [];
            const trades = [...new Set(filteredData.map(row => row.trade))];
            
            // Find best performing trade
            const tradePerformance = trades.map(trade => {
                const tradeData = filteredData.filter(row => row.trade === trade);
                const completed = tradeData.filter(row => row.state === 'complete').length;
                const total = tradeData.length;
                const rate = total > 0 ? (completed / total) * 100 : 0;
                return { trade, rate, completed, total };
            }).sort((a, b) => b.rate - a.rate);

            if (tradePerformance.length > 0) {
                const bestTrade = tradePerformance[0];
                if (bestTrade.rate > 50) {
                    insights.push({
                        type: 'achievement',
                        title: `${bestTrade.trade} Leading Progress`,
                        description: `Highest completion rate at ${bestTrade.rate.toFixed(1)}%, setting strong pace for project`,
                        action: 'Allocate excess capacity to support lagging trades'
                    });
                }

                const worstTrade = tradePerformance[tradePerformance.length - 1];
                if (worstTrade.rate < 30 && worstTrade.total > 0) {
                    insights.push({
                        type: 'concern',
                        title: `${worstTrade.trade} Low Completion`,
                        description: `Only ${worstTrade.rate.toFixed(1)}% complete, significantly lagging other trades`,
                        action: 'Increase crew allocation and investigate bottlenecks'
                    });
                }
            }

            // Check for level completion opportunities
            const levels = [...new Set(filteredData.map(row => row.level))];
            levels.forEach(level => {
                const levelData = filteredData.filter(row => row.level === level);
                const completed = levelData.filter(row => row.state === 'complete').length;
                const total = levelData.length;
                const rate = total > 0 ? (completed / total) * 100 : 0;
                
                if (rate > 75) {
                    insights.push({
                        type: 'opportunity',
                        title: `Level ${level} Nearing Completion`,
                        description: `${rate.toFixed(0)}% complete - opportunity to showcase progress to stakeholders`,
                        action: 'Schedule walkthrough with investors'
                    });
                }
            });

            // Add a risk insight about trade coordination
            if (insights.length < 4) {
                insights.push({
                    type: 'risk',
                    title: 'Trade Sequence Violations Increasing',
                    description: 'Multiple instances of premature starts detected this week',
                    action: 'Reinforce sequencing protocols with superintendents'
                });
            }

            // Add default insights if none were generated from data
            if (insights.length === 0) {
                insights.push(
                    {
                        type: 'achievement',
                        title: 'Data Analysis Ready',
                        description: 'Upload your construction CSV data to see real insights',
                        action: 'Upload CSV file to begin analysis'
                    },
                    {
                        type: 'opportunity',
                        title: 'Dashboard Configured',
                        description: 'System ready for construction project tracking',
                        action: 'Begin by uploading project data'
                    }
                );
            }

            return insights.slice(0, 4); // Return max 4 insights
        }

        // Render timeline based on real data
        function renderTimeline() {
            const container = document.getElementById('timeline-container');
            container.innerHTML = '';

            const milestones = getMilestonesFromData();

            milestones.forEach((milestone, index) => {
                const timelineItem = document.createElement('div');
                timelineItem.className = 'relative flex items-start';
                
                timelineItem.innerHTML = `
                    <!-- Timeline dot -->
                    <div class="relative z-10 w-12 h-12 rounded-full flex items-center justify-center ${
                        milestone.status === 'complete' ? 'bg-blue-600' :
                        milestone.status === 'in-progress' ? 'bg-blue-400' : 'bg-blue-300'
                    }">
                        ${milestone.status === 'complete' ? 
                            '<svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path></svg>' :
                            `<span class="text-white font-bold text-sm">${index + 1}</span>`
                        }
                    </div>
                    
                    <!-- Milestone content -->
                    <div class="ml-6 flex-1">
                        <div class="bg-gray-50 p-4 rounded-lg">
                            <div class="flex items-center justify-between mb-2">
                                <h4 class="font-semibold text-gray-900">${milestone.name}</h4>
                                <span class="px-3 py-1 text-xs font-medium rounded-full ${
                                    milestone.status === 'complete' ? 'bg-blue-100 text-blue-800' :
                                    milestone.status === 'in-progress' ? 'bg-blue-50 text-blue-700' :
                                    'bg-blue-50 text-blue-600'
                                }">
                                    ${milestone.status}
                                </span>
                            </div>
                            <p class="text-sm text-gray-600 mb-3">
                                Status: ${milestone.description}
                            </p>
                            
                            <!-- Progress bar -->
                            <div class="flex items-center gap-3">
                                <div class="flex-1 bg-gray-200 rounded-full h-3">
                                    <div 
                                        class="h-3 rounded-full transition-all duration-500 ${
                                            milestone.status === 'complete' ? 'bg-blue-600' :
                                            milestone.status === 'in-progress' ? 'bg-blue-400' : 'bg-blue-300'
                                        }"
                                        style="width: ${milestone.progress}%"
                                    ></div>
                                </div>
                                <span class="text-sm font-medium text-gray-900 w-12">
                                    ${milestone.progress}%
                                </span>
                            </div>
                        </div>
                    </div>
                `;
                
                container.appendChild(timelineItem);
            });
        }

        // Get milestones from actual data
        function getMilestonesFromData() {
            const trades = [...new Set(filteredData.map(row => row.trade))];
            const milestones = [];

            // Create milestones based on trade completion rates
            trades.forEach(trade => {
                const tradeData = filteredData.filter(row => row.trade === trade);
                const completed = tradeData.filter(row => row.state === 'complete').length;
                const total = tradeData.length;
                const progress = total > 0 ? Math.round((completed / total) * 100) : 0;
                
                let status = 'in-progress';
                if (progress === 100) status = 'complete';
                
                milestones.push({
                    name: trade,
                    description: `${completed}/${total} tasks completed`,
                    status: status,
                    progress: progress
                });
            });

            // Only show milestones generated from real data

            // Sort by progress descending and take top 5
            return milestones.sort((a, b) => b.progress - a.progress).slice(0, 5);
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize with upload screen
            initUpload();
        });
    </script>
</body>
</html>
