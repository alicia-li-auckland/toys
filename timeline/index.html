<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Progress AI Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Custom scrollbar for better aesthetics */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f5f9;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        /* Layout for frozen panes */
        .timeline-grid-wrapper {
            display: grid;
            grid-template-columns: 300px 1fr;
            overflow: auto;
            height: calc(100vh - 225px); /* Adjust based on header/legend/filter height */
        }

        .sticky-header {
            position: sticky;
            top: 0;
            z-index: 20;
        }

        .sticky-col {
            position: sticky;
            left: 0;
            z-index: 10;
        }

        /* Style for behind-schedule tasks */
        .behind-schedule-bar {
            background-color: #ef4444; /* red-500 */
        }

        #hover-card {
            transition: opacity 0.2s;
        }

        .truncate-ellipsis {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800">
    <div class="flex h-screen">
        <!-- Home Sidebar -->
        <aside class="bg-white w-16 flex flex-col items-center py-4 border-r border-slate-200 flex-shrink-0">
            <a href="../" class="p-2 rounded-lg bg-slate-100 hover:bg-slate-200 transition-colors" title="Go Home">
                <i data-lucide="home" class="text-slate-600"></i>
            </a>
        </aside>

        <!-- Main Content -->
        <div class="flex-1 flex flex-col overflow-hidden">
            <!-- Top Header (Frozen) -->
            <header class="bg-white border-b border-slate-200 flex-shrink-0">
                <div class="flex items-center justify-between p-4">
                    <div>
                        <h1 class="text-lg font-semibold">Progress AI</h1>
                        <p class="text-xs text-slate-500">Home / Project / Fly Upload</p>
                    </div>
                    <div class="flex items-center gap-4">
                        <button class="flex items-center gap-2 px-4 py-2 text-sm font-medium text-white bg-blue-600 rounded-lg hover:bg-blue-700">
                            <i data-lucide="share-2" class="w-4 h-4"></i>
                            <span>Share</span>
                        </button>
                        <i data-lucide="bell" class="text-slate-500"></i>
                        <i data-lucide="help-circle" class="text-slate-500"></i>
                        <img src="https://placehold.co/32x32/64748b/ffffff?text=U" class="rounded-full" alt="User Avatar">
                    </div>
                </div>
            </header>

            <!-- Main dashboard area -->
            <main class="flex-1 overflow-hidden">
                <div class="p-4 lg:p-6 h-full">
                    <div class="bg-white rounded-xl shadow-sm h-full flex flex-col">
                        <!-- Legend -->
                        <div class="p-3 border-b border-slate-200 flex items-center gap-6 text-sm">
                            <div class="flex items-center gap-2">
                                <div class="w-10 h-4 rounded border-2 border-blue-500"></div>
                                <span class="text-slate-600 font-medium">Planned Schedule</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <div class="w-10 h-4 rounded bg-blue-500"></div>
                                <span class="text-slate-600 font-medium">In Progress (50%)</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <div class="w-10 h-4 rounded bg-green-500"></div>
                                <span class="text-slate-600 font-medium">Completed</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <div class="w-10 h-4 rounded border-2 border-red-500 bg-red-500"></div>
                                <span class="text-slate-600 font-medium">Delayed</span>
                            </div>
                        </div>

                        <!-- Search and Filter Controls -->
                        <div class="p-3 border-b border-slate-200 flex items-center justify-between gap-4">
                            <div class="relative flex-grow max-w-xs">
                                <i data-lucide="search" class="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-slate-400"></i>
                                <input type="text" id="search-input" placeholder="Search hierarchy..." class="w-full pl-9 pr-4 py-1.5 text-sm border border-slate-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:outline-none">
                            </div>
                            <div class="relative">
                                <button id="filter-btn" class="flex items-center gap-2 px-3 py-1.5 text-sm font-medium text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50">
                                    <i data-lucide="filter" class="w-4 h-4"></i>
                                    <span>Filter Zones</span>
                                </button>
                                <div id="filter-panel" class="hidden absolute top-full right-0 mt-2 w-72 bg-white border border-slate-200 rounded-lg shadow-lg z-40">
                                    <div class="p-3 border-b flex justify-between items-center">
                                        <h4 class="font-semibold text-sm">Filter by Zone</h4>
                                        <button id="clear-filter-btn" class="text-xs text-blue-600 hover:underline">Clear all</button>
                                    </div>
                                    <div id="filter-options" class="p-3 max-h-60 overflow-y-auto custom-scrollbar space-y-2">
                                        <!-- Checkboxes will be generated here -->
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- CSV Upload UI -->
                        <div class="p-3 border-b border-slate-200 flex items-center gap-4">
                            <input type="file" id="csv-upload" accept=".csv" class="block text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-medium file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 transition-colors">
                            <button id="process-csv-btn" class="px-4 py-2 rounded-lg bg-blue-600 text-white font-semibold text-sm disabled:bg-slate-300 disabled:cursor-not-allowed" disabled>Process</button>
                            <span class="text-xs text-slate-500">CSV format: Location,Trade,Status,Start Date,Finish Date,Duration (from Word to CSV converter)</span>
                        </div>

                        <!-- Schedule Upload UI -->
                        <div class="p-3 border-b border-slate-200 flex items-center gap-4">
                            <div class="flex items-center gap-2">
                                <i data-lucide="calendar" class="w-4 h-4 text-green-600"></i>
                                <span class="text-sm font-medium text-slate-700">Schedule:</span>
                            </div>
                            <input type="file" id="schedule-upload" accept=".csv,.xml,.xer,.mpp,.pp" class="block text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-medium file:bg-green-50 file:text-green-700 hover:file:bg-green-100 transition-colors">
                            <button id="process-schedule-btn" class="px-4 py-2 rounded-lg bg-green-600 text-white font-semibold text-sm disabled:bg-slate-300 disabled:cursor-not-allowed" disabled>Load Schedule</button>
                            <span class="text-xs text-slate-500">Upload schedule from Schedule Converter</span>
                        </div>

                        <!-- Actualized Work Upload UI -->
                        <div class="p-3 border-b border-slate-200 flex items-center gap-4">
                            <div class="flex items-center gap-2">
                                <i data-lucide="check-circle" class="w-4 h-4 text-orange-600"></i>
                                <span class="text-sm font-medium text-slate-700">Actualized Work:</span>
                            </div>
                            <input type="file" id="actualized-upload" accept=".csv" class="block text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-medium file:bg-orange-50 file:text-orange-700 hover:file:bg-orange-100 transition-colors">
                            <button id="process-actualized-btn" class="px-4 py-2 rounded-lg bg-orange-600 text-white font-semibold text-sm disabled:bg-slate-300 disabled:cursor-not-allowed" disabled>Update Progress</button>
                            <span class="text-xs text-slate-500">CSV format: Location,Trade,Status (matches with schedule using Location+Trade)</span>
                            <div id="data-status" class="flex items-center gap-2 text-xs">
                                <span id="schedule-status" class="px-2 py-1 rounded bg-slate-100 text-slate-600">No Schedule</span>
                                <span id="actualized-status" class="px-2 py-1 rounded bg-slate-100 text-slate-600">No Actualized Data</span>
                            </div>
                        </div>

                        <!-- Trades-Locations Mapping Upload UI -->
                        <div class="p-3 border-b border-slate-200 flex items-center gap-4">
                            <div class="flex items-center gap-2">
                                <i data-lucide="map" class="w-4 h-4 text-purple-600"></i>
                                <span class="text-sm font-medium text-slate-700">Trades-Locations Mapping:</span>
                            </div>
                            <input type="file" id="trades-locations-upload" accept=".csv" class="block text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-medium file:bg-purple-50 file:text-purple-700 hover:file:bg-purple-100 transition-colors">
                            <button id="process-trades-locations-btn" class="px-4 py-2 rounded-lg bg-purple-600 text-white font-semibold text-sm disabled:bg-slate-300 disabled:cursor-not-allowed" disabled>Load Mapping</button>
                            <span class="text-xs text-slate-500">CSV format: Location,Trade (validates location-trade combinations)</span>
                            <span id="trades-locations-status" class="px-2 py-1 rounded bg-slate-100 text-slate-600 text-xs">No Mapping</span>
                        </div>

                        <!-- Timeline Grid -->
                        <div class="timeline-grid-wrapper custom-scrollbar">
                            <!-- Corner block -->
                            <div class="p-3 border-r border-b border-slate-200 bg-slate-100 sticky top-0 left-0 z-30">
                                <h3 class="font-semibold text-slate-600 text-sm">Hierarchy</h3>
                            </div>

                            <!-- X-Axis Header -->
                            <div id="timeline-header-wrapper" class="border-b border-slate-200 bg-slate-100/80 backdrop-blur-sm sticky top-0 z-20">
                                <!-- JS generates date headers here -->
                            </div>

                            <!-- Y-Axis Body (Hierarchy Labels) -->
                            <div id="hierarchy-body" class="border-r border-slate-200 bg-white sticky left-0 z-10">
                                <!-- JS generates hierarchy here -->
                            </div>

                            <!-- X-Axis Body (Timeline Bars) -->
                            <div id="timeline-body-wrapper" class="overflow-visible">
                                <div id="timeline-body" class="relative">
                                    <!-- JS generates timeline bars and grid lines here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- Hover Card -->
    <div id="hover-card" class="hidden absolute z-50 p-3 bg-white rounded-lg shadow-xl w-64 border border-slate-200 pointer-events-none opacity-0">
        <img id="hover-card-img" src="" class="w-full h-32 object-cover rounded-md mb-2 bg-slate-200" alt="Task Image">
        <h4 id="hover-card-title" class="font-bold text-slate-800"></h4>
        <p id="hover-card-group" class="text-sm text-slate-500 mb-2"></p>
        <div class="text-xs space-y-1 text-slate-600">
            <p><strong>Status:</strong> <span id="hover-card-status"></span></p>
            <p><strong>Planned:</strong> <span id="hover-card-planned"></span></p>
            <p><strong>Actual:</strong> <span id="hover-card-actual"></span></p>
        </div>
    </div>

    <script>
    // Initialize Lucide Icons
    lucide.createIcons();

    // --- Configuration ---
    const dayWidth = 4; // Condensed width per day for monthly view
    let today = new Date('2025-07-03T00:00:00Z'); // Default date
    let projectData; // Global project data
    let scheduleData; // Global schedule data from schedule converter
    let actualizedWorkData; // Global actualized work data
    let tradesLocationsMap; // Global trades per location mapping
    let overallStartDate, overallEndDate, totalDays;
    let hideCardTimeout;

    // --- Date & Scheduling ---
    const addDays = (date, days) => new Date(date.valueOf() + days * 864e5);
    const getDaysBetween = (start, end) => Math.round((end - start) / 864e5);
    function parseDateSafe(dateStr) {
        if (!dateStr) return null;
        const d = new Date(dateStr);
        return isNaN(d.getTime()) ? null : d;
    }

    // --- Data Handling ---
    function processData(data) {
        projectData = data;
        const allDates = [];
        function collectDatesAndStatus(items) {
            if (!items) return;
            items.forEach(item => {
                item.visible = true;
                const s = parseDateSafe(item.startDate);
                const e = parseDateSafe(item.endDate);
                const as = parseDateSafe(item.actualStartDate);
                const ae = parseDateSafe(item.actualEndDate);
                if (s) allDates.push(s);
                if (e) allDates.push(e);
                if (as) allDates.push(as);
                if (ae) allDates.push(ae);
                if (s && !item.status) {
                    if (ae) item.status = 'Complete';
                    else if (as) item.status = 'In Progress';
                    else if (s < today) item.status = 'Behind Schedule';
                    else item.status = 'Not Started';
                }
                if (item.children) collectDatesAndStatus(item.children);
            });
        }
        collectDatesAndStatus([projectData]);
        overallStartDate = allDates.length > 0 ? new Date(Math.min(...allDates)) : new Date();
        overallEndDate = allDates.length > 0 ? new Date(Math.max(...allDates)) : new Date();
        totalDays = getDaysBetween(overallStartDate, addDays(overallEndDate, 30));
    }

    function buildTreeFromCsv(rows) {
        const root = { id: 'root', name: 'Project', level: 0, children: [] };
        const locationMap = {};
        
        // Location matching function - attempts to match Word to CSV locations with timeline locations
        function matchLocation(wordLocation) {
            if (!wordLocation) return 'Unknown';
            
            const wordLoc = wordLocation.toLowerCase();
            
            // Direct matches
            const directMatches = {
                'dch': 'DCH',
                'eyd': 'EYD', 
                'myd': 'MYD',
                'conveyance': 'Conveyance',
                'dwtr': 'DWTR',
                'fire pump house': 'Fire Pump House',
                'gps': 'GPS',
                'sss': 'SSS',
                'gen yard': 'GEN YARD',
                'uss yard': 'USS YARD',
                'mcp': 'MCP',
                'loading dock': 'Loading Dock'
            };
            
            // Check for direct matches
            for (const [key, value] of Object.entries(directMatches)) {
                if (wordLoc.includes(key)) {
                    return value;
                }
            }
            
            // Check for partial matches (e.g., DCH1-3 -> DCH)
            const partialMatches = {
                'dch': 'DCH',
                'eyd': 'EYD',
                'myd': 'MYD'
            };
            
            for (const [key, value] of Object.entries(partialMatches)) {
                if (wordLoc.includes(key)) {
                    return value;
                }
            }
            
            // Check for number patterns (e.g., DCH1, DCH2, etc.)
            const numberPatterns = [
                { pattern: /dch\d+/i, match: 'DCH' },
                { pattern: /eyd\d+/i, match: 'EYD' },
                { pattern: /myd\d+/i, match: 'MYD' }
            ];
            
            for (const { pattern, match } of numberPatterns) {
                if (pattern.test(wordLoc)) {
                    return match;
                }
            }
            
            return wordLocation; // Return original if no match found
        }
        
        rows.forEach(row => {
            const originalLocation = row['location'] || 'Unknown';
            const matchedLocation = matchLocation(originalLocation);
            
            if (!locationMap[matchedLocation]) {
                locationMap[matchedLocation] = {
                    id: matchedLocation.replace(/\s+/g, '-').toLowerCase(),
                    name: matchedLocation,
                    level: 1,
                    children: [],
                };
                root.children.push(locationMap[matchedLocation]);
            }
            
            // Create activity name from trade and status
            const trade = row['trade'] || 'Unknown Trade';
            const status = row['status'] || 'Unknown Status';
            const activityName = `${trade} - ${status}`;
            
            locationMap[matchedLocation].children.push({
                id: `${matchedLocation}-${trade}-${status}`.replace(/\s+/g, '-').toLowerCase(),
                name: activityName,
                level: 3, // <-- set to 3 so bars are rendered
                location: matchedLocation,
                originalLocation: originalLocation,
                trade: trade,
                status: status,
                activityName: activityName,
                startDate: row['start date'],
                endDate: row['finish date'],
                duration: row['duration']
            });
        });
        return root;
    }

    // --- Schedule and Actualized Work Processing ---
    
    /**
     * Processes schedule data from schedule converter
     * @param {Array} rows - CSV rows from schedule converter
     */
    function processScheduleData(rows) {
        scheduleData = rows;
        console.log('Schedule data loaded:', scheduleData.length, 'activities');
        
        // Create a lookup map for quick matching
        scheduleData.lookupMap = new Map();
        scheduleData.forEach(row => {
            const location = (row['location'] || '').toLowerCase().trim();
            const trade = (row['trade'] || '').toLowerCase().trim();
            const key = `${location}|${trade}`;
            scheduleData.lookupMap.set(key, row);
        });
        
        // Convert schedule data to project data structure for timeline
        const treeData = buildTreeFromScheduleData(rows);
        processData(treeData);
        
        // Update status indicator
        scheduleStatus.textContent = `Schedule (${scheduleData.length} activities)`;
        scheduleStatus.className = 'px-2 py-1 rounded bg-green-100 text-green-600 text-xs';
        
        showToast('Schedule loaded successfully', 'success');
    }
    
    /**
     * Builds timeline tree structure from schedule data
     * @param {Array} rows - Schedule data rows
     * @returns {Object} Tree structure for timeline
     */
    function buildTreeFromScheduleData(rows) {
        const root = { id: 'root', name: 'Project', level: 0, children: [] };
        const locationMap = {};
        
        // Location matching function - attempts to match schedule locations with timeline locations
        function matchLocation(scheduleLocation) {
            if (!scheduleLocation) return 'Unknown';
            
            const scheduleLoc = scheduleLocation.toLowerCase();
            
            // Direct matches
            const directMatches = {
                'dch': 'DCH',
                'eyd': 'EYD', 
                'myd': 'MYD',
                'conveyance': 'Conveyance',
                'dwtr': 'DWTR',
                'fire pump house': 'Fire Pump House',
                'gps': 'GPS',
                'sss': 'SSS',
                'gen yard': 'GEN YARD',
                'uss yard': 'USS YARD',
                'mcp': 'MCP',
                'loading dock': 'Loading Dock',
                'booster pump system': 'Booster Pump System'
            };
            
            // Check for direct matches
            for (const [key, value] of Object.entries(directMatches)) {
                if (scheduleLoc.includes(key)) {
                    return value;
                }
            }
            
            // Check for partial matches (e.g., DCH1-3 -> DCH)
            const partialMatches = {
                'dch': 'DCH',
                'eyd': 'EYD',
                'myd': 'MYD'
            };
            
            for (const [key, value] of Object.entries(partialMatches)) {
                if (scheduleLoc.includes(key)) {
                    return value;
                }
            }
            
            // Check for number patterns (e.g., DCH1, DCH2, etc.)
            const numberPatterns = [
                { pattern: /dch\d+/i, match: 'DCH' },
                { pattern: /eyd\d+/i, match: 'EYD' },
                { pattern: /myd\d+/i, match: 'MYD' }
            ];
            
            for (const { pattern, match } of numberPatterns) {
                if (pattern.test(scheduleLoc)) {
                    return match;
                }
            }
            
            return scheduleLocation; // Return original if no match found
        }
        
        rows.forEach(row => {
            const originalLocation = row['location'] || 'Unknown';
            const matchedLocation = matchLocation(originalLocation);
            const trade = row['trade'] || 'Unknown Trade';
            const startDate = row['start date'] || row['start'] || '';
            const endDate = row['finish date'] || row['end date'] || row['finish'] || row['end'] || '';
            const duration = row['duration'] || '';
            
            if (!locationMap[matchedLocation]) {
                locationMap[matchedLocation] = {
                    id: matchedLocation.replace(/\s+/g, '-').toLowerCase(),
                    name: matchedLocation,
                    level: 1,
                    children: [],
                };
                root.children.push(locationMap[matchedLocation]);
            }
            
            // Create activity name from trade
            const activityName = trade;
            
            // Validate location-trade combination if mapping is available
            let validationStatus = 'unknown';
            if (tradesLocationsMap) {
                const isValid = isValidLocationTradeCombination(matchedLocation, trade);
                validationStatus = isValid ? 'valid' : 'invalid';
            }
            
            locationMap[matchedLocation].children.push({
                id: `${matchedLocation}-${trade}`.replace(/\s+/g, '-').toLowerCase(),
                name: activityName,
                level: 3, // Set to 3 so bars are rendered
                location: matchedLocation,
                originalLocation: originalLocation,
                trade: trade,
                startDate: startDate,
                endDate: endDate,
                duration: duration,
                validationStatus: validationStatus,
                // Default status - will be updated by actualized work
                status: 'Not Started'
            });
        });
        
        return root;
    }
    
    /**
     * Processes actualized work data and matches with schedule
     * @param {Array} rows - CSV rows with Location, Trade, Status
     */
    function processActualizedWork(rows) {
        actualizedWorkData = rows;
        console.log('Actualized work data loaded:', actualizedWorkData.length, 'activities');
        
        if (!projectData || !Array.isArray(projectData.children)) {
            showToast('Please load schedule data first', 'error');
            return;
        }
        
        // Match actualized work with schedule items
        let matchedCount = 0;
        let unmatchedCount = 0;
        let invalidCombinations = 0;
        let suggestions = [];
        
        actualizedWorkData.forEach(actualizedRow => {
            const location = (actualizedRow['location'] || '').toLowerCase().trim();
            const trade = (actualizedRow['trade'] || '').toLowerCase().trim();
            const status = (actualizedRow['status'] || '').toLowerCase().trim();
            const key = `${location}|${trade}`;
            
            // Validate location-trade combination if mapping is loaded
            if (tradesLocationsMap && !isValidLocationTradeCombination(location, trade)) {
                invalidCombinations++;
                const suggestionsForThis = suggestSimilarTrades(location, trade);
                if (suggestionsForThis.length > 0) {
                    suggestions.push({
                        location: actualizedRow['location'],
                        trade: actualizedRow['trade'],
                        suggestions: suggestionsForThis
                    });
                }
            }
            
            // Find matching schedule item in project data
            let foundItem = null;
            function findInProjectData(items) {
                if (!Array.isArray(items)) return;
                items.forEach(item => {
                    if (item.level === 3 && item.location && item.trade) {
                        const itemLocation = item.location.toLowerCase().trim();
                        const itemTrade = item.trade.toLowerCase().trim();
                        if (itemLocation === location && itemTrade === trade) {
                            foundItem = item;
                        }
                    }
                    if (item.children) findInProjectData(item.children);
                });
            }
            findInProjectData(projectData.children);
            
            if (foundItem) {
                // Update project item with actualized status
                foundItem.actualizedStatus = actualizedRow['status'];
                foundItem.actualizedLocation = actualizedRow['location'];
                foundItem.actualizedTrade = actualizedRow['trade'];
                matchedCount++;
                
                // Parse completion date if provided in status
                const completionDateMatch = status.match(/completed on (\d{4}-\d{2}-\d{2})/i);
                if (completionDateMatch) {
                    foundItem.actualCompletionDate = completionDateMatch[1];
                }
            } else {
                unmatchedCount++;
                console.log('No schedule match found for:', location, trade);
            }
        });
        
        // Update status indicator
        let statusText = `Actualized (${matchedCount} matched, ${unmatchedCount} unmatched)`;
        if (invalidCombinations > 0) {
            statusText += `, ${invalidCombinations} invalid`;
        }
        actualizedStatus.textContent = statusText;
        actualizedStatus.className = 'px-2 py-1 rounded bg-orange-100 text-orange-600 text-xs';
        
        // Show detailed feedback
        let message = `Matched ${matchedCount} activities, ${unmatchedCount} unmatched`;
        if (invalidCombinations > 0) {
            message += `, ${invalidCombinations} invalid combinations`;
        }
        showToast(message, 'info');
        
        // Show suggestions if any
        if (suggestions.length > 0) {
            console.log('Suggestions for invalid combinations:', suggestions);
            setTimeout(() => {
                showToast(`${suggestions.length} suggestions available for invalid combinations`, 'info');
            }, 1000);
        }
        
        // Re-render the timeline to show updated bars
        render();
    }
    
    /**
     * Shows a toast notification
     */
    function showToast(message, type = 'info') {
        const toast = document.getElementById('toast');
        const typeClasses = {
            success: 'bg-green-500 text-white',
            error: 'bg-red-500 text-white',
            info: 'bg-blue-500 text-white'
        };
        
        toast.className = `fixed bottom-4 right-4 z-50 px-4 py-2 rounded-lg shadow-lg ${typeClasses[type] || typeClasses.info}`;
        toast.textContent = message;
        toast.classList.remove('translate-y-full');
        
        setTimeout(() => {
            toast.classList.add('translate-y-full');
        }, 3000);
    }
    
    /**
     * Loads and processes trades-locations mapping
     * @param {Array} rows - CSV rows with Location, Trade
     */
    function loadTradesLocationsMapping(rows) {
        tradesLocationsMap = new Map();
        
        if (rows.length === 0) return;
        
        // Check if this is a matrix format (first row has trade names as headers)
        const firstRow = rows[0];
        const isMatrixFormat = Object.keys(firstRow).length > 2 && 
                              Object.keys(firstRow).some(key => key.toLowerCase() !== 'location' && key.trim() !== '');
        
        if (isMatrixFormat) {
            // Matrix format: Location is first column, trades are other columns with Y values
            const tradeColumns = Object.keys(firstRow).filter(key => key.toLowerCase() !== 'location' && key.trim() !== '');
            
            rows.forEach(row => {
                const location = (row['location'] || '').toLowerCase().trim();
                if (!location) return;
                
                const validTrades = new Set();
                tradeColumns.forEach(trade => {
                    const value = (row[trade] || '').toString().toLowerCase().trim();
                    if (value === 'y' || value === 'yes' || value === 'true' || value === '1') {
                        validTrades.add(trade.toLowerCase().trim());
                    }
                });
                
                if (validTrades.size > 0) {
                    tradesLocationsMap.set(location, validTrades);
                }
            });
            
            console.log('Matrix format detected. Loaded trades-locations mapping:', tradesLocationsMap.size, 'locations');
        } else {
            // Standard format: Location, Trade columns
            rows.forEach(row => {
                const location = (row['location'] || '').toLowerCase().trim();
                const trade = (row['trade'] || '').toLowerCase().trim();
                
                if (location && trade) {
                    if (!tradesLocationsMap.has(location)) {
                        tradesLocationsMap.set(location, new Set());
                    }
                    tradesLocationsMap.get(location).add(trade);
                }
            });
            
            console.log('Standard format detected. Loaded trades-locations mapping:', tradesLocationsMap.size, 'locations');
        }
        
        // Log some examples for debugging
        console.log('Sample mappings:');
        let count = 0;
        for (const [location, trades] of tradesLocationsMap.entries()) {
            if (count < 3) {
                console.log(`${location}: ${Array.from(trades).slice(0, 5).join(', ')}${trades.size > 5 ? '...' : ''}`);
                count++;
            }
        }
        
        showToast(`Trades-locations mapping loaded: ${tradesLocationsMap.size} locations`, 'success');
    }
    
    /**
     * Validates if a location-trade combination is valid
     * @param {string} location - Location name
     * @param {string} trade - Trade name
     * @returns {boolean} True if valid combination
     */
    function isValidLocationTradeCombination(location, trade) {
        if (!tradesLocationsMap) return true; // If no mapping loaded, accept all
        
        const locationKey = location.toLowerCase().trim();
        const tradeKey = trade.toLowerCase().trim();
        
        const tradesForLocation = tradesLocationsMap.get(locationKey);
        if (!tradesForLocation) return false;
        
        return tradesForLocation.has(tradeKey);
    }
    
    /**
     * Gets all valid trades for a location
     * @param {string} location - Location name
     * @returns {Array} Array of valid trades
     */
    function getValidTradesForLocation(location) {
        if (!tradesLocationsMap) return [];
        
        const locationKey = location.toLowerCase().trim();
        const tradesForLocation = tradesLocationsMap.get(locationKey);
        
        return tradesForLocation ? Array.from(tradesForLocation) : [];
    }
    
    /**
     * Suggests similar trades for a location if exact match not found
     * @param {string} location - Location name
     * @param {string} trade - Trade name
     * @returns {Array} Array of suggested trades
     */
    function suggestSimilarTrades(location, trade) {
        if (!tradesLocationsMap) return [];
        
        const locationKey = location.toLowerCase().trim();
        const tradeKey = trade.toLowerCase().trim();
        const tradesForLocation = tradesLocationsMap.get(locationKey);
        
        if (!tradesForLocation) return [];
        
        const suggestions = [];
        tradesForLocation.forEach(validTrade => {
            if (validTrade.includes(tradeKey) || tradeKey.includes(validTrade)) {
                suggestions.push(validTrade);
            }
        });
        
        return suggestions;
    }

        // --- DOM Elements ---
        const hierarchyBody = document.getElementById('hierarchy-body');
        const timelineHeaderWrapper = document.getElementById('timeline-header-wrapper');
        const timelineBodyWrapper = document.getElementById('timeline-body-wrapper');
        const timelineBody = document.getElementById('timeline-body');
        const searchInput = document.getElementById('search-input');
        const filterBtn = document.getElementById('filter-btn');
        const filterPanel = document.getElementById('filter-panel');
        const filterOptions = document.getElementById('filter-options');
        const clearFilterBtn = document.getElementById('clear-filter-btn');
        const hoverCard = document.getElementById('hover-card');
        const csvUpload = document.getElementById('csv-upload');
        const processCsvBtn = document.getElementById('process-csv-btn');
        const scheduleUpload = document.getElementById('schedule-upload');
        const processScheduleBtn = document.getElementById('process-schedule-btn');
        const actualizedUpload = document.getElementById('actualized-upload');
        const processActualizedBtn = document.getElementById('process-actualized-btn');
        const scheduleStatus = document.getElementById('schedule-status');
        const actualizedStatus = document.getElementById('actualized-status');
        const tradesLocationsUpload = document.getElementById('trades-locations-upload');
        const processTradesLocationsBtn = document.getElementById('process-trades-locations-btn');
        const tradesLocationsStatus = document.getElementById('trades-locations-status');

        // Add Export CSV button to the header
        const header = document.querySelector('header .flex.items-center.gap-4');
        if (header) {
            const exportBtn = document.createElement('button');
            exportBtn.id = 'export-csv-btn';
            exportBtn.className = 'flex items-center gap-2 px-4 py-2 text-sm font-medium text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50';
            exportBtn.innerHTML = '<i data-lucide="download" class="w-4 h-4"></i> Export CSV';
            exportBtn.disabled = !projectData || !Array.isArray(projectData.children) || projectData.children.length === 0;
            exportBtn.addEventListener('click', () => {
                if (!projectData || !Array.isArray(projectData.children)) return;
                // Flatten all activities (level 3) from the tree
                const activities = [];
                function collectActivities(items) {
                    if (!Array.isArray(items)) return;
                    items.forEach(item => {
                        if (item.level === 3) activities.push(item);
                        if (item.children) collectActivities(item.children);
                    });
                }
                collectActivities(projectData.children);
                exportCsv(activities);
            });
            header.appendChild(exportBtn);
            lucide.createIcons();
        }

        // --- Rendering ---
        function render() {
            console.log('projectData:', projectData);
            if (!projectData || !Array.isArray(projectData.children)) {
                console.error('No valid projectData.children to render:', projectData);
                return;
            }
            hierarchyBody.innerHTML = '';
            timelineBody.innerHTML = '';
            let rowIndex = 0;
            let timelineBarsHtml = '';
            function renderRecursive(items, parentId = 'root', parentIsVisible = true) {
                if (!Array.isArray(items)) return;
                items.forEach(item => {
                    const hasChildren = item.children && item.children.length > 0;
                    const isExpanded = item.isExpanded === undefined ? true : item.isExpanded;
                    const isVisible = parentIsVisible && item.visible;
                    if (item.level === 1 || item.level === 2) {
                        const row = document.createElement('div');
                        row.id = `row-${item.id}`;
                        row.dataset.id = item.id;
                        row.dataset.parentId = parentId;
                        row.className = `flex items-center h-10 border-b border-slate-200 text-sm font-bold text-slate-700 bg-slate-50 hover:bg-slate-100 ${!isVisible ? 'hidden' : ''}`;
                        let expanderIcon = hasChildren ? `<i data-lucide="chevron-right" class="w-4 h-4 mr-1 transition-transform ${isExpanded ? 'rotate-90' : ''}"></i>` : '<span class="w-5 mr-1"></span>';
                        row.innerHTML = `
                            <div style="width: 300px; padding-left: ${item.level === 1 ? '1.25rem' : '2.5rem'};" class="flex items-center flex-shrink-0 cursor-pointer truncate-ellipsis">${expanderIcon}<span>${item.name}</span></div>
                            <div style="flex:1;" class="flex-shrink-0"></div>
                        `;
                        hierarchyBody.appendChild(row);
                        if(isVisible) rowIndex++;
                        if (hasChildren && isExpanded) renderRecursive(item.children, item.id, isVisible && isExpanded);
                    } else if (item.level === 3) {
                        const row = document.createElement('div');
                        row.id = `row-${item.id}`;
                        row.dataset.id = item.id;
                        row.dataset.parentId = parentId;
                        row.className = `flex items-center h-10 border-b border-slate-200 text-sm text-slate-700 hover:bg-slate-50 ${!isVisible ? 'hidden' : ''}`;
                        row.innerHTML = `
                            <div style="width: 300px; padding-left: 4rem;" class="flex-shrink-0 truncate-ellipsis" title="${item.activityName || item.name}"><span>${item.activityName || item.name}</span></div>
                            <div style="flex:1;" class="flex-shrink-0"></div>
                        `;
                        hierarchyBody.appendChild(row);
                        if(isVisible) rowIndex++;
                        // Timeline bar with status-based rendering
                        const plannedStart = parseDateSafe(item.startDate);
                        const plannedEnd = parseDateSafe(item.endDate);
                        if (plannedStart && plannedEnd && isVisible) {
                            const plannedOffsetDays = getDaysBetween(overallStartDate, plannedStart);
                            const plannedDurationDays = Math.max(1, getDaysBetween(plannedStart, plannedEnd));
                            const plannedLeft = plannedOffsetDays * dayWidth;
                            const plannedWidth = plannedDurationDays * dayWidth;
                            
                            // Status-based rendering logic - prioritize actualized status over original status
                            let fillWidth = 0;
                            let fillColor = 'bg-transparent';
                            let isDelayed = false;
                            let validationClass = '';
                            
                            // Add validation styling if trades-locations mapping is available
                            if (item.validationStatus === 'invalid') {
                                validationClass = 'border-dashed border-2 border-red-400';
                            } else if (item.validationStatus === 'valid') {
                                validationClass = 'border-solid border-2';
                            }
                            
                            // Check if we have actualized status
                            if (item.actualizedStatus) {
                                const status = item.actualizedStatus.toLowerCase();
                                
                                if (status.includes('not started')) {
                                    fillWidth = 0;
                                    fillColor = 'bg-transparent';
                                    isDelayed = false;
                                } else if (status.includes('in progress')) {
                                    fillWidth = plannedWidth * 0.5; // 50% fill
                                    fillColor = 'bg-blue-500';
                                    isDelayed = false;
                                } else if (status.includes('completed')) {
                                    fillWidth = plannedWidth; // 100% fill
                                    fillColor = 'bg-green-500';
                                    
                                    // Check if delayed based on completion date
                                    if (item.actualCompletionDate) {
                                        const completionDate = parseDateSafe(item.actualCompletionDate);
                                        if (completionDate && plannedEnd && completionDate > plannedEnd) {
                                            isDelayed = true;
                                            fillColor = 'bg-red-500';
                                        }
                                    }
                                } else if (status.includes('delayed')) {
                                    fillWidth = plannedWidth * 0.3; // Show some progress but mark as delayed
                                    fillColor = 'bg-red-500';
                                    isDelayed = true;
                                }
                            } else {
                                // Fall back to original status logic
                                const status = item.status ? item.status.toLowerCase() : '';
                                
                                if (status.includes('not started')) {
                                    fillWidth = 0;
                                    fillColor = 'bg-transparent';
                                } else if (status.includes('in progress')) {
                                    fillWidth = plannedWidth * 0.5;
                                    fillColor = 'bg-blue-500';
                                } else if (status.includes('complete') || status.includes('completed')) {
                                    fillWidth = plannedWidth;
                                    fillColor = 'bg-green-500';
                                    
                                    const completedDate = parseDateSafe(item.endDate);
                                    if (completedDate && plannedEnd && completedDate > plannedEnd) {
                                        isDelayed = true;
                                        fillColor = 'bg-red-500';
                                    }
                                } else if (status.includes('delayed') || status.includes('behind')) {
                                    fillWidth = plannedWidth * 0.3;
                                    fillColor = 'bg-red-500';
                                    isDelayed = true;
                                } else {
                                    fillWidth = 0;
                                    fillColor = 'bg-transparent';
                                }
                            }
                            
                            const outlineColor = isDelayed ? 'border-red-500' : 'border-blue-500';
                            const fillStyle = fillWidth > 0 ? `style="width: ${fillWidth}px;"` : '';
                            
                            // Add data attributes for hover information
                            const statusText = item.actualizedStatus || item.status || 'Unknown Status';
                            const completionInfo = item.actualCompletionDate ? ` (Completed: ${item.actualCompletionDate})` : '';
                            const validationInfo = item.validationStatus === 'invalid' ? ' [Invalid Location-Trade]' : 
                                                  item.validationStatus === 'valid' ? ' [Valid Location-Trade]' : '';
                            
                            timelineBarsHtml += `
                                <div class="absolute h-10 flex items-center" style="top: ${(rowIndex - 1) * 40}px; left: ${plannedLeft}px; width: ${plannedWidth}px;">
                                    <div class="h-6 w-full rounded ${outlineColor} relative overflow-hidden ${validationClass}" 
                                         title="${item.activityName || item.name} (${statusText})${completionInfo}${validationInfo}"
                                         data-task-id="${item.id}">
                                        ${fillWidth > 0 ? `<div class="h-full ${fillColor} rounded" ${fillStyle}></div>` : ''}
                                    </div>
                                </div>
                            `;
                        }
                    }
                });
            }
            renderRecursive(projectData.children);
            const totalHeight = rowIndex * 40;
            timelineBody.style.width = `${totalDays * dayWidth}px`;
            timelineBody.style.height = `${totalHeight}px`;
            hierarchyBody.style.height = `${totalHeight}px`;
            let gridLinesHtml = '';
            const months = [];
            let tempDate = new Date(overallStartDate);
            tempDate.setDate(1);
            while (tempDate <= addDays(overallEndDate, 30)) {
                months.push(new Date(tempDate));
                tempDate.setMonth(tempDate.getMonth() + 1);
            }
            months.forEach(monthDate => {
                const startOffsetDays = getDaysBetween(overallStartDate, monthDate);
                if (startOffsetDays > 0 && startOffsetDays < totalDays) {
                    const left = startOffsetDays * dayWidth;
                    gridLinesHtml += `<div class="absolute top-0 bottom-0 w-px bg-slate-200" style="left: ${left}px;"></div>`;
                }
            });
            const todayOffset = getDaysBetween(overallStartDate, today);
            if (todayOffset >= 0 && todayOffset < totalDays) {
                gridLinesHtml += `<div class="absolute top-0 bottom-0 w-0.5 bg-blue-500 z-10" style="left: ${todayOffset * dayWidth}px;"></div>`;
            }
            timelineBody.innerHTML = gridLinesHtml + timelineBarsHtml;
            renderTimelineHeader();
            lucide.createIcons();
        }

        function renderTimelineHeader() {
            let yearRowHtml = '';
            let monthRowHtml = '';
            const months = [];
            let tempDate = new Date(overallStartDate);
            tempDate.setDate(1);
            while (tempDate < addDays(overallEndDate, 30)) {
                months.push(new Date(tempDate));
                tempDate.setMonth(tempDate.getMonth() + 1);
            }
            let yearSpans = {};
            months.forEach(m => {
                const year = m.getFullYear();
                if (!yearSpans[year]) yearSpans[year] = 0;
                yearSpans[year]++;
            });
            let yearGridTemplateColumns = '';
            for (const year in yearSpans) {
                let yearWidth = 0;
                months.filter(m => m.getFullYear() == year).forEach(m => {
                    const daysInMonth = new Date(m.getFullYear(), m.getMonth() + 1, 0).getDate();
                    yearWidth += daysInMonth * dayWidth;
                });
                yearGridTemplateColumns += `${yearWidth}px `;
                yearRowHtml += `<div class="text-sm font-semibold text-slate-600 p-1 text-center border-r border-slate-200">${year}</div>`;
            }
            let monthGridTemplateColumns = '';
            months.forEach(monthDate => {
                const daysInMonth = new Date(monthDate.getFullYear(), monthDate.getMonth() + 1, 0).getDate();
                const monthWidth = daysInMonth * dayWidth;
                monthGridTemplateColumns += `${monthWidth}px `;
                const monthName = monthDate.toLocaleString('default', { month: 'short' }).toUpperCase();
                monthRowHtml += `<div class="h-8 flex items-center justify-center border-l border-slate-200 text-xs text-slate-500">${monthName}</div>`;
            });
            const totalWidth = totalDays * dayWidth;
            timelineHeaderWrapper.innerHTML = `
                <div style="width: ${totalWidth}px;">
                    <div class="grid" style="grid-template-columns: ${yearGridTemplateColumns.trim()};">
                        ${yearRowHtml}
                    </div>
                    <div class="grid border-t border-slate-200" style="grid-template-columns: ${monthGridTemplateColumns.trim()};">
                        ${monthRowHtml}
                    </div>
                </div>
            `;
        }

        // --- Filter and Search Logic ---
        function applyFilters() {
            const searchTerm = searchInput.value.toLowerCase();
            const activeFilters = [...filterOptions.querySelectorAll('input:checked')].map(el => el.value);

            function filterRecursive(items) {
                let isAnyChildVisible = false;
                items.forEach(item => {
                    const hasMatchingChild = item.children ? filterRecursive(item.children) : false;

                    const matchesSearch = item.name.toLowerCase().includes(searchTerm);
                    const matchesFilter = activeFilters.length === 0 || 
                        (item.level === 1 && activeFilters.includes(item.id)) || 
                        item.level !== 1;

                    item.visible = (matchesSearch || hasMatchingChild) && matchesFilter;

                    if(item.visible) isAnyChildVisible = true;
                });
                return isAnyChildVisible;
            }

            filterRecursive(projectData.children);
            render();
        }

        function populateFilterPanel() {
    filterOptions.innerHTML = '';
    if (!projectData || !projectData.children) return;
    const level1Items = projectData.children;
    level1Items.forEach(item => {
        if(item.level === 1) {
                    const label = document.createElement('label');
                    label.className = 'flex items-center space-x-2 cursor-pointer';
                    label.innerHTML = `
                        <input type="checkbox" value="${item.id}" class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                        <span>${item.name}</span>
                    `;
                    filterOptions.appendChild(label);
                }
            });
        }

        // --- Utility Functions ---
        function showLoading() {
            // Simple loading indicator - can be enhanced later
            console.log('Processing CSV data...');
        }

        // --- Event Handling ---
        /**
         * Sets up all event listeners for the timeline UI.
         */
        function setupEventListeners() {
            // Hierarchy expand/collapse
            hierarchyBody.addEventListener('click', (e) => {
                const row = e.target.closest('[data-id]');
                if (!row) return;
                const id = row.dataset.id;
                const item = findDataItem(projectData.children, id);
                if (item && item.children && item.children.length > 0) {
                    item.isExpanded = item.isExpanded === undefined ? false : !item.isExpanded;
                    render();
                }
            });

            // Search
            searchInput.addEventListener('input', applyFilters);

            // Filter panel toggle
            filterBtn.addEventListener('click', () => {
                filterPanel.classList.toggle('hidden');
            });
            clearFilterBtn.addEventListener('click', () => {
                filterOptions.querySelectorAll('input').forEach(input => input.checked = false);
                applyFilters();
            });
            filterOptions.addEventListener('change', applyFilters);

            // Hover card for timeline bars
            timelineBody.addEventListener('mouseover', (e) => {
                const target = e.target.closest('[data-task-id]');
                if (!target) return;
                clearTimeout(hideCardTimeout);
                const taskId = target.dataset.taskId;
                const task = findDataItem(projectData.children, taskId);
                if (task) {
                    showHoverCard(e, task);
                }
            });
            timelineBody.addEventListener('mouseout', (e) => {
                const target = e.target.closest('[data-task-id]');
                if (target) {
                    hideCardTimeout = setTimeout(hideHoverCard, 200);
                }
            });
            hoverCard.addEventListener('mouseover', () => {
                clearTimeout(hideCardTimeout);
            });
            hoverCard.addEventListener('mouseout', () => {
                hideCardTimeout = setTimeout(hideHoverCard, 200);
            });
            document.body.addEventListener('mousemove', (e) => {
                positionHoverCard(e);
            });

            // Sync scrolling between hierarchy and timeline
            const gridWrapper = document.querySelector('.timeline-grid-wrapper');
            gridWrapper.addEventListener('scroll', () => {
                timelineHeaderWrapper.scrollLeft = gridWrapper.scrollLeft;
                hierarchyBody.scrollTop = gridWrapper.scrollTop;
            });

            // CSV upload and processing
            csvUpload.addEventListener('change', e => {
                const file = e.target.files[0];
                processCsvBtn.disabled = !file;
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function(evt) {
                    const text = evt.target.result;
                    const rows = parseCsv(text);
                    const treeData = buildTreeFromCsv(rows);
                    processData(treeData);
                };
                reader.readAsText(file);
            });
            processCsvBtn.addEventListener('click', () => {
    if (!projectData) return;
    showLoading();
    setTimeout(() => {
        render();
        populateFilterPanel();
    }, 100); // Allow loading indicator to render
});

            // Schedule upload and processing
            scheduleUpload.addEventListener('change', e => {
                const file = e.target.files[0];
                processScheduleBtn.disabled = !file;
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function(evt) {
                    const text = evt.target.result;
                    const rows = parseCsv(text);
                    processScheduleData(rows); // Call the new function
                };
                reader.readAsText(file);
            });
            processScheduleBtn.addEventListener('click', () => {
                if (!projectData) return;
                showLoading();
                setTimeout(() => {
                    // This button will trigger the actual schedule loading/merging logic
                    // For now, it just re-renders the hierarchy and timeline
                    // to reflect the current projectData structure.
                    render();
                    populateFilterPanel();
                    scheduleStatus.textContent = 'Schedule Loaded';
                    scheduleStatus.classList.remove('bg-slate-100', 'text-slate-600');
                    scheduleStatus.classList.add('bg-green-100', 'text-green-600');
                }, 100);
            });

            // Actualized work upload and processing
            actualizedUpload.addEventListener('change', e => {
                const file = e.target.files[0];
                processActualizedBtn.disabled = !file;
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function(evt) {
                    const text = evt.target.result;
                    const rows = parseActualizedCsv(text);
                    processActualizedWork(rows); // Call the new function
                };
                reader.readAsText(file);
            });
            processActualizedBtn.addEventListener('click', () => {
                if (!projectData) return;
                showLoading();
                setTimeout(() => {
                    // This button will trigger the actual actualized work loading/merging logic
                    // For now, it just re-renders the hierarchy and timeline
                    // to reflect the current projectData structure.
                    render();
                    populateFilterPanel();
                    actualizedStatus.textContent = 'Actualized Data Loaded';
                    actualizedStatus.classList.remove('bg-slate-100', 'text-slate-600');
                    actualizedStatus.classList.add('bg-green-100', 'text-green-600');
                }, 100);
            });

            // Trades-Locations Mapping Upload and Processing
            tradesLocationsUpload.addEventListener('change', e => {
                const file = e.target.files[0];
                processTradesLocationsBtn.disabled = !file;
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function(evt) {
                    const text = evt.target.result;
                    const rows = parseCsv(text);
                    loadTradesLocationsMapping(rows);
                    
                    // Update status indicator with detailed info
                    const totalTrades = Array.from(tradesLocationsMap.values()).reduce((sum, trades) => sum + trades.size, 0);
                    tradesLocationsStatus.textContent = `Mapping (${tradesLocationsMap.size} locations, ${totalTrades} trades)`;
                    tradesLocationsStatus.classList.remove('bg-slate-100', 'text-slate-600');
                    tradesLocationsStatus.classList.add('bg-purple-100', 'text-purple-600');
                };
                reader.readAsText(file);
            });
            processTradesLocationsBtn.addEventListener('click', () => {
                if (!tradesLocationsMap) {
                    showToast('Please load a trades-locations mapping file first', 'error');
                    return;
                }
                showLoading();
                setTimeout(() => {
                    // This button will trigger the actual trades-locations mapping loading/merging logic
                    // For now, it just re-renders the hierarchy and timeline
                    // to reflect the current tradesLocationsMap structure.
                    render();
                    populateFilterPanel();
                    tradesLocationsStatus.textContent = 'Mapping Loaded';
                    tradesLocationsStatus.classList.remove('bg-slate-100', 'text-slate-600');
                    tradesLocationsStatus.classList.add('bg-purple-100', 'text-purple-600');
                }, 100);
            });
        }

        // Call once on load
        setupEventListeners();

        // --- Data Handling ---
        /**
         * Parses CSV text into an array of row objects, stripping quotes and trimming whitespace.
         * @param {string} text - The CSV text.
         * @returns {Array<Object>} Array of row objects.
         */
        function parseCsv(text) {
            function stripQuotes(str) {
                return str.replace(/^"+|"+$/g, '').trim();
            }
            const lines = text.split(/\r?\n/).filter(line => line.trim());
            if (lines.length < 2) return [];
            // Normalize headers: trim, lowercase, strip quotes
            const rawHeaders = lines[0].split(',').map(h => stripQuotes(h).toLowerCase());
            // Map normalized headers to expected keys
            const headerMap = {
                'location': 'location',
                'trade': 'trade',
                'status': 'status',
                'start date': 'start date',
                'finish date': 'finish date',
                'end date': 'finish date', // Alternative header name
                'duration': 'duration'
            };
            const headers = rawHeaders.map(h => headerMap[h] || h);
            const rows = lines.slice(1).map(line => {
                const values = line.split(',').map(stripQuotes);
                const obj = {};
                headers.forEach((h, i) => {
                    obj[h] = values[i] !== undefined ? values[i] : '';
                });
                return obj;
            });
            if (rows.length) console.log('First parsed row:', rows[0]);
            return rows;
        }
        
        /**
         * Parses actualized work CSV with Location, Trade, Status format
         * @param {string} text - The CSV text.
         * @returns {Array<Object>} Array of row objects.
         */
        function parseActualizedCsv(text) {
            function stripQuotes(str) {
                return str.replace(/^"+|"+$/g, '').trim();
            }
            const lines = text.split(/\r?\n/).filter(line => line.trim());
            if (lines.length < 2) return [];
            
            // Normalize headers: trim, lowercase, strip quotes
            const rawHeaders = lines[0].split(',').map(h => stripQuotes(h).toLowerCase());
            
            // Map normalized headers to expected keys for actualized work
            const headerMap = {
                'location': 'location',
                'trade': 'trade',
                'status': 'status'
            };
            
            const headers = rawHeaders.map(h => headerMap[h] || h);
            const rows = lines.slice(1).map(line => {
                const values = line.split(',').map(stripQuotes);
                const obj = {};
                headers.forEach((h, i) => {
                    obj[h] = values[i] !== undefined ? values[i] : '';
                });
                return obj;
            });
            
            if (rows.length) console.log('First actualized row:', rows[0]);
            return rows;
        }

        /**
         * Finds a data item by id in a tree of items.
         * @param {Array} items - The tree to search.
         * @param {string} id - The id to find.
         * @returns {Object|null} The found item or null.
         */
        function findDataItem(items, id) {
            for (const item of items) {
                if (item.id === id) return item;
                if (item.children) {
                    const found = findDataItem(item.children, id);
                    if (found) return found;
                }
            }
            return null;
        }

        /**
         * Shows the hover card for a timeline bar.
         * @param {MouseEvent} event
         * @param {Object} task
         */
        function showHoverCard(event, task) {
            document.getElementById('hover-card-img').src = `https://placehold.co/600x400/a3a3a3/ffffff?text=${encodeURIComponent(task.trade || task.activityName)}`;
            document.getElementById('hover-card-title').textContent = task.trade || task.activityName;
            document.getElementById('hover-card-group').textContent = task.location;
            
            // Show actualized status if available, otherwise fall back to original status
            const statusText = task.actualizedStatus || task.status || 'Unknown';
            document.getElementById('hover-card-status').textContent = statusText;
            
            // Show schedule dates
            const scheduleInfo = `${task.startDate || 'Not set'} to ${task.endDate || 'Not set'}`;
            if (task.duration) {
                scheduleInfo += ` (${task.duration} days)`;
            }
            document.getElementById('hover-card-planned').textContent = scheduleInfo;
            
            // Show comprehensive actualized information
            let actualInfo = 'No actualized data';
            if (task.actualizedStatus) {
                actualInfo = `Status: ${task.actualizedStatus}`;
                if (task.actualCompletionDate) {
                    actualInfo += ` (Completed: ${task.actualCompletionDate})`;
                }
                
                // Add validation info if trades-locations mapping is available
                if (tradesLocationsMap && task.location && task.trade) {
                    const isValid = isValidLocationTradeCombination(task.location, task.trade);
                    if (!isValid) {
                        const suggestions = suggestSimilarTrades(task.location, task.trade);
                        actualInfo += ` [Invalid combination]`;
                        if (suggestions.length > 0) {
                            actualInfo += ` Suggestions: ${suggestions.slice(0, 3).join(', ')}`;
                        }
                    } else {
                        actualInfo += ` [Valid combination]`;
                    }
                }
            } else if (task.originalLocation) {
                actualInfo = `Original: ${task.originalLocation}`;
                
                // Add validation info for schedule items
                if (tradesLocationsMap && task.location && task.trade) {
                    const isValid = isValidLocationTradeCombination(task.location, task.trade);
                    if (!isValid) {
                        const suggestions = suggestSimilarTrades(task.location, task.trade);
                        actualInfo += ` [Invalid combination]`;
                        if (suggestions.length > 0) {
                            actualInfo += ` Suggestions: ${suggestions.slice(0, 3).join(', ')}`;
                        }
                    } else {
                        actualInfo += ` [Valid combination]`;
                    }
                }
            }
            document.getElementById('hover-card-actual').textContent = actualInfo;
            
            hoverCard.classList.remove('hidden');
            setTimeout(() => hoverCard.classList.remove('opacity-0'), 10); // Fade in
            positionHoverCard(event);
        }

        /**
         * Hides the hover card.
         */
        function hideHoverCard() {
            hoverCard.classList.add('opacity-0');
            setTimeout(() => hoverCard.classList.add('hidden'), 200); // Wait for fade out
        }

        /**
         * Positions the hover card near the mouse.
         * @param {MouseEvent} event
         */
        function positionHoverCard(event) {
            const offsetX = 15;
            const offsetY = 15;
            hoverCard.style.left = `${event.clientX + offsetX}px`;
            hoverCard.style.top = `${event.clientY + offsetY}px`;
        }

        function exportCsv(activities) {
    const headers = ['Location','Trade','Status','Start Date','Finish Date','Duration'];
    const rows = [headers.join(',')];
    activities.forEach(a => {
        rows.push([
            a.location || '',
            a.trade || '',
            a.status || '',
            a.startDate || '',
            a.endDate || '',
            a.duration || ''
        ].join(','));
    });
    const blob = new Blob([rows.join('\n')], {type:'text/csv'});
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'timeline_export.csv';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);
}
        // --- Initial Render ---
        render();
        populateFilterPanel();
    </script>
</body>
</html> 