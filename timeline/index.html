<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Progress AI Tracker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Custom scrollbar for better aesthetics */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f5f9;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #94a3b8;
            border-radius: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        /* Layout for frozen panes */
        .timeline-grid-wrapper {
            display: grid;
            grid-template-columns: 300px 1fr;
            overflow: auto;
            height: calc(100vh - 225px); /* Adjust based on header/legend/filter height */
        }

        .sticky-header {
            position: sticky;
            top: 0;
            z-index: 20;
        }

        .sticky-col {
            position: sticky;
            left: 0;
            z-index: 10;
        }

        /* Style for behind-schedule tasks */
        .behind-schedule-bar {
            background-color: #ef4444; /* red-500 */
        }

        #hover-card {
            transition: opacity 0.2s;
        }

        .truncate-ellipsis {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .day-container {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            margin-right: 4px;
            font-size: 10px;
            font-weight: 500;
        }
    </style>
</head>
<body class="bg-slate-100 text-slate-800 min-h-screen">
  <!-- Global Sidebar will be injected here -->

  <!-- Main Content -->
  <div class="flex-1 flex flex-col overflow-hidden">
            <!-- Top Header -->
            <header class="bg-white border-b border-slate-200 flex-shrink-0">
                <div class="flex items-center justify-between p-4">
                    <div class="flex items-center gap-6">
                        <div class="flex items-center gap-3">
                            <i data-lucide="calendar" class="w-7 h-7 text-blue-600"></i>
                            <span class="text-xl font-bold text-slate-800">Timeline Creator</span>
                        </div>
                        
                        <!-- File Upload -->
                        <div class="flex items-center gap-3">
                            <button id="choose-file-btn" class="px-4 py-2 rounded-lg bg-blue-600 text-white font-semibold text-sm hover:bg-blue-700">Choose File</button>
                            <button id="process-csv-btn" class="px-4 py-2 rounded-lg bg-blue-600 text-white font-semibold text-sm disabled:bg-slate-300 disabled:cursor-not-allowed" disabled>Process</button>
                        </div>
                    </div>
                    
                    <div class="flex items-center gap-4">
                        <!-- Search Box -->
                        <div class="relative w-64">
                            <i data-lucide="search" class="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-slate-400"></i>
                            <input type="text" id="search-input" placeholder="Search hierarchy..." class="w-full pl-9 pr-4 py-2 text-sm border border-slate-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none">
                        </div>
                        
                        <!-- Filter Zones Button -->
                        <div class="relative">
                            <button id="filter-btn" class="flex items-center gap-2 px-3 py-2 text-sm font-medium text-slate-700 bg-white border border-slate-300 rounded-lg hover:bg-slate-50">
                                <i data-lucide="filter" class="w-4 h-4"></i>
                                <span>Filter Zones</span>
                            </button>
                            <div id="filter-panel" class="hidden absolute top-full right-0 mt-2 w-72 bg-white border border-slate-200 rounded-lg shadow-lg z-40">
                                <div class="p-3 border-b flex justify-between items-center">
                                    <h4 class="font-semibold text-sm">Filter by Zone</h4>
                                    <button id="clear-filter-btn" class="text-xs text-blue-600 hover:underline">Clear all</button>
                                </div>
                                <div id="filter-options" class="p-3 max-h-60 overflow-y-auto custom-scrollbar space-y-2">
                                    <!-- Checkboxes will be generated here -->
                                </div>
                            </div>
                        </div>
                        
                        <!-- View Toggle -->
                        <div class="flex bg-white rounded-lg border border-slate-300 p-1">
                            <button id="chronological-view-btn" class="px-3 py-1.5 text-sm font-medium rounded-md transition-colors bg-blue-600 text-white shadow-sm">Chronological</button>
                            <button id="zone-view-btn" class="px-3 py-1.5 text-sm font-medium rounded-md transition-colors text-slate-700 hover:bg-slate-100">By Zone</button>
                        </div>
                        
                        <div class="w-9 h-9 rounded-full bg-slate-200 flex items-center justify-center text-slate-600 font-bold">U</div>
                    </div>
                </div>
            </header>

            <!-- Main dashboard area -->
            <main class="flex-1 overflow-hidden">
                <div class="p-4 lg:p-6 h-full">
                    <div class="bg-white rounded-xl shadow-sm h-full flex flex-col">
                        <!-- Legend -->
                        <div class="p-3 border-b border-slate-200 flex items-center justify-between text-sm">
                            <div class="flex items-center gap-6">
                                <div class="flex items-center gap-2">
                                    <div class="w-10 h-4 rounded border-2 border-slate-400"></div>
                                    <span class="text-slate-600 font-medium">Planned Schedule</span>
                                </div>
                                <div class="flex items-center gap-2">
                                    <div class="w-10 h-4 rounded bg-slate-400"></div>
                                    <span class="text-slate-600 font-medium">Actual Progress</span>
                                </div>
                            </div>
                            <div class="flex items-center gap-4">
                                <label class="flex items-center gap-2 cursor-pointer">
                                    <input type="checkbox" id="show-matched-only" class="w-4 h-4 text-green-600 border-slate-300 rounded focus:ring-green-500">
                                    <span class="text-sm font-medium text-slate-700">Show Matched Items Only</span>
                                </label>
                                <span id="match-count" class="text-xs text-slate-500 bg-slate-100 px-2 py-1 rounded-full"></span>
                            </div>
                        </div>



                        <!-- Timeline Grid -->
                        <div class="timeline-grid-wrapper custom-scrollbar">
                            <!-- Corner block -->
                            <div class="p-3 border-r border-b border-slate-200 bg-slate-100 sticky top-0 left-0 z-30">
                                <h3 class="font-semibold text-slate-600 text-sm">Hierarchy</h3>
                            </div>

                            <!-- X-Axis Header -->
                            <div id="timeline-header-wrapper" class="border-b border-slate-200 bg-slate-100/80 backdrop-blur-sm sticky top-0 z-20">
                                <!-- JS generates date headers here -->
                            </div>

                            <!-- Y-Axis Body (Hierarchy Labels) -->
                            <div id="hierarchy-body" class="border-r border-slate-200 bg-white sticky left-0 z-10">
                                <!-- JS generates hierarchy here -->
                            </div>

                            <!-- X-Axis Body (Timeline Bars) -->
                            <div id="timeline-body-wrapper" class="overflow-visible">
                                <div id="timeline-body" class="relative">
                                    <!-- JS generates timeline bars and grid lines here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>

    <!-- File Type Selection Modal -->
    <div id="file-type-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-xl p-6 w-96">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-semibold text-slate-800">Choose File Type</h3>
                <button id="close-modal" class="text-slate-400 hover:text-slate-600">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
            <div class="space-y-4">
                <div class="border border-slate-200 rounded-lg p-4 hover:bg-slate-50 cursor-pointer" id="schedule-option">
                    <div class="flex items-center gap-3">
                        <div class="w-10 h-4 rounded border-2 border-slate-400"></div>
                        <div>
                            <h4 class="font-medium text-slate-800">Schedule</h4>
                            <p class="text-sm text-slate-500">Upload planned schedule data</p>
                        </div>
                    </div>
                </div>
                <div class="border border-slate-200 rounded-lg p-4 hover:bg-slate-50 cursor-pointer" id="actualized-option">
                    <div class="flex items-center gap-3">
                        <div class="w-10 h-4 rounded bg-slate-400"></div>
                        <div>
                            <h4 class="font-medium text-slate-800">Actualized Work</h4>
                            <p class="text-sm text-slate-500">Upload actual progress data</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden file inputs -->
    <input type="file" id="schedule-csv-upload" accept=".csv" style="display: none;">
    <input type="file" id="actualized-csv-upload" accept=".csv" style="display: none;">

    <!-- Hover Card -->
    <div id="hover-card" class="hidden absolute z-50 p-3 bg-white rounded-lg shadow-xl w-64 border border-slate-200 pointer-events-none opacity-0">
        <img id="hover-card-img" src="" class="w-full h-32 object-cover rounded-md mb-2 bg-slate-200" alt="Task Image">
        <h4 id="hover-card-title" class="font-bold text-slate-800"></h4>
        <p id="hover-card-group" class="text-sm text-slate-500 mb-2"></p>
        <div class="text-xs space-y-1 text-slate-600">
            <p><strong>Status:</strong> <span id="hover-card-status"></span></p>
            <p><strong>Planned:</strong> <span id="hover-card-planned"></span></p>
            <p><strong>Actual:</strong> <span id="hover-card-actual"></span></p>
        </div>
    </div>

    <script>
    // Initialize Lucide Icons
    lucide.createIcons();

    // --- Configuration ---
            const dayWidth = 24; // 20px container + 4px spacing for each day
    let today = new Date('2025-07-03T00:00:00Z'); // Default date
    let projectData; // Global project data
    let actualizedData = []; // Actual progress data
    let overallStartDate, overallEndDate, totalDays;
    let hideCardTimeout;
            let viewMode = 'chronological'; // 'chronological' or 'zone'
        let showMatchedOnly = false; // Filter to show only items with actualized data

    // --- Date & Scheduling ---
    const addDays = (date, days) => new Date(date.valueOf() + days * 864e5);
    const getDaysBetween = (start, end) => Math.round((end - start) / 864e5);
    function parseDateSafe(dateStr) {
        if (!dateStr) return null;
        const d = new Date(dateStr);
        return isNaN(d.getTime()) ? null : d;
    }

    // --- Data Handling ---
    function processData(data) {
        projectData = data;
        const allDates = [];
        function collectDatesAndStatus(items) {
            if (!items) return;
            items.forEach(item => {
                item.visible = true;
                const s = parseDateSafe(item.startDate);
                const e = parseDateSafe(item.endDate);
                const as = parseDateSafe(item.actualStartDate);
                const ae = parseDateSafe(item.actualEndDate);
                if (s) allDates.push(s);
                if (e) allDates.push(e);
                if (as) allDates.push(as);
                if (ae) allDates.push(ae);
                if (s && !item.status) {
                    if (ae) item.status = 'Complete';
                    else if (as) item.status = 'In Progress';
                    else if (s < today) item.status = 'Behind Schedule';
                    else item.status = 'Not Started';
                }
                if (item.children) collectDatesAndStatus(item.children);
            });
        }
        collectDatesAndStatus([projectData]);
        overallStartDate = allDates.length > 0 ? new Date(Math.min(...allDates)) : new Date();
        overallEndDate = allDates.length > 0 ? new Date(Math.max(...allDates)) : new Date();
        totalDays = getDaysBetween(overallStartDate, addDays(overallEndDate, 30));
    }

    function buildTreeFromCsv(rows) {
        const root = { id: 'root', name: 'Project', level: 0, children: [] };
        const locationMap = {};
        rows.forEach(row => {
            const location = row['location'] || 'Unknown';
            if (!locationMap[location]) {
                locationMap[location] = {
                    id: location.replace(/\s+/g, '-').toLowerCase(),
                    name: location,
                    level: 1,
                    children: [],
                };
                root.children.push(locationMap[location]);
            }
            locationMap[location].children.push({
                id: row['activity id'] || row['activity name'],
                name: row['activity name'],
                level: 3, // <-- set to 3 so bars are rendered
                location: location,
                activityId: row['activity id'],
                activityName: row['activity name'],
                startDate: row['start date'],
                endDate: row['finish date'],
                duration: row['duration']
            });
        });
        return root;
    }

        // --- DOM Elements ---
        const hierarchyBody = document.getElementById('hierarchy-body');
        const timelineHeaderWrapper = document.getElementById('timeline-header-wrapper');
        const timelineBodyWrapper = document.getElementById('timeline-body-wrapper');
        const timelineBody = document.getElementById('timeline-body');
        const searchInput = document.getElementById('search-input');
        const filterBtn = document.getElementById('filter-btn');
        const filterPanel = document.getElementById('filter-panel');
        const filterOptions = document.getElementById('filter-options');
        const clearFilterBtn = document.getElementById('clear-filter-btn');
        const hoverCard = document.getElementById('hover-card');
        const chooseFileBtn = document.getElementById('choose-file-btn');
        const processCsvBtn = document.getElementById('process-csv-btn');
        const fileTypeModal = document.getElementById('file-type-modal');
        const closeModal = document.getElementById('close-modal');
        const scheduleOption = document.getElementById('schedule-option');
        const actualizedOption = document.getElementById('actualized-option');
        const scheduleCsvUpload = document.getElementById('schedule-csv-upload');
        const actualizedCsvUpload = document.getElementById('actualized-csv-upload');

        // Add Export CSV button to the header
        const header = document.querySelector('header .flex.items-center.gap-4');
        if (header) {
            const exportBtn = document.createElement('button');
            exportBtn.id = 'export-csv-btn';
            exportBtn.className = 'flex items-center gap-2 px-4 py-2 text-sm font-medium text-slate-700 bg-white border border-slate-300 rounded-md hover:bg-slate-50';
            exportBtn.innerHTML = '<i data-lucide="download" class="w-4 h-4"></i> Export CSV';
            exportBtn.disabled = !projectData || !Array.isArray(projectData.children) || projectData.children.length === 0;
            exportBtn.addEventListener('click', () => {
                if (!projectData || !Array.isArray(projectData.children)) return;
                // Flatten all activities (level 3) from the tree
                const activities = [];
                function collectActivities(items) {
                    if (!Array.isArray(items)) return;
                    items.forEach(item => {
                        if (item.level === 3) activities.push(item);
                        if (item.children) collectActivities(item.children);
                    });
                }
                collectActivities(projectData.children);
                exportCsv(activities);
            });
            header.appendChild(exportBtn);
            lucide.createIcons();
        }

        /**
         * Flattens the hierarchical data into a single chronological list for chronological view.
         * @param {Array} items - The hierarchical data to flatten.
         * @returns {Array} - Flattened array of activities sorted by start date.
         */
        function flattenDataForChronologicalView(items) {
            const flattened = [];
            
            function collectActivities(items) {
                if (!Array.isArray(items)) return;
                items.forEach(item => {
                    if (item.level === 3) {
                        // This is an activity, add it to the flattened list
                        flattened.push({
                            ...item,
                            level: 3, // Keep as level 3 for rendering
                            isVisible: true,
                            isExpanded: true
                        });
                    } else if (item.children && item.children.length > 0) {
                        // Recursively collect activities from children
                        collectActivities(item.children);
                    }
                });
            }
            
            collectActivities(items);
            
            // Sort by start date
            flattened.sort((a, b) => {
                const dateA = parseDateSafe(a.startDate);
                const dateB = parseDateSafe(b.startDate);
                if (!dateA && !dateB) return 0;
                if (!dateA) return 1;
                if (!dateB) return -1;
                return dateA - dateB;
            });
            
            return flattened;
        }

        // --- Rendering ---
        function render() {
            console.log('projectData:', projectData);
            if (!projectData || !Array.isArray(projectData.children)) {
                console.error('No valid projectData.children to render:', projectData);
                return;
            }
            
            // Prepare data based on view mode
            let dataToRender;
            if (viewMode === 'chronological') {
                dataToRender = flattenDataForChronologicalView(projectData.children);
            } else {
                dataToRender = projectData.children;
            }
            
            hierarchyBody.innerHTML = '';
            timelineBody.innerHTML = '';
            let rowIndex = 0;
            let timelineBarsHtml = '';
            
            function renderRecursive(items, parentId = 'root', parentIsVisible = true) {
                if (!Array.isArray(items)) return;
                items.forEach(item => {
                    const hasChildren = item.children && item.children.length > 0;
                    const isExpanded = item.isExpanded === undefined ? true : item.isExpanded;
                    const isVisible = parentIsVisible && item.visible;
                    
                    // Apply matched-only filter
                    if (showMatchedOnly && item.level === 3 && !item.hasActualData) {
                        return; // Skip this item if it doesn't have actualized data
                    }
                    
                    // In chronological view, skip location headers and only show activities
                    if (viewMode === 'chronological' && item.level !== 3) {
                        if (hasChildren && isExpanded) renderRecursive(item.children, item.id, isVisible && isExpanded);
                        return;
                    }
                    
                    if (item.level === 1 || item.level === 2) {
                        const row = document.createElement('div');
                        row.id = `row-${item.id}`;
                        row.dataset.id = item.id;
                        row.dataset.parentId = parentId;
                        row.className = `flex items-center h-10 border-b border-slate-200 text-sm font-bold text-slate-700 bg-slate-50 hover:bg-slate-100 ${!isVisible ? 'hidden' : ''}`;
                        let expanderIcon = hasChildren ? `<i data-lucide="chevron-right" class="w-4 h-4 mr-1 transition-transform ${isExpanded ? 'rotate-90' : ''}"></i>` : '<span class="w-5 mr-1"></span>';
                        row.innerHTML = `
                            <div style="width: 300px; padding-left: ${item.level === 1 ? '1.25rem' : '2.5rem'};" class="flex items-center flex-shrink-0 cursor-pointer truncate-ellipsis">${expanderIcon}<span>${item.name}</span></div>
                            <div style="flex:1;" class="flex-shrink-0"></div>
                        `;
                        hierarchyBody.appendChild(row);
                        if(isVisible) rowIndex++;
                        if (hasChildren && isExpanded) renderRecursive(item.children, item.id, isVisible && isExpanded);
                    } else if (item.level === 3) {
                        const row = document.createElement('div');
                        row.id = `row-${item.id}`;
                        row.dataset.id = item.id;
                        row.dataset.parentId = parentId;
                        row.className = `flex items-center h-10 border-b border-slate-200 text-sm text-slate-700 hover:bg-slate-50 ${!isVisible ? 'hidden' : ''}`;
                        
                        // In chronological view, show location in the activity name
                        let displayName = item.activityName || item.name;
                        if (viewMode === 'chronological' && item.location) {
                            displayName = `${item.location} - ${displayName}`;
                        }
                        
                        row.innerHTML = `
                            <div style="width: 300px; padding-left: ${viewMode === 'chronological' ? '1.25rem' : '4rem'};" class="flex-shrink-0 truncate-ellipsis" title="${displayName}"><span>${displayName}</span></div>
                            <div style="flex:1;" class="flex-shrink-0"></div>
                        `;
                        hierarchyBody.appendChild(row);
                        if(isVisible) rowIndex++;
                        // Timeline bars
                        const plannedStart = parseDateSafe(item.startDate);
                        const plannedEnd = parseDateSafe(item.endDate);
                        const actualStart = parseDateSafe(item.actualStartDate);
                        const actualEnd = parseDateSafe(item.actualEndDate);

                        if (plannedStart && plannedEnd && isVisible) {
                            const plannedOffsetDays = getDaysBetween(overallStartDate, plannedStart);
                            const plannedDurationDays = Math.max(1, getDaysBetween(plannedStart, plannedEnd));
                            const plannedLeft = plannedOffsetDays * dayWidth;
                            const plannedWidth = plannedDurationDays * dayWidth;
                            
                            // Planned bar (outline)
                            timelineBarsHtml += `<div class="absolute h-10 flex items-center" style="top: ${(rowIndex - 1) * 40}px; left: ${plannedLeft}px; width: ${plannedWidth}px;"><div class="h-6 w-full rounded border-2 border-blue-500" title="${item.activityName || item.name} (Planned)"></div></div>`;
                            
                            // Actual bar (filled) if available
                            if (actualStart && actualEnd && item.hasActualData) {
                                const actualOffsetDays = getDaysBetween(overallStartDate, actualStart);
                                const actualDurationDays = Math.max(1, getDaysBetween(actualStart, actualEnd));
                                const actualLeft = actualOffsetDays * dayWidth;
                                const actualWidth = actualDurationDays * dayWidth;
                                
                                timelineBarsHtml += `<div class="absolute h-10 flex items-center" style="top: ${(rowIndex - 1) * 40}px; left: ${actualLeft}px; width: ${actualWidth}px;"><div class="h-6 w-full rounded bg-slate-400" title="${item.activityName || item.name} (Actual)"></div></div>`;
                            }
                        }
                    }
                });
            }
            renderRecursive(dataToRender);
            const totalHeight = rowIndex * 40;
            timelineBody.style.width = `${totalDays * dayWidth}px`;
            timelineBody.style.height = `${totalHeight}px`;
            hierarchyBody.style.height = `${totalHeight}px`;
            let gridLinesHtml = '';
            const months = [];
            let tempDate = new Date(overallStartDate);
            tempDate.setDate(1);
            while (tempDate <= addDays(overallEndDate, 30)) {
                months.push(new Date(tempDate));
                tempDate.setMonth(tempDate.getMonth() + 1);
            }
            months.forEach(monthDate => {
                const startOffsetDays = getDaysBetween(overallStartDate, monthDate);
                if (startOffsetDays > 0 && startOffsetDays < totalDays) {
                    const left = startOffsetDays * dayWidth;
                    gridLinesHtml += `<div class="absolute top-0 bottom-0 w-px bg-slate-200" style="left: ${left}px;"></div>`;
                }
            });
            const todayOffset = getDaysBetween(overallStartDate, today);
            if (todayOffset >= 0 && todayOffset < totalDays) {
                gridLinesHtml += `<div class="absolute top-0 bottom-0 w-0.5 bg-blue-500 z-10" style="left: ${todayOffset * dayWidth}px;"></div>`;
            }
            timelineBody.innerHTML = gridLinesHtml + timelineBarsHtml;
            renderTimelineHeader();
            lucide.createIcons();
            updateMatchCount();
        }

        function renderTimelineHeader() {
            let yearRowHtml = '';
            let monthRowHtml = '';
            let dayRowHtml = '';
            const months = [];
            let tempDate = new Date(overallStartDate);
            tempDate.setDate(1);
            while (tempDate < addDays(overallEndDate, 30)) {
                months.push(new Date(tempDate));
                tempDate.setMonth(tempDate.getMonth() + 1);
            }
            let yearSpans = {};
            months.forEach(m => {
                const year = m.getFullYear();
                if (!yearSpans[year]) yearSpans[year] = 0;
                yearSpans[year]++;
            });
            let yearGridTemplateColumns = '';
            for (const year in yearSpans) {
                let yearWidth = 0;
                months.filter(m => m.getFullYear() == year).forEach(m => {
                    const daysInMonth = new Date(m.getFullYear(), m.getMonth() + 1, 0).getDate();
                    yearWidth += daysInMonth * dayWidth;
                });
                yearGridTemplateColumns += `${yearWidth}px `;
                yearRowHtml += `<div class="text-sm font-semibold text-slate-600 p-1 text-center border-r border-slate-200">${year}</div>`;
            }
            let monthGridTemplateColumns = '';
            let dayGridTemplateColumns = '';
            months.forEach(monthDate => {
                const daysInMonth = new Date(monthDate.getFullYear(), monthDate.getMonth() + 1, 0).getDate();
                const monthWidth = daysInMonth * dayWidth;
                monthGridTemplateColumns += `${monthWidth}px `;
                const monthName = monthDate.toLocaleString('default', { month: 'short' }).toUpperCase();
                monthRowHtml += `<div class="h-6 flex items-center justify-center border-l border-slate-200 text-xs text-slate-500">${monthName}</div>`;
                
                // Add individual days for this month
                for (let day = 1; day <= daysInMonth; day++) {
                    dayGridTemplateColumns += `${dayWidth}px `;
                    const isToday = monthDate.getFullYear() === today.getFullYear() && 
                                   monthDate.getMonth() === today.getMonth() && 
                                   day === today.getDate();
                    const dayClass = isToday ? 'bg-blue-100 text-blue-700' : 'bg-slate-50 text-slate-600';
                    dayRowHtml += `<div class="day-container ${dayClass}">${day}</div>`;
                }
            });
            const totalWidth = totalDays * dayWidth;
            timelineHeaderWrapper.innerHTML = `
                <div style="width: ${totalWidth}px;">
                    <div class="grid" style="grid-template-columns: ${yearGridTemplateColumns.trim()};">
                        ${yearRowHtml}
                    </div>
                    <div class="grid border-t border-slate-200" style="grid-template-columns: ${monthGridTemplateColumns.trim()};">
                        ${monthRowHtml}
                    </div>
                    <div class="grid border-t border-slate-200" style="grid-template-columns: ${dayGridTemplateColumns.trim()};">
                        ${dayRowHtml}
                    </div>
                </div>
            `;
        }

        // --- Filter and Search Logic ---
        function applyFilters() {
            const searchTerm = searchInput.value.toLowerCase();
            const activeFilters = [...filterOptions.querySelectorAll('input:checked')].map(el => el.value);

            function filterRecursive(items) {
                let isAnyChildVisible = false;
                items.forEach(item => {
                    const hasMatchingChild = item.children ? filterRecursive(item.children) : false;

                    const matchesSearch = item.name.toLowerCase().includes(searchTerm);
                    const matchesFilter = activeFilters.length === 0 || 
                        (item.level === 1 && activeFilters.includes(item.id)) || 
                        item.level !== 1;

                    item.visible = (matchesSearch || hasMatchingChild) && matchesFilter;

                    if(item.visible) isAnyChildVisible = true;
                });
                return isAnyChildVisible;
            }

            filterRecursive(projectData.children);
            render();
        }

        function matchActualizedData() {
            if (!projectData || !actualizedData.length) return;

            let totalScheduledItems = 0;
            let matchedItems = 0;
            const matchStats = {
                exact_id: 0,
                exact_name: 0,
                location: 0,
                partial_name: 0,
                duration_similar: 0,
                date_similar: 0
            };

            function matchRecursive(items) {
                items.forEach(item => {
                    if (item.level === 3) {
                        totalScheduledItems++;
                        // Enhanced tag-based matching with multiple strategies
                        const match = findBestMatch(item, actualizedData);

                        if (match) {
                            matchedItems++;
                            item.actualStartDate = match['start date'];
                            item.actualEndDate = match['finish date'];
                            item.actualDuration = match['duration'];
                            item.hasActualData = true;
                            
                            // Track match statistics
                            match.matchDetails.forEach(detail => {
                                if (detail.startsWith('common_words:')) {
                                    // Skip common_words details for stats
                                } else if (matchStats.hasOwnProperty(detail)) {
                                    matchStats[detail]++;
                                }
                            });
                            
                            console.log(`âœ… Matched: "${item.activityName}" with "${match['activity name']}" (score: ${match.matchScore}, methods: ${match.matchDetails.join(', ')})`);
                        } else {
                            console.log(`âŒ No match found for: "${item.activityName}"`);
                        }
                    }
                    if (item.children) {
                        matchRecursive(item.children);
                    }
                });
            }

            matchRecursive(projectData.children);
            
            // Display matching statistics
            console.log(`\nðŸ“Š Matching Statistics:`);
            console.log(`Total scheduled items: ${totalScheduledItems}`);
            console.log(`Successfully matched: ${matchedItems} (${Math.round(matchedItems/totalScheduledItems*100)}%)`);
            console.log(`Match methods used:`);
            Object.entries(matchStats).forEach(([method, count]) => {
                if (count > 0) {
                    console.log(`  - ${method}: ${count} items`);
                }
            });
            
            // Show user-friendly message
            if (matchedItems > 0) {
                showMessage(`Successfully matched ${matchedItems} out of ${totalScheduledItems} scheduled items with actualized work data`, 'success');
            } else {
                showMessage('No matches found between schedule and actualized work data. Check that the data formats are compatible.', 'error');
            }
            
            // Update match count display
            updateMatchCount();
        }

        /**
         * Enhanced matching function that uses multiple strategies to find the best match
         * @param {Object} scheduledItem - The scheduled activity to match
         * @param {Array} actualizedData - Array of actualized work items
         * @returns {Object|null} - The best matching actualized item or null
         */
        function findBestMatch(scheduledItem, actualizedData) {
            let bestMatch = null;
            let bestScore = 0;

            actualizedData.forEach(actual => {
                let score = 0;
                const matchDetails = [];

                // Strategy 1: Exact ID match (highest priority)
                if (actual['activity id'] && scheduledItem.activityId && 
                    actual['activity id'].toString().trim() === scheduledItem.activityId.toString().trim()) {
                    score += 100;
                    matchDetails.push('exact_id');
                }

                // Strategy 2: Exact name match
                if (actual['activity name'] && scheduledItem.activityName && 
                    actual['activity name'].toString().trim().toLowerCase() === scheduledItem.activityName.toString().trim().toLowerCase()) {
                    score += 90;
                    matchDetails.push('exact_name');
                }

                // Strategy 3: Location match (if available in both)
                if (actual['location'] && scheduledItem.location && 
                    actual['location'].toString().trim().toLowerCase() === scheduledItem.location.toString().trim().toLowerCase()) {
                    score += 30;
                    matchDetails.push('location');
                }

                // Strategy 4: Partial name match (fuzzy matching)
                if (actual['activity name'] && scheduledItem.activityName) {
                    const actualName = actual['activity name'].toString().trim().toLowerCase();
                    const scheduledName = scheduledItem.activityName.toString().trim().toLowerCase();
                    
                    // Check if one contains the other
                    if (actualName.includes(scheduledName) || scheduledName.includes(actualName)) {
                        score += 50;
                        matchDetails.push('partial_name');
                    }
                    
                    // Check for common keywords
                    const actualWords = actualName.split(/\s+/);
                    const scheduledWords = scheduledName.split(/\s+/);
                    const commonWords = actualWords.filter(word => 
                        scheduledWords.some(scheduledWord => 
                            word.length > 3 && scheduledWord.length > 3 && 
                            (word.includes(scheduledWord) || scheduledWord.includes(word))
                        )
                    );
                    if (commonWords.length > 0) {
                        score += commonWords.length * 10;
                        matchDetails.push(`common_words:${commonWords.join(',')}`);
                    }
                }

                // Strategy 5: Duration similarity (if both have duration)
                if (actual['duration'] && scheduledItem.duration) {
                    const actualDur = parseFloat(actual['duration']) || 0;
                    const scheduledDur = parseFloat(scheduledItem.duration) || 0;
                    if (actualDur > 0 && scheduledDur > 0) {
                        const durationDiff = Math.abs(actualDur - scheduledDur) / Math.max(actualDur, scheduledDur);
                        if (durationDiff < 0.2) { // Within 20% difference
                            score += 20;
                            matchDetails.push('duration_similar');
                        }
                    }
                }

                // Strategy 6: Date range overlap (if dates are available)
                if (actual['start date'] && scheduledItem.startDate) {
                    const actualStart = parseDateSafe(actual['start date']);
                    const scheduledStart = parseDateSafe(scheduledItem.startDate);
                    if (actualStart && scheduledStart) {
                        const daysDiff = Math.abs(getDaysBetween(actualStart, scheduledStart));
                        if (daysDiff <= 7) { // Within 7 days
                            score += 15;
                            matchDetails.push('date_similar');
                        }
                    }
                }

                // Update best match if this score is higher
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = { ...actual, matchScore: score, matchDetails };
                }
            });

            // Only return match if score is above threshold
            if (bestScore >= 30) {
                return bestMatch;
            }

            return null;
        }

        function populateFilterPanel() {
    filterOptions.innerHTML = '';
    if (!projectData || !projectData.children) return;
    const level1Items = projectData.children;
    level1Items.forEach(item => {
        if(item.level === 1) {
                    const label = document.createElement('label');
                    label.className = 'flex items-center space-x-2 cursor-pointer';
                    label.innerHTML = `
                        <input type="checkbox" value="${item.id}" class="h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500">
                        <span>${item.name}</span>
                    `;
                    filterOptions.appendChild(label);
                }
            });
        }

        // --- Utility Functions ---
        function showLoading() {
            // Simple loading indicator - can be enhanced later
            console.log('Processing CSV data...');
        }

        // --- Event Handling ---
        /**
         * Sets up all event listeners for the timeline UI.
         */
        function setupEventListeners() {
            // Hierarchy expand/collapse
            hierarchyBody.addEventListener('click', (e) => {
                const row = e.target.closest('[data-id]');
                if (!row) return;
                const id = row.dataset.id;
                const item = findDataItem(projectData.children, id);
                if (item && item.children && item.children.length > 0) {
                    item.isExpanded = item.isExpanded === undefined ? false : !item.isExpanded;
                    render();
                }
            });

            // Search
            searchInput.addEventListener('input', applyFilters);

            // Filter panel toggle
            filterBtn.addEventListener('click', () => {
                filterPanel.classList.toggle('hidden');
            });
            clearFilterBtn.addEventListener('click', () => {
                filterOptions.querySelectorAll('input').forEach(input => input.checked = false);
                applyFilters();
            });
            filterOptions.addEventListener('change', applyFilters);

            // Hover card for timeline bars
            timelineBody.addEventListener('mouseover', (e) => {
                const target = e.target.closest('[data-task-id]');
                if (!target) return;
                clearTimeout(hideCardTimeout);
                const taskId = target.dataset.taskId;
                const task = findDataItem(projectData.children, taskId);
                if (task) {
                    showHoverCard(e, task);
                }
            });
            timelineBody.addEventListener('mouseout', (e) => {
                const target = e.target.closest('[data-task-id]');
                if (target) {
                    hideCardTimeout = setTimeout(hideHoverCard, 200);
                }
            });
            hoverCard.addEventListener('mouseover', () => {
                clearTimeout(hideCardTimeout);
            });
            hoverCard.addEventListener('mouseout', () => {
                hideCardTimeout = setTimeout(hideHoverCard, 200);
            });
            document.body.addEventListener('mousemove', (e) => {
                positionHoverCard(e);
            });

            // Sync scrolling between hierarchy and timeline
            const gridWrapper = document.querySelector('.timeline-grid-wrapper');
            gridWrapper.addEventListener('scroll', () => {
                timelineHeaderWrapper.scrollLeft = gridWrapper.scrollLeft;
                hierarchyBody.scrollTop = gridWrapper.scrollTop;
            });

            // View toggle functionality
            const chronologicalViewBtn = document.getElementById('chronological-view-btn');
            const zoneViewBtn = document.getElementById('zone-view-btn');
            
            chronologicalViewBtn.addEventListener('click', () => {
                viewMode = 'chronological';
                updateViewToggleButtons();
                render();
            });
            
            zoneViewBtn.addEventListener('click', () => {
                viewMode = 'zone';
                updateViewToggleButtons();
                render();
            });

            // Matched items filter
            const showMatchedOnlyCheckbox = document.getElementById('show-matched-only');
            showMatchedOnlyCheckbox.addEventListener('change', (e) => {
                showMatchedOnly = e.target.checked;
                updateMatchCount();
                render();
            });

            // Modal functionality
            chooseFileBtn.addEventListener('click', () => {
                fileTypeModal.classList.remove('hidden');
                lucide.createIcons();
            });

            closeModal.addEventListener('click', () => {
                fileTypeModal.classList.add('hidden');
            });

            // Close modal when clicking outside
            fileTypeModal.addEventListener('click', (e) => {
                if (e.target === fileTypeModal) {
                    fileTypeModal.classList.add('hidden');
                }
            });

            // Schedule option
            scheduleOption.addEventListener('click', () => {
                fileTypeModal.classList.add('hidden');
                scheduleCsvUpload.click();
            });

            // Actualized option
            actualizedOption.addEventListener('click', () => {
                fileTypeModal.classList.add('hidden');
                actualizedCsvUpload.click();
            });

            // Schedule CSV upload and processing
            scheduleCsvUpload.addEventListener('change', e => {
                const file = e.target.files[0];
                processCsvBtn.disabled = !file;
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function(evt) {
                    const text = evt.target.result;
                    const rows = parseCsv(text);
                    const treeData = buildTreeFromCsv(rows);
                    processData(treeData);
                };
                reader.readAsText(file);
            });

            // Actualized CSV upload and processing
            actualizedCsvUpload.addEventListener('change', e => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function(evt) {
                    const text = evt.target.result;
                    const rows = parseCsv(text);
                    actualizedData = rows;
                    if (projectData) {
                        matchActualizedData();
                        render();
                    }
                };
                reader.readAsText(file);
            });

            processCsvBtn.addEventListener('click', () => {
    if (!projectData) return;
    showLoading();
    setTimeout(() => {
        render();
        populateFilterPanel();
    }, 100); // Allow loading indicator to render
});
        }

        // Call once on load
        setupEventListeners();

        // --- Data Handling ---
        /**
         * Parses CSV text into an array of row objects, stripping quotes and trimming whitespace.
         * @param {string} text - The CSV text.
         * @returns {Array<Object>} Array of row objects.
         */
        function parseCsv(text) {
            function stripQuotes(str) {
                return str.replace(/^"+|"+$/g, '').trim();
            }
            const lines = text.split(/\r?\n/).filter(line => line.trim());
            if (lines.length < 2) return [];
            // Normalize headers: trim, lowercase, strip quotes
            const rawHeaders = lines[0].split(',').map(h => stripQuotes(h).toLowerCase());
            // Map normalized headers to expected keys
            const headerMap = {
                'location': 'location',
                'activity id': 'activity id',
                'activity name': 'activity name',
                'start date': 'start date',
                'finish date': 'finish date',
                'duration': 'duration'
            };
            const headers = rawHeaders.map(h => headerMap[h] || h);
            const rows = lines.slice(1).map(line => {
                const values = line.split(',').map(stripQuotes);
                const obj = {};
                headers.forEach((h, i) => {
                    obj[h] = values[i] !== undefined ? values[i] : '';
                });
                return obj;
            });
            if (rows.length) console.log('First parsed row:', rows[0]);
            return rows;
        }

        /**
         * Finds a data item by id in a tree of items.
         * @param {Array} items - The tree to search.
         * @param {string} id - The id to find.
         * @returns {Object|null} The found item or null.
         */
        function findDataItem(items, id) {
            for (const item of items) {
                if (item.id === id) return item;
                if (item.children) {
                    const found = findDataItem(item.children, id);
                    if (found) return found;
                }
            }
            return null;
        }

        /**
         * Updates the match count display.
         */
        function updateMatchCount() {
            if (!projectData || !Array.isArray(projectData.children)) {
                document.getElementById('match-count').textContent = '';
                return;
            }

            let totalItems = 0;
            let matchedItems = 0;

            function countRecursive(items) {
                items.forEach(item => {
                    if (item.level === 3) {
                        totalItems++;
                        if (item.hasActualData) {
                            matchedItems++;
                        }
                    }
                    if (item.children) {
                        countRecursive(item.children);
                    }
                });
            }

            countRecursive(projectData.children);
            
            const matchCountElement = document.getElementById('match-count');
            if (matchedItems > 0) {
                matchCountElement.textContent = `${matchedItems}/${totalItems} matched`;
            } else {
                matchCountElement.textContent = '';
            }
        }

        /**
         * Updates the view toggle button states.
         */
        function updateViewToggleButtons() {
            const chronologicalViewBtn = document.getElementById('chronological-view-btn');
            const zoneViewBtn = document.getElementById('zone-view-btn');
            
            if (viewMode === 'chronological') {
                chronologicalViewBtn.className = 'px-3 py-1.5 text-sm font-medium rounded-md transition-colors bg-blue-600 text-white shadow-sm';
                zoneViewBtn.className = 'px-3 py-1.5 text-sm font-medium rounded-md transition-colors text-slate-700 hover:bg-slate-100';
            } else {
                chronologicalViewBtn.className = 'px-3 py-1.5 text-sm font-medium rounded-md transition-colors text-slate-700 hover:bg-slate-100';
                zoneViewBtn.className = 'px-3 py-1.5 text-sm font-medium rounded-md transition-colors bg-blue-600 text-white shadow-sm';
            }
        }

        /**
         * Shows the hover card for a timeline bar.
         * @param {MouseEvent} event
         * @param {Object} task
         */
        function showHoverCard(event, task) {
            document.getElementById('hover-card-img').src = `https://placehold.co/600x400/a3a3a3/ffffff?text=${encodeURIComponent(task.activityName)}`;
            document.getElementById('hover-card-title').textContent = task.activityName;
            document.getElementById('hover-card-group').textContent = task.location;
            document.getElementById('hover-card-status').textContent = task.status;
            document.getElementById('hover-card-planned').textContent = `${task.startDate} to ${task.endDate}`;
            document.getElementById('hover-card-actual').textContent = `${task.actualStartDate} to ${task.actualEndDate || 'Present'}`;
            hoverCard.classList.remove('hidden');
            setTimeout(() => hoverCard.classList.remove('opacity-0'), 10); // Fade in
            positionHoverCard(event);
        }

        /**
         * Hides the hover card.
         */
        function hideHoverCard() {
            hoverCard.classList.add('opacity-0');
            setTimeout(() => hoverCard.classList.add('hidden'), 200); // Wait for fade out
        }

        /**
         * Positions the hover card near the mouse.
         * @param {MouseEvent} event
         */
        function positionHoverCard(event) {
            const offsetX = 15;
            const offsetY = 15;
            hoverCard.style.left = `${event.clientX + offsetX}px`;
            hoverCard.style.top = `${event.clientY + offsetY}px`;
        }

        function exportCsv(activities) {
    const headers = ['Location','Activity ID','Activity Name','Start Date','Finish Date','Duration'];
    const rows = [headers.join(',')];
    activities.forEach(a => {
        rows.push([
            a.location || '',
            a.activityId || a.id || '',
            a.activityName || a.name || '',
            a.startDate || '',
            a.endDate || '',
            a.duration || ''
        ].join(','));
    });
    const blob = new Blob([rows.join('\n')], {type:'text/csv'});
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = 'filtered_schedule.csv';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);
}
        // --- Initial Render ---
        render();
        populateFilterPanel();
        updateViewToggleButtons();
    </script>

    <!-- Global Sidebar Script -->
    <script src="../global-sidebar.js"></script>
    <script>
        // Initialize Lucide icons
        lucide.createIcons();
    </script>
</body>
</html> 